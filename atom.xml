<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quanluo&#39;s blog</title>
  
  <subtitle>Not only can I write code well, but I can also swim well</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quanluo.github.io/"/>
  <updated>2023-07-08T05:59:09.525Z</updated>
  <id>http://quanluo.github.io/</id>
  
  <author>
    <name>Quanluo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单总结下设计模式的六大原则</title>
    <link href="http://quanluo.github.io/2023/07/08/%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://quanluo.github.io/2023/07/08/%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2023-07-08T05:54:49.000Z</published>
    <updated>2023-07-08T05:59:09.525Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式的六大原则是一组指导软件设计的准则和原则，旨在帮助开发人员编写灵活、可扩展和易于维护的代码。以下是这些原则的正确总结：</p><ol><li>单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。换句话说，每个类应该负责一项明确的功能或责任。这有助于提高代码的可读性、可维护性和可测试性。</li><li>开闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着在添加新功能时，不应该修改现有的代码，而是通过扩展现有代码来实现。</li></ol><a id="more"></a><ol><li>里氏替换原则（Liskov Substitution Principle，LSP）：子类应该能够替代父类，而不会影响程序的正确性。也就是说，继承关系应该遵循父类与子类之间的约定，子类应该能够无缝地替代父类。</li><li>迪米特法则（Law of Demeter，LoD）：一个对象应该只与其直接的朋友进行交互，而不应该了解整个系统的详细内部结构。换句话说，一个对象应该尽可能少地与其他对象进行通信，减少对象之间的直接依赖关系。</li><li>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖于它不需要的接口。将大型接口拆分成更小、更具体的接口，可以避免客户端依赖于无用的接口，提高系统的灵活性和可维护性。</li><li>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。具体的实现细节应该依赖于抽象接口或基类，而不是相反。这样做可以减少模块之间的耦合度，提高代码的可扩展性和可测试性。</li></ol><p>这些设计原则提供了指导开发人员编写高质量、可维护和易于扩展的代码的准则。它们有助于降低代码的耦合度、增加代码的灵活性，并提供更好的可测试性和可复用性。在实践中，结合使用这些原则可以帮助开发人员设计出更加优雅和可靠的软件系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式的六大原则是一组指导软件设计的准则和原则，旨在帮助开发人员编写灵活、可扩展和易于维护的代码。以下是这些原则的正确总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。换句话说，每个类应该负责一项明确的功能或责任。这有助于提高代码的可读性、可维护性和可测试性。&lt;/li&gt;
&lt;li&gt;开闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着在添加新功能时，不应该修改现有的代码，而是通过扩展现有代码来实现。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://quanluo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="六大原则" scheme="http://quanluo.github.io/tags/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>每日Java面经（Day6）</title>
    <link href="http://quanluo.github.io/2023/07/08/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day6%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/07/08/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day6%EF%BC%89/</id>
    <published>2023-07-08T05:54:12.000Z</published>
    <updated>2023-07-08T10:42:26.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Redis过期键的删除策略有哪些？"><a href="#1、Redis过期键的删除策略有哪些？" class="headerlink" title="1、Redis过期键的删除策略有哪些？"></a>1、Redis过期键的删除策略有哪些？</h3><p>在Redis中，过期键的删除策略主要有两种：</p><ol><li>定期删除策略（定时删除）： Redis会通过定时任务来主动删除已过期的键。每隔一段时间，Redis会扫描部分设置了过期时间的键，并删除过期的键。该策略可以确保过期键及时被删除，但也会带来一定的性能开销。</li><li>惰性删除策略（延迟删除）： 当客户端对某个键进行读写操作时，Redis会先检查该键是否过期，如果过期则会立即删除。这种策略避免了对所有键进行主动扫描的开销，但可能会导致过期键在一段时间内没有被删除。</li></ol><p>这两种策略在Redis中是同时使用的。定期删除策略用于删除过期键的大部分，而惰性删除策略则在客户端访问键时处理那些被定期删除策略漏掉的过期键。通过这样的组合，Redis可以高效地管理过期键并提供良好的性能。</p><a id="more"></a><h3 id="2、Redis删除策略的优点和缺点有哪些？"><a href="#2、Redis删除策略的优点和缺点有哪些？" class="headerlink" title="2、Redis删除策略的优点和缺点有哪些？"></a>2、Redis删除策略的优点和缺点有哪些？</h3><p>Redis的删除策略有以下几个优点和缺点：</p><p>优点：</p><ol><li>高效性能：Redis的删除策略设计得非常高效，能够在维护数据的同时处理过期键的删除，不会对系统整体性能产生明显的影响。</li><li>低内存占用：Redis使用了惰性删除策略，只有在访问到过期键时才会进行删除操作，因此可以在一定程度上减少内存的占用。</li><li>简单易用：Redis的删除策略实现相对简单，管理过期键的逻辑较为清晰，方便使用和维护。</li></ol><p>缺点：</p><ol><li>不保证即时删除：惰性删除策略可能导致过期键在一段时间内仍保留在Redis中，直到被访问时才进行删除。这意味着过期键的删除不是即时的，而是延迟的。</li><li>随机性删除：定期删除策略是随机选择部分设置了过期时间的键进行删除，这样可能导致某些键长时间未被检查从而长时间保留在Redis中。</li><li>对于大量过期键的情况，定期删除策略可能会对系统性能产生一定影响，因为需要在一定周期内执行大量的删除操作。</li></ol><p>综上所述，Redis的删除策略在绝大多数场景下能够提供高效的过期键管理，但在某些特定情况下可能需要额外的措施来保证过期键的及时删除。</p><h3 id="3、什么是热点Key问题？什么样的key被称为热key？如何解决热点Key？"><a href="#3、什么是热点Key问题？什么样的key被称为热key？如何解决热点Key？" class="headerlink" title="3、什么是热点Key问题？什么样的key被称为热key？如何解决热点Key？"></a>3、什么是热点Key问题？什么样的key被称为热key？如何解决热点Key？</h3><p>热点Key问题是指在分布式系统中，某些特定的Key被频繁访问，导致负载不均衡的情况。当某个Key成为热点Key时，它所在的节点会承受大量的请求压力，而其他节点的负载相对较低，从而造成性能瓶颈和系统不稳定。</p><p>被称为热点Key的Key具有以下特点：</p><ol><li>高访问频率：某个Key被频繁地读取或写入。</li><li>数据量较大：热点Key对应的数据量较大，导致处理该Key的节点负担过重。</li><li>业务逻辑关联度高：与热点Key关联的操作可能需要访问其他相关数据，进一步增加了负载压力。</li></ol><p>解决热点Key问题的方法包括：</p><ol><li>缓存层面的解决方案：使用缓存来减轻对后端存储系统（如数据库）的访问压力。可以将热点Key的数据缓存在内存中，以提高读取速度，并通过合适的缓存策略（例如LRU、LFU等）来管理缓存的大小和替换策略。</li><li>分片（Sharding）：将热点Key进行分片，将其均匀地分散到多个节点上，以平衡负载。可以采用哈希算法或一致性哈希算法来确定热点Key应该被分配到哪个节点上。</li><li>数据重排（Data Repartitioning）：重新规划数据的分布方式，将数据合理地划分到不同的存储节点上，避免某个Key集中在一个节点上。</li><li>动态调整：根据实时负载情况，动态地调整热点Key的分配策略和节点的资源分配，以保持负载均衡。</li><li>水平扩展（Horizontal Scaling）：增加处理热点Key的节点数量，使负载更均衡。可以通过增加节点数目或者使用负载均衡器来实现。</li></ol><p>需要根据具体的系统架构和业务场景选择合适的解决方案，有时需要综合运用多种方法来解决热点Key问题。</p><h3 id="4、Redis是单线程的吗？"><a href="#4、Redis是单线程的吗？" class="headerlink" title="4、Redis是单线程的吗？"></a>4、Redis是单线程的吗？</h3><p>Redis 是单线程的。</p><p>Redis 使用单线程模型来处理客户端请求和操作。这意味着 Redis 在任意给定时间只能执行一个命令，而不是并行处理多个命令。</p><p>由于 Redis 使用单线程模型，它能够避免多线程带来的线程竞争和锁的开销，简化了内部数据结构的实现，并提高了读取和写入操作的速度。此外，Redis 通过使用高效的数据结构和异步 I/O 等技术，进一步提升了性能。</p><p>然而，需要注意的是，Redis 在某些情况下可以利用多核处理器的优势。例如，在具有多个 Redis 实例的主从复制架构中，每个实例可以运行在不同的 CPU 核心上，以实现并行处理多个客户端请求。此外，Redis 还可以通过使用多个 Redis 实例和负载均衡器来实现横向扩展，并提高整体的吞吐量。</p><p>总结起来，Redis 是单线程的，它利用单线程模型、高效的数据结构和异步 I/O 技术来提供出色的性能和响应速度。</p><h3 id="5、Redis-String类型的底层是如何实现？"><a href="#5、Redis-String类型的底层是如何实现？" class="headerlink" title="5、Redis String类型的底层是如何实现？"></a>5、Redis String类型的底层是如何实现？</h3><p>Redis 的 String 类型底层是通过简单动态字符串（SDS）来实现的。</p><p>简单动态字符串（SDS）是 Redis 自己实现的一种字符串表示方式，相较于传统的 C 字符串，SDS 提供了更多的功能和性能优势。SDS 有以下特点：</p><ol><li>常数时间复杂度的字符串长度：SDS 在其结构中保存了字符串的长度信息，可以在 O(1) 的时间复杂度内获取到字符串的长度，而无需遍历整个字符串。</li><li>自动扩容：当字符串长度超过当前分配空间时，SDS 会自动进行空间扩容，而不需要手动管理内存。扩容时会根据需要增加额外的空间，而不是按照固定的步长进行扩展。</li><li>二进制安全：SDS 可以保存任意二进制数据，而不仅限于文本数据。它的内部使用字节数组来存储字符串数据，因此可以处理任意的二进制数据。</li><li>缓冲区溢出保护：SDS 内部维护了字符串的长度信息，并通过预留空间来避免缓冲区溢出问题。</li><li>附加额外操作：SDS 提供了一些附加的操作，如追加、切割、拷贝等，使得对字符串的操作更加方便和高效。</li></ol><p>总结起来，Redis 的 String 类型底层使用简单动态字符串（SDS）实现。SDS 提供了常数时间复杂度的字符串长度、自动扩容、二进制安全、缓冲区溢出保护等特性，使得 Redis 在处理字符串类型数据时具备高效性和灵活性</p><h3 id="6、为什么Redis要用简单动态字符串-SDS？"><a href="#6、为什么Redis要用简单动态字符串-SDS？" class="headerlink" title="6、为什么Redis要用简单动态字符串 SDS？"></a>6、为什么Redis要用简单动态字符串 SDS？</h3><p>Redis 选择使用简单动态字符串（SDS）作为字符串类型的底层实现，主要基于以下几个原因：</p><ol><li>动态扩容：SDS 具备自动扩容的能力。当字符串长度超过当前分配的空间时，SDS 可以自动进行空间扩容，而不需要手动管理内存。这种动态扩容的机制使得 Redis 在处理字符串时更加灵活，不会受到固定空间大小的限制。</li><li>高效的字符串操作：SDS 提供了一些附加的操作，如追加、切割、拷贝等，使得对字符串的操作更加高效。这些操作可以在 O(1) 的时间复杂度内完成，而不需要遍历整个字符串。例如，在追加字符串时，SDS 只需要将新的字符串拼接到原有字符串的末尾，而不需要重新分配和拷贝整个字符串。</li><li>二进制安全：SDS 可以保存任意二进制数据，而不仅限于文本字符串。它的内部使用字节数组来存储字符串数据，因此能够处理任意的二进制数据。这种二进制安全性使得 Redis 在存储和处理各种类型的数据时更加灵活。</li><li>缓冲区溢出保护：SDS 内部维护了字符串的长度信息，并通过预留空间来避免缓冲区溢出问题。在进行字符串追加或修改操作时，SDS 会根据需要进行空间扩展，并确保足够的空间来容纳新的数据，从而避免了常见的缓冲区溢出漏洞。</li></ol><p>综上所述，Redis 选择使用简单动态字符串（SDS）作为字符串类型的底层实现，主要是因为 SDS 提供了动态扩容、高效的字符串操作、二进制安全性和缓冲区溢出保护等优势，使得 Redis 在处理字符串数据时更加高效、灵活和安全。</p><h3 id="7、Redis-Sorted-set类型的底层是如何实现？"><a href="#7、Redis-Sorted-set类型的底层是如何实现？" class="headerlink" title="7、Redis Sorted set类型的底层是如何实现？"></a>7、Redis Sorted set类型的底层是如何实现？</h3><p>Redis Sorted Set（有序集合）的底层实现主要包括两个数据结构：跳跃表（Skip List）和字典（Dictionary）。</p><ol><li>跳跃表（Skip List）： 跳跃表是一种有序的、分层的数据结构。它由多个层级组成，每个层级都是一个有序链表。在 Redis 中，有序集合的元素以节点的形式存储在跳跃表中，并根据元素的分值（score）进行排序。每个节点包含一个成员（member）和对应的分值。</li></ol><p>跳跃表可以通过指针跳跃连接不同层级的节点，从而提高查询效率。通过这种分层结构，跳跃表可以在平均情况下以 O(log n) 的时间复杂度进行查找、插入和删除操作。跳跃表在维护有序性的同时，具有较低的时间复杂度和较高的性能。</p><ol><li>字典（Dictionary）： 为了保证有序集合中成员的唯一性，Redis 结合跳跃表使用了字典作为附属数据结构。字典是一种基于哈希表的数据结构，以成员作为键，分值作为值，用于快速地按成员进行查找和去重。</li></ol><p>字典使用哈希表来存储键值对，通过哈希算法将成员映射到相应的哈希槽中，并使用链表处理哈希冲突。字典可以在常数时间复杂度 O(1) 内完成搜索、插入和删除操作，因此提供了快速的成员查找和唯一性保证。</p><p>通过跳跃表和字典两种数据结构的组合，Redis 实现了有序集合类型的底层存储和操作。跳跃表提供了有序性和高效的范围查询操作，而字典则提供了快速的成员查找和唯一性保证。这种综合使用不同的数据结构，使得 Redis 的有序集合能够高效地支持插入、删除、范围查询等操作，并且保持较低的复杂度。</p><p>以上就是 Redis Sorted Set 类型底层实现的主要内容。它的设计结合了跳跃表和字典，使得有序集合具备了排序、唯一性和高效操作的特点。</p><p>Redis Sorted Set 类型的底层实现可以分为以下几个步骤：</p><ol><li>创建跳跃表（Skip List）和字典（Dictionary）：<ul><li>Redis 在内存中创建一个空的跳跃表和字典，用于存储有序集合的数据。</li><li>跳跃表包括多个层级，每个层级都是一个有序链表，用于维护元素的顺序。</li><li>字典使用哈希表来存储键值对，用于快速查找成员并确保唯一性。</li></ul></li><li>插入元素：<ul><li>当执行插入操作时，首先根据成员和分值创建一个新的节点。</li><li>然后将新节点插入跳跃表中，并根据分值进行排序。</li><li>同时，将成员和对应的指针插入字典中，以便快速查找和去重。</li></ul></li><li>删除元素：<ul><li>当执行删除操作时，首先通过成员在字典中找到对应的节点。</li><li>然后在跳跃表中删除该节点，并更新各层级的指针。</li><li>最后从字典中删除成员，完成元素的删除操作。</li></ul></li><li>范围查询：<ul><li>范围查询是有序集合的一个重要功能，可以根据分值的范围获取一定区间内的元素。</li><li>在跳跃表中，可以通过分值范围快速定位到起始节点和结束节点。</li><li>然后按照节点的指针在跳跃表上遍历，并将符合范围条件的元素返回。</li></ul></li><li>更新分值：<ul><li>如果需要更新元素的分值，首先通过成员在字典中找到对应的节点。</li><li>然后修改节点的分值，并根据新的分值重新排序节点在跳跃表中的位置。</li></ul></li></ol><p>通过以上步骤，Redis Sorted Set 实现了有序集合的底层存储和操作。通过跳跃表和字典的结合，它能够提供高效的插入、删除、范围查询等功能，并保持数据的有序性和唯一性。这种设计使得 Redis 的 Sorted Set 能够在实际应用中快速响应各种操作，并支持复杂的数据处理需求。</p><h3 id="8、为什么Sorted-set底层不用二叉树，平衡树实现？"><a href="#8、为什么Sorted-set底层不用二叉树，平衡树实现？" class="headerlink" title="8、为什么Sorted set底层不用二叉树，平衡树实现？"></a>8、为什么Sorted set底层不用二叉树，平衡树实现？</h3><p>Redis Sorted Set 底层没有选择使用二叉树或平衡树的原因是出于性能和实现复杂性方面的考虑。</p><p>虽然二叉树或平衡树可以提供有序集合的功能，并且在某些情况下具有较好的查询性能，但它们的实现通常比跳跃表复杂，并且需要更多的内存来维护树结构。</p><p>相比之下，跳跃表是一种简单而高效的数据结构，具有以下优点：</p><ol><li>内存效率：跳跃表相对于树结构占用的内存空间更少。它只需要维护一系列有序链表和指针，不需要像树那样额外存储节点的引用关系，因此在存储大量元素时，跳跃表占用的内存更少。</li><li>查询性能：跳跃表在平均情况下具有良好的查询性能，其时间复杂度为 O(log n)。尽管二叉树或平衡树的查询性能也是 O(log n)，但跳跃表的实现更简单，避免了树旋转等操作，减少了计算和内存访问的开销。</li><li>实现简单性：跳跃表的实现相对简单，易于理解和调试。相比之下，二叉树或平衡树的实现更加复杂，需要处理平衡因子、旋转操作等，容易引入错误。</li></ol><p>综上所述，Redis Sorted Set 选择了跳跃表作为底层实现，因为它在提供高效查询性能的同时，也具有较低的内存消耗和简单的实现。这样的设计平衡了性能和实现复杂性，使得 Redis 的 Sorted Set 能够高效地支持插入、删除和范围查询等操作。</p><h3 id="9、讲一讲Redis持久化机制？"><a href="#9、讲一讲Redis持久化机制？" class="headerlink" title="9、讲一讲Redis持久化机制？"></a>9、讲一讲Redis持久化机制？</h3><p>Redis 提供了两种主要的持久化机制：AOF（Append Only File）持久化和 RDB（Redis DataBase）持久化。</p><ol><li>AOF 持久化：<ul><li>AOF 持久化以追加方式将每个写操作记录到日志文件中，记录的是写操作本身，以文本格式保存。</li><li>当 Redis 启动时，会重新执行 AOF 文件中保存的所有写命令，将数据恢复到内存中。</li><li>AOF 文件的写入可以配置成每秒同步（默认）、每个命令同步还是不同步，同步频率影响持久化的性能和数据安全性。</li><li>AOF 文件过大时，可以进行压缩重写，生成一份尽可能紧凑的 AOF 文件。</li></ul></li><li>RDB 持久化：<ul><li>RDB 持久化是通过生成数据库快照来保存数据，快照是 Redis 在某个时间点上的数据副本。</li><li>快照以二进制格式保存在硬盘上，通常以 dump.rdb 的文件名保存。</li><li>RDB 持久化可以手动触发或者在设定的时间间隔内自动触发生成快照。</li><li>在进行恢复时，Redis 会加载最近的 RDB 文件，并将数据恢复到内存中。</li></ul></li></ol><p>AOF 持久化将写操作以追加方式记录到文件中，提供更高的数据安全性，但文件较大、恢复速度相对较慢。RDB 持久化生成紧凑的快照文件，具有较小的文件大小和较快的恢复速度，但可能会有一定程度的数据丢失风险。</p><p>可以根据具体需求选择适合的持久化机制，也可以同时使用 AOF 和 RDB 来兼顾数据的安全性和性能。</p><h3 id="10、Redis中AOF-和-RDB持久化方式的区别？"><a href="#10、Redis中AOF-和-RDB持久化方式的区别？" class="headerlink" title="10、Redis中AOF 和 RDB持久化方式的区别？"></a>10、Redis中AOF 和 RDB持久化方式的区别？</h3><ol><li>数据存储方式：<ul><li>AOF 持久化：AOF 机制以追加的方式将写操作记录到日志文件中，保存了每个写操作的详细信息。</li><li>RDB 持久化：RDB 机制是通过生成快照来保存 Redis 数据，将内存中的数据以二进制格式保存到硬盘上。</li></ul></li><li>恢复数据的方式：<ul><li>AOF 持久化：在 Redis 重新启动时，会通过执行 AOF 文件中的写操作来还原数据。</li><li>RDB 持久化：在 Redis 重新启动时，会加载最近生成的 RDB 文件，将数据恢复到内存中。</li></ul></li><li>数据安全性：<ul><li>AOF 持久化：由于 AOF 持久化记录了每个写操作，因此数据丢失的风险比较低。</li><li>RDB 持久化：RDB 持久化在 Redis 崩溃时可能会丢失最后一次生成 RDB 文件后的数据。</li></ul></li><li>文件大小和恢复速度：<ul><li>AOF 持久化：AOF 文件通常比 RDB 文件大，因为它记录了每个写操作。恢复速度可能会比较慢，特别是处理大型 AOF 文件时。</li><li>RDB 持久化：RDB 文件通常比 AOF 文件小，因为它只包含了数据的快照信息。恢复速度相对较快，尤其是在处理大量数据时。</li></ul></li></ol><p>总体上，AOF 持久化提供了较高的数据安全性，但文件较大且恢复速度较慢。RDB 持久化文件较小，恢复速度较快，但可能会有一定的数据丢失风险。根据具体需求，可以选择合适的持久化方式或同时使用两个机制来平衡数据安全性和性能。</p><h3 id="11、如果我采取AOF持久化方式，并且想要高可靠性保证，选择哪一种写回策略，为什么？"><a href="#11、如果我采取AOF持久化方式，并且想要高可靠性保证，选择哪一种写回策略，为什么？" class="headerlink" title="11、如果我采取AOF持久化方式，并且想要高可靠性保证，选择哪一种写回策略，为什么？"></a>11、如果我采取AOF持久化方式，并且想要高可靠性保证，选择哪一种写回策略，为什么？</h3><p>如果你采取 AOF 持久化方式，并且希望实现高可靠性保证，推荐选择每个命令都进行同步的写回策略。</p><p>写回策略决定了 Redis 在执行写操作时是否等待操作成功地同步到磁盘上的 AOF 文件。在 AOF 持久化中，有以下几种写回策略可供选择：</p><ol><li><code>always</code>（默认）：每个写操作都要把数据同步到磁盘上的 AOF 文件，即使会导致性能下降。</li><li><code>everysec</code>：每秒将写操作同步到磁盘一次，以平衡性能和数据安全性。</li><li><code>no</code>：不进行同步操作，完全依赖操作系统来决定何时将数据写入磁盘。</li></ol><p>对于追求高可靠性的场景，建议选择 <code>always</code> 策略，即每个命令都进行同步。这样可以确保每个写操作都被完全记录到磁盘上的 AOF 文件中，即使出现停电或突发故障也能够最大程度地保证数据持久化和数据的完整性。尽管这种策略可能会对性能产生一些影响，但它提供了最强的数据安全保障。</p><p>请注意，选择写回策略需要根据具体的业务需求和可接受的数据安全性来进行权衡。如果对性能要求更高，可以选择 <code>everysec</code> 策略，它在一定程度上平衡了性能和数据安全性。</p><h3 id="12、如果我想要数据不能丢失，如何让RDB和AOF混合使用来满足我的诉求？"><a href="#12、如果我想要数据不能丢失，如何让RDB和AOF混合使用来满足我的诉求？" class="headerlink" title="12、如果我想要数据不能丢失，如何让RDB和AOF混合使用来满足我的诉求？"></a>12、如果我想要数据不能丢失，如何让RDB和AOF混合使用来满足我的诉求？</h3><p>要确保数据不丢失，可以将 RDB 和 AOF 混合使用，以下是设置步骤：</p><ol><li>启用 AOF 持久化方式：在 Redis 配置文件中找到 <code>appendonly</code> 选项，并将其设置为 <code>yes</code>，启用 AOF 日志记录功能。</li><li>设置 AOF 的同步频率：在配置文件中找到 <code>appendfsync</code> 选项，并将其设置为 <code>always</code>，表示每次写操作都会同步到 AOF 文件，以保证数据的安全性。这样会对性能造成一定的影响，但可以最大程度地确保数据不丢失。</li><li>设置定期执行 RDB 快照：在配置文件中找到 <code>save</code> 选项，设置定期执行 RDB 快照的条件。例如，可以设置 <code>save 60 10000</code> 表示在60秒内如果有至少10000个键被修改，则执行 RDB 快照。通过定期执行 RDB 快照，可以提供一份较新的快照备份。</li></ol><p>通过以上设置，Redis 将同时使用 AOF 和 RDB 来提供数据持久化和容灾能力。AOF 记录了每个写操作的日志，用于数据的恢复和重放。而定期执行的 RDB 快照提供了一个较新的数据备份，用于快速还原到最近的快照状态。</p><p>请注意，这种混合持久化方式可以最大限度地保证数据不丢失，但也会带来一定的性能开销。因此，在选择持久化方式时，请根据应用程序的需求和性能要求进行综合考虑，并确保定期备份和监控这些文件，以确保数据的安全性。</p><h3 id="13、Redis能实现ACID属性吗？"><a href="#13、Redis能实现ACID属性吗？" class="headerlink" title="13、Redis能实现ACID属性吗？"></a>13、Redis能实现ACID属性吗？</h3><p>Redis 是一个键值对存储系统，它主要关注的是高性能和高吞吐量，因此并不直接支持传统数据库中的 ACID（原子性、一致性、隔离性和持久性）属性。但是，Redis 提供了一些特性和命令，可以部分满足 ACID 的需求。</p><ol><li>原子性（Atomicity）：Redis 中的每个命令通常是原子执行的，即一个命令要么完全执行成功，要么完全失败，不存在中间状态。例如，使用 <code>MULTI</code> 和 <code>EXEC</code> 命令可以实现事务，一组命令要么全部执行成功，要么全部回滚，确保原子性。</li><li>一致性（Consistency）：Redis 不提供内置的一致性保证机制，因为它是一个单机数据库，不涉及复杂的分布式一致性问题。但是，应用程序可以根据自身需求，在访问 Redis 数据时维护一致性，例如通过使用队列、锁或其他手段来确保数据的一致性。</li><li>隔离性（Isolation）：Redis 是单线程的，每个命令在执行期间不会被其他命令打断，因此不存在并发冲突和隔离级别的问题。但在多个客户端同时对 Redis 进行读写操作时，可能会存在竞争条件和数据一致性的问题，需要应用程序自行管理和解决。</li><li>持久性（Durability）：Redis 提供持久化机制来确保数据的持久性。通过使用 AOF（Append-Only File）和 RDB（Redis Database Backup）机制，可以将数据写入磁盘并在重启后恢复数据。这可以提供一定程度的持久性保证，但在数据写入磁盘的过程中，仍然会有一部分数据可能丢失。</li></ol><p>总结起来，虽然 Redis 不直接实现 ACID 属性，但通过一些机制和应用程序的辅助，可以实现一部分类似的属性。如果您需要更强的 ACID 支持，可能需要考虑使用传统的关系型数据库或其他支持 ACID 的系统。</p><h3 id="14、Redis的事务可以保证原子性吗？为什么？"><a href="#14、Redis的事务可以保证原子性吗？为什么？" class="headerlink" title="14、Redis的事务可以保证原子性吗？为什么？"></a>14、Redis的事务可以保证原子性吗？为什么？</h3><p>实际上，Redis 的事务机制无法提供严格的 ACID 属性中的原子性保证。</p><p>Redis 的事务使用 MULTI、EXEC、WATCH 和 UNWATCH 等命令进行控制。通过 MULTI 命令开启一个事务，在 EXEC 命令执行时，Redis 会按顺序执行事务中的所有命令。Redis 的事务可以确保在 EXEC 执行期间，其他客户端发来的命令不会被插入其中，这种单线程的执行方式在一定程度上保证了操作的原子性。</p><p>然而，Redis 的事务机制存在以下限制：</p><ol><li>异常情况：如果 Redis 服务器崩溃、网络故障或客户端异常退出等情况发生，事务可能无法完全执行或部分执行。这种情况下，原子性无法得到保证。</li><li>监视键（WATCH）：Redis 允许使用 WATCH 命令监视一个或多个键。如果事务执行之前被监视的键发生了变化，事务将被放弃执行，避免了在监视的键发生变化时可能产生不一致结果的情况。但这仅针对被监视的键，而不是所有的键。</li><li>冲突解决：Redis 事务无法自动处理并发操作的冲突。如果多个客户端同时修改了相同的键，并且没有使用 WATCH 命令进行监视，事务的执行结果可能导致数据不一致。</li></ol><p>综上所述，Redis 的事务机制可以提供部分的原子性保证，但在特定情况下仍然存在一些限制，无法像传统关系型数据库一样提供严格的 ACID 属性的原子性保证。因此，在需要严格的事务支持的场景中，建议选择传统的关系型数据库或其他支持事务的数据库</p><h3 id="15、Redis的事务可以保证一致性吗？为什么？"><a href="#15、Redis的事务可以保证一致性吗？为什么？" class="headerlink" title="15、Redis的事务可以保证一致性吗？为什么？"></a>15、Redis的事务可以保证一致性吗？为什么？</h3><p>Redis的事务机制无法提供严格的一致性保证。一致性是指所有数据在事务开始和结束时都保持一致的状态。虽然Redis的事务机制可以确保在执行期间不会被其他客户端的命令中断，但它并不能解决并发修改引起的数据不一致性问题。</p><p>当一个事务执行过程中，如果其他客户端对事务中涉及的键进行了修改，那么Redis会放弃执行该事务，并返回一个错误。这种通过WATCH命令监视键来实现的乐观锁机制可以防止因并发修改导致的数据不一致情况。但它只能检测到与事务相关的键是否被修改，而不能解决多个客户端修改同一键所带来的冲突。</p><p>在Redis事务中，即使WATCH命令未被使用，事务中的命令仍然会按序执行，不会受到其他客户端操作的干扰。这确保了事务的原子性，即事务中的一系列命令要么全部执行成功，要么全部失败回滚。但这并不能保证最终数据的一致性。</p><p>综上所述，Redis的事务机制可以提供部分的原子性保证，但无法提供严格的一致性保证。为了实现更严格的一致性，建议使用具备分布式事务支持的数据库或采用其他数据存储和同步机制。</p><h3 id="16、Redis的事务可以保证隔离性吗？为什么？"><a href="#16、Redis的事务可以保证隔离性吗？为什么？" class="headerlink" title="16、Redis的事务可以保证隔离性吗？为什么？"></a>16、Redis的事务可以保证隔离性吗？为什么？</h3><p>Redis 的事务机制不能提供严格的隔离性保证。隔离性是指并发执行的事务之间应该相互隔离，每个事务都应该感知不到其他事务的存在。</p><p>在 Redis 的事务中，一旦事务开始执行，Redis 将按顺序执行事务中的所有命令，期间不会被其他客户端的命令中断。这种单线程执行的方式可以保证事务的原子性，即事务中的一系列命令要么全部执行成功，要么全部失败回滚。</p><p>然而，Redis 的事务机制并不能解决并发操作导致的数据不一致性问题，也就无法提供严格的隔离性。如果多个客户端同时修改了相同的键，并且没有使用 WATCH 命令进行监视，事务的执行结果可能导致数据不一致。这是因为 Redis 在事务执行期间不会对并发的修改进行阻塞或回滚，而是将这些修改合并到事务的执行流中。</p><p>因此，Redis 事务的隔离级别较低，无法提供严格的隔离性保证。在需要更高隔离级别的应用场景中，建议使用具备分布式事务支持的数据库或采用其他的并发控制机制来确保数据的隔离性。</p><h3 id="17、Redis的事务可以保证持久性吗？为什么？"><a href="#17、Redis的事务可以保证持久性吗？为什么？" class="headerlink" title="17、Redis的事务可以保证持久性吗？为什么？"></a>17、Redis的事务可以保证持久性吗？为什么？</h3><p>Redis 的事务机制无法直接保证持久性。持久性是指数据在发生故障或重启后能够恢复并保持不变的特性。</p><p>Redis 默认情况下在每个命令执行完成后就立即将数据写入磁盘（RDB 持久化或 AOF 持久化），以确保数据的持久性。然而，在 Redis 的事务中，一系列命令在 EXEC 命令执行时才会被执行，这意味着事务过程中的数据修改只会在事务执行结束后才被写入磁盘，而不会在每个命令执行完成后立即写入。</p><p>如果在事务执行期间发生 Redis 服务器崩溃、网络故障或客户端异常退出等情况，事务中的数据修改可能不会被持久化。这会导致事务中的数据丢失或回滚到之前的状态，从而影响持久性。</p><p>为了确保事务的持久性，可以在事务执行结束后使用 Redis 的持久化机制，如手动执行 BGSAVE 命令进行 RDB 持久化或开启 AOF 持久化来将事务中的数据写入磁盘。这样可以在发生故障或重启后，通过加载持久化文件来恢复事务中的数据。</p><p>综上所述，Redis 的事务机制本身无法直接保证事务的持久性，需要结合 Redis 的持久化机制来确保数据的持久性。</p><h3 id="18、Redis中的事务是否支持回滚？"><a href="#18、Redis中的事务是否支持回滚？" class="headerlink" title="18、Redis中的事务是否支持回滚？"></a>18、Redis中的事务是否支持回滚？</h3><p>Redis 的事务是不支持回滚的。</p><p>在 Redis 中，事务是通过 MULTI、EXEC 和 DISCARD 命令来实现的。MULTI 命令标记一个事务的开始，EXEC 命令用于执行所有已加入队列的命令，DISCARD 命令用于取消事务。</p><p>然而，即使在事务执行期间发生了错误，Redis 也不会回滚已经执行的命令。当发生错误时，Redis 会继续执行剩余的命令，并返回错误的结果。</p><p>因此，Redis 的事务机制并不提供回滚操作。如果需要撤消某些操作，需要在应用层面进行相应的处理。</p><p>请注意，在 Redis 中，事务主要用于将一系列的命令打包执行，以确保这些命令按顺序执行，并保证在执行期间不会被其他客户端的命令中断。但事务并不提供回滚机制，所以在使用 Redis 事务时需要特别注意异常处理和错误恢复的逻辑。</p><h3 id="19、渐进式rehash实现过程？"><a href="#19、渐进式rehash实现过程？" class="headerlink" title="19、渐进式rehash实现过程？"></a>19、渐进式rehash实现过程？</h3><p>渐进式 rehash 是 Redis 在进行扩容或收缩时使用的一种方法，用于将数据从一个哈希表（旧表）迁移到另一个哈希表（新表）。</p><p>以下是渐进式 rehash 的实现过程：</p><ol><li>Redis 创建一个新的空哈希表，作为新表。</li><li>Redis 根据设置的步长（step）值，每次从旧表中选取一部分键值对进行 rehash 操作。</li><li>Redis 将选取到的键值对从旧表移动到新表中，并更新相应的哈希槽。</li><li>在移动键值对的过程中，Redis 会检查每个被移动键所在的哈希槽是否已经被全部迁移完成。如果某个哈希槽已经没有键值对，则将其从旧表中删除，以节省内存空间。</li><li>重复步骤 2 和步骤 3，直到将旧表中的所有键值对都迁移到新表中。</li><li>最终，当所有键值对都成功迁移后，Redis 完成了渐进式 rehash 过程，并将新表作为当前的主表。</li></ol><p>渐进式 rehash 的好处是可以在迁移过程中减少对系统的影响。因为每次只迁移部分键值对，所以 Redis 的读写操作可以同时在旧表和新表上进行，保证了服务的可用性和数据一致性。</p><p>需要注意的是，渐进式 rehash 过程中，如果有新的写操作发生在旧表中的键上，这些写操作会同时被写入旧表和新表，以保证数据的一致性。读操作则会先在新表进行查询，如果找不到再尝试在旧表中查询。这样可以逐渐确保所有操作都在新表上完成后，才切换至完全使用新表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Redis过期键的删除策略有哪些？&quot;&gt;&lt;a href=&quot;#1、Redis过期键的删除策略有哪些？&quot; class=&quot;headerlink&quot; title=&quot;1、Redis过期键的删除策略有哪些？&quot;&gt;&lt;/a&gt;1、Redis过期键的删除策略有哪些？&lt;/h3&gt;&lt;p&gt;在Redis中，过期键的删除策略主要有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定期删除策略（定时删除）： Redis会通过定时任务来主动删除已过期的键。每隔一段时间，Redis会扫描部分设置了过期时间的键，并删除过期的键。该策略可以确保过期键及时被删除，但也会带来一定的性能开销。&lt;/li&gt;
&lt;li&gt;惰性删除策略（延迟删除）： 当客户端对某个键进行读写操作时，Redis会先检查该键是否过期，如果过期则会立即删除。这种策略避免了对所有键进行主动扫描的开销，但可能会导致过期键在一段时间内没有被删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种策略在Redis中是同时使用的。定期删除策略用于删除过期键的大部分，而惰性删除策略则在客户端访问键时处理那些被定期删除策略漏掉的过期键。通过这样的组合，Redis可以高效地管理过期键并提供良好的性能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java面经" scheme="http://quanluo.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Redis" scheme="http://quanluo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>每日Java面经（Day5）</title>
    <link href="http://quanluo.github.io/2023/07/07/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day5%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/07/07/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day5%EF%BC%89/</id>
    <published>2023-07-07T08:36:24.000Z</published>
    <updated>2023-07-08T05:55:07.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、TCP拥塞控制如何实现？"><a href="#1、TCP拥塞控制如何实现？" class="headerlink" title="1、TCP拥塞控制如何实现？"></a>1、TCP拥塞控制如何实现？</h3><p>当网络出现拥塞时，TCP拥塞控制使用一系列算法和机制来减少数据的发送速率，以避免进一步加剧拥塞情况。下面是TCP拥塞控制的正确实现过程：</p><ol><li>慢启动（Slow Start）：连接刚建立时，TCP发送方将拥塞窗口（Congestion Window）的大小设置为一个较小的值，通常为一个最大报文段长度（MSS）。随着每个确认报文的到达，拥塞窗口的大小逐渐增加。初始阶段，每收到一个确认就将拥塞窗口的值翻倍。这样可以逐渐增大数据传输的速率，直至网络开始出现拥塞。</li><li>拥塞避免阶段（Congestion Avoidance）：一旦拥塞窗口的大小达到一个阈值（慢启动阈值），TCP发送方就会进入拥塞避免阶段。在这个阶段，每次成功接收到一个确认报文后，拥塞窗口的大小就会线性增加（并不是翻倍增加）。每经过一个往返时间（Round Trip Time，RTT），拥塞窗口的值只会增加一个MSS。</li><li>拥塞检测（Congestion Detection）：TCP发送方通过以下两个条件来检测网络是否出现拥塞：一是发生超时，即在一定时间内未能收到确认报文；二是接收到重复的确认报文，表示网络中出现了丢包。当发生拥塞时，TCP发送方将执行拥塞控制算法。</li><li>快速重传和快速恢复：当发生拥塞时，TCP发送方会采取快速重传和快速恢复机制。当发送方接收到连续的重复确认报文时，它会立即重传丢失的报文段，并减小拥塞窗口的大小。这样可以更快地恢复数据传输速率，而不用像慢启动那样从头开始。</li><li>超时重传：如果在规定时间内没有收到确认报文，发送方将认为发生了拥塞，并进行超时重传。在超时重传中，发送方重新发送所有未确认的报文段，并将拥塞窗口的大小设置为一个较小的值，然后重新进行慢启动和拥塞避免过程。</li></ol><p>通过以上算法和机制，TCP拥塞控制实现了动态调整数据传输速率的功能，以适应网络的拥塞程度。它可以根据网络的状况来平衡数据发送的速率，避免网络拥塞和丢包，并提高网络的稳定性和吞吐量。</p><a id="more"></a><h3 id="2、什么是快重传和快恢复算法？"><a href="#2、什么是快重传和快恢复算法？" class="headerlink" title="2、什么是快重传和快恢复算法？"></a>2、什么是快重传和快恢复算法？</h3><p>快重传（Fast Retransmit）和快恢复（Fast Recovery）是TCP拥塞控制算法中的两个关键机制，用于在网络出现拥塞时更快地恢复数据传输速率。</p><p>在传统的TCP拥塞控制算法中，当TCP发送方发现一个报文段丢失时，会等待一段时间，直到超时重传定时器到期才会进行重传。这种方式可能导致等待时间过长，降低了数据传输的效率。为了解决这个问题，快重传和快恢复算法被引入。</p><p>快重传算法的核心思想是：当TCP发送方接收到连续的重复确认报文时，它会推断下一个报文段已经丢失，并立即进行重传，而不需要等待超时定时器。通过这种方式，TCP发送方可以更早地获知丢失的报文段，并立即采取行动，从而避免不必要的等待时间。</p><p>快恢复算法则用于在快重传后更快地恢复数据传输速率。当发送方执行快重传后，它将进入快恢复状态，并减小拥塞窗口的大小。但与慢启动不同，快恢复状态下，拥塞窗口的大小不会回到慢启动阶段，而是线性增加。每收到一个确认报文，拥塞窗口的大小增加一个最大报文段长度（MSS）。</p><p>通过快重传和快恢复机制，TCP可以更快地恢复数据传输速率，而无需等待超时定时器到期。这样可以充分利用网络带宽，提高数据传输效率，并减少对网络拥塞的影响。总之，快重传和快恢复是TCP拥塞控制算法中的重要机制，有助于提高网络性能和传输效率。</p><h3 id="3、每一层对应的网络协议有哪些？"><a href="#3、每一层对应的网络协议有哪些？" class="headerlink" title="3、每一层对应的网络协议有哪些？"></a>3、每一层对应的网络协议有哪些？</h3><ol><li>物理层：物理层主要处理传输介质、电压等物理特性，负责比特流的传输。常见的物理层协议有Ethernet（以太网）、Wi-Fi、Bluetooth等。</li><li>数据链路层：数据链路层负责将数据分割成帧并进行可靠的点对点传输。最著名的数据链路层协议是以太网（Ethernet），其他还包括PPP（点对点协议）、HDLC（高级数据链路控制）等。</li><li>网络层：网络层负责实现网络互连和路由选择，将数据包从源主机传递到目标主机。常见的网络层协议有IP（Internet Protocol，因特网协议）、ICMP（Internet Control Message Protocol，因特网控制报文协议）、IPSec（Internet Protocol Security，因特网协议安全）等。</li><li>传输层：传输层负责提供端到端的数据传输服务，确保数据的可靠性和完整性。最常用的传输层协议是TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）。</li><li>应用层：应用层提供基于网络的应用程序之间的通信服务。常见的应用层协议有HTTP（Hypertext Transfer Protocol，超文本传输协议）、FTP（File Transfer Protocol，文件传输协议）、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）等。</li></ol><p>这些协议是根据TCP/IP模型进行分类，是目前广泛使用的网络通信协议。请注意，这只是一种分层模型，在实际网络中，某些协议可能会在多个层次上起作用，并且还存在其他一些特定的协议和标准。</p><p><strong>（补充）</strong></p><p>除了TCP/IP模型，还有OSI（开放系统互联）参考模型。OSI模型是国际标准化组织（ISO）提出的一种分层模型，它将计算机网络通信过程划分为七个不同的层次：</p><ol><li>物理层：负责物理媒介（如电缆、光纤）上比特流的传输。</li><li>数据链路层：提供错误检测和纠正，以及对物理连接的访问控制。</li><li>网络层：处理数据包在网络中的路由选择和转发，实现端到端的数据传输。</li><li>传输层：负责可靠的端到端数据传输，提供数据的分段和重组、流量控制和错误恢复等功能。</li><li>会话层：建立、管理和终止应用程序之间的会话连接。</li><li>表示层：处理数据的格式和编码，确保不同系统之间的数据可互操作性。</li><li>应用层：提供网络应用程序与用户之间的接口，包括文件传输、电子邮件、远程登录等。</li></ol><p>OSI模型与TCP/IP模型在结构和功能上存在一些差异，但都是用来描述计算机网络通信过程中不同层次的协议和功能。这两种模型都对网络通信的分层架构提供了标准化的参考。</p><h3 id="4、WebSocket-与-Socket-的区别？"><a href="#4、WebSocket-与-Socket-的区别？" class="headerlink" title="4、WebSocket 与 Socket 的区别？"></a>4、WebSocket 与 Socket 的区别？</h3><ol><li>WebSocket是一种基于TCP协议的双向通信协议，旨在提供实时的、持久的连接，使得服务器和客户端能够在同一个连接上进行双向的数据传输。它通过HTTP协议的升级机制实现握手，并在连接建立后使用自定义的WebSocket协议进行通信。</li><li>Socket是一种通用的网络编程接口，可以支持不同传输层协议（如TCP和UDP），用于在网络上建立连接并进行数据传输。它提供了底层的API来管理网络连接、发送和接收数据，需要开发者负责处理协议、连接状态和数据解析等细节。</li><li>WebSocket适用于需要实时双向通信的应用场景，如在线聊天、实时游戏等。它通过保持长连接来避免频繁建立或关闭连接的开销，并提供了更高效的双向数据传输方式。</li><li>Socket适用于更广泛的网络编程应用场景，无论是实时通信还是离线数据传输。它提供了更底层的控制能力，可以自定义协议和数据格式，并且支持多种传输层协议。</li></ol><p>总结来说，WebSocket是一种专门用于实时双向通信的协议，提供了更高层次的抽象和便捷性。而Socket是一种通用的网络编程接口，用于各种网络通信需求，但需要开发者自行处理连接管理和数据解析。选择WebSocket还是Socket取决于具体应用的需求和使用场景。</p><h3 id="5、HTTP与HTTPS的区别"><a href="#5、HTTP与HTTPS的区别" class="headerlink" title="5、HTTP与HTTPS的区别?"></a>5、HTTP与HTTPS的区别?</h3><p>HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是用于在客户端和服务器之间传输数据的通信协议，它们的主要区别如下：</p><ol><li>安全性：HTTP是明文传输的协议，数据在传输过程中不进行加密。这意味着通过HTTP传输的数据容易被网络攻击者窃听、篡改或伪装。而HTTPS使用SSL/TLS协议对通信进行加密，确保传输的数据在网络上是安全的，不容易被第三方恶意获取和修改。</li><li>数据完整性与身份验证：HTTPS不仅可以加密数据，还能够验证通信双方的身份和保证数据的完整性。HTTPS使用数字证书来验证服务器的身份，并确保在传输过程中数据没有被篡改。</li><li>默认端口：HTTP的默认端口是80，而HTTPS的默认端口是443。通过默认端口，浏览器和服务器能够识别使用的通信协议。</li><li>性能：由于加密和身份验证等额外的操作，HTTPS在一定程度上比HTTP具有较大的性能开销。因此，如果没有特殊的安全需求，对于一般的网页浏览等场景，使用HTTP可以获得更高的性能。</li></ol><p>综上所述，HTTPS相比于HTTP提供了更高的安全性，适用于需要保护敏感信息传输的场景，如在线支付、用户登录等。而HTTP适用于不涉及敏感信息传输或对性能要求较高的场景，例如一般网页浏览。</p><h3 id="6、HTTPS为什么是安全的？"><a href="#6、HTTPS为什么是安全的？" class="headerlink" title="6、HTTPS为什么是安全的？"></a>6、HTTPS为什么是安全的？</h3><p>HTTPS之所以被认为是安全的，是因为它通过以下几种方式提供了数据传输的安全性：</p><ol><li>加密：HTTPS使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对通信进行加密。在建立HTTPS连接时，客户端和服务器之间会进行密钥交换，并使用该密钥对通信过程中的数据进行加密。这意味着即使网络上的数据被窃听，攻击者也无法解读加密后的数据。</li><li>数据完整性：在HTTPS通信过程中，数据会被分割成小块并计算校验和，然后经过哈希函数进行散列运算生成消息摘要。接收方在接收数据时会重新计算摘要，并与发送方发送的摘要进行比较。如果两者一致，说明数据在传输过程中没有被篡改。</li><li>身份验证：HTTPS使用数字证书来验证服务器的身份。服务器需要拥有有效的数字证书，由受信任的第三方机构（证书颁发机构，Certificate Authority）颁发。客户端在与服务器建立连接时会验证证书的合法性和有效性，确保正在连接的服务器是合法可信的。</li></ol><p>通过加密、数据完整性验证和身份验证等机制，HTTPS提供了更高的安全性。这使得用户可以放心地在HTTPS连接上进行敏感数据的传输，如登录账户、在线支付等。同时，HTTPS还能够有效防止网络攻击者对用户数据进行窃听、篡改或冒充服务器的行为，保护用户隐私和数据安全。</p><h3 id="7、TCP-和-UDP-的区别？"><a href="#7、TCP-和-UDP-的区别？" class="headerlink" title="7、TCP 和 UDP 的区别？"></a>7、TCP 和 UDP 的区别？</h3><p>TCP（传输控制协议）和UDP（用户数据报协议）是TCP/IP协议族中的两个主要传输层协议，它们有以下几个主要区别：</p><ol><li>连接性：<ul><li>TCP是面向连接的协议，使用三次握手建立连接，确保可靠的数据传输。通信之前需要先建立连接，并在通信结束后断开连接。</li><li>UDP是无连接的协议，通信双方不需要事先建立连接，直接发送数据报。每个数据报都是独立的，没有先后顺序和重组机制。</li></ul></li><li>可靠性：<ul><li>TCP提供可靠的数据传输机制，使用确认、重传、序列号等技术来确保数据的正确性和完整性。如果数据包丢失或损坏，TCP会重新发送该数据包，直到接收方正确接收。</li><li>UDP不提供可靠性保证，它只是简单地将数据报发送出去，并不关心是否到达目标，也不会进行重传操作。因此，UDP适用于对可靠性要求较低但实时性要求较高的应用，如音视频传输、实时游戏等。</li></ul></li><li>传输效率：<ul><li>TCP的可靠性机制会引入一定的传输延迟和额外的开销，包括确认、重传、拥塞控制等。因此，相比UDP，TCP的传输效率较低。</li><li>UDP没有可靠性机制，传输效率较高。它适用于对实时性要求较高、并且能够容忍少量丢包的应用场景。</li></ul></li><li>数据长度：<ul><li>TCP发送的数据是以字节流的形式进行传输的，可以支持任意长度的数据。</li><li>UDP发送的数据被限制在一个数据报的长度内（通常被限制在64KB），如果数据超过了这个限制，需要进行分片处理。</li></ul></li><li>应用场景：<ul><li>TCP适用于对数据可靠性要求较高的应用，如文件传输、网页浏览、电子邮件等。</li><li>UDP适用于对实时性要求较高、数据传输量较大且能够容忍少量丢包的应用，如音视频传输、实时游戏、DNS查询等。</li></ul></li></ol><p>综上所述，TCP和UDP在连接性、可靠性、传输效率、数据长度和应用场景等方面有明显的区别，选择合适的协议取决于具体的需求和应用场景。</p><h3 id="8、有哪些应用使用的是TCP协议，哪些应用使用的是UDP协议？"><a href="#8、有哪些应用使用的是TCP协议，哪些应用使用的是UDP协议？" class="headerlink" title="8、有哪些应用使用的是TCP协议，哪些应用使用的是UDP协议？"></a>8、有哪些应用使用的是TCP协议，哪些应用使用的是UDP协议？</h3><p>使用TCP协议的应用程序：</p><ol><li>HTTP（超文本传输协议）：用于在Web浏览器和Web服务器之间传输网页内容。</li><li>HTTPS（HTTP安全）：在HTTP基础上增加了安全层，用于加密传输敏感数据的网页内容。</li><li>FTP（文件传输协议）：用于在客户端和服务器之间传输文件。</li><li>SMTP（简单邮件传输协议）：用于发送电子邮件。</li><li>POP3（邮局协议版本3）：用于从服务器接收电子邮件。</li><li>IMAP（Internet消息访问协议）：用于从服务器接收和管理电子邮件。</li></ol><p>使用UDP协议的应用程序：</p><ol><li>DNS（域名系统）：用于将域名转换为IP地址，进行域名解析。</li><li>DHCP（动态主机配置协议）：用于自动分配IP地址和其他网络配置信息给客户端设备。</li><li>TFTP（小型文件传输协议）：用于在客户端和服务器之间传输小型文件。</li><li>SNMP（简单网络管理协议）：用于网络设备的远程管理和监控。</li><li>VoIP（IP电话）：用于实时语音通信。</li><li>视频游戏：许多实时多人在线游戏使用UDP传输，因为它对实时性要求高，并且可以容忍少量丢包。</li></ol><p>需要注意的是，某些应用程序可能同时使用TCP和UDP协议。例如，Skype在登录和消息传递时使用TCP，但在语音和视频通信时使用UDP。具体使用哪种协议还取决于应用程序设计和需求。</p><h3 id="9、用户输入网址到显示对应页面的全过程？"><a href="#9、用户输入网址到显示对应页面的全过程？" class="headerlink" title="9、用户输入网址到显示对应页面的全过程？"></a>9、用户输入网址到显示对应页面的全过程？</h3><p>用户输入网址到显示对应页面的全过程包括以下步骤：</p><ol><li>用户在浏览器地址栏中输入网址（例如：<a href="http://www.example.com/" target="_blank" rel="noopener">www.example.com</a>）。</li><li>浏览器将网址发送给DNS（域名系统）服务器，以获取网址对应的IP地址。</li><li>DNS服务器返回网址对应的IP地址给浏览器。</li><li>浏览器使用获取到的IP地址与服务器建立TCP连接。</li><li>浏览器通过TCP连接向服务器发送HTTP请求。</li><li>服务器接收到HTTP请求，并根据请求的内容做出响应。</li><li>服务器将响应的内容以HTTP响应的形式发送回浏览器。</li><li>浏览器接收到HTTP响应后，解析响应的内容。</li><li>如果响应是HTML文档，浏览器会解析HTML文件，同时下载其中引用的CSS、JavaScript和其他资源文件。</li><li>浏览器渲染HTML文档，并将所有相关资源展示在用户界面上，最终显示对应的页面内容。</li></ol><p>这个过程主要涉及到用户输入、域名解析、建立TCP连接、发送/接收HTTP请求和响应、解析和渲染网页等步骤。每个步骤都是为了将用户输入的网址转化为对应的页面内容并呈现给用户。</p><h3 id="10、TCP协议如何保证可靠性？"><a href="#10、TCP协议如何保证可靠性？" class="headerlink" title="10、TCP协议如何保证可靠性？"></a>10、TCP协议如何保证可靠性？</h3><p>TCP（传输控制协议）采用了以下机制来保证数据的可靠传输：</p><ol><li>应答确认（Acknowledgement）：TCP发送数据后会等待接收方的应答确认。如果发送方在合理时间内没有收到确认，就会认为数据丢失或者损坏，并重新发送数据。</li><li>序列号（Sequence Number）和确认号（Acknowledgement Number）：TCP在每个数据段中使用序列号和确认号字段。序列号用于标识发送的数据段的顺序，确认号用于标识期望接收的下一个数据段的序列号。</li><li>重传机制：如果发送方没有收到确认消息或者发现数据丢失，TCP会启动重传机制，重新发送未确认的数据段。接收方可以通过确认号标识出它已经成功接收的数据，从而避免数据重复。</li><li>滑动窗口（Sliding Window）：TCP使用滑动窗口机制来控制发送方和接收方之间的数据流量。滑动窗口确定了发送方可以发送多少个字节的数据，在接收方进行确认之前，发送方只能发送窗口大小内的数据。</li><li>流量控制：TCP使用流量控制机制来平衡发送方和接收方之间的数据流量。接收方可以通过通告窗口大小来告知发送方它所能接收的数据量，从而避免接收方被大量数据淹没。</li><li>拥塞控制：TCP使用拥塞控制机制来避免网络发生拥塞，保持网络的稳定性和可靠性。通过动态调整发送方的发送速率，TCP可以根据网络的负载情况来控制数据的发送。</li></ol><p>通过以上的机制，TCP协议能够提供可靠的数据传输，保证了数据在发送和接收之间的正确性、完整性和可靠性。</p><h3 id="11、三次握手和四次握手"><a href="#11、三次握手和四次握手" class="headerlink" title="11、三次握手和四次握手"></a>11、三次握手和四次握手</h3><p><strong>三次握手的实现原理</strong>：</p><ol><li>第一步：客户端向服务器发送一个SYN（同步）报文，表示客户端请求建立连接。</li><li>第二步：服务器收到SYN报文后，确认客户端的请求，并发送一个SYN-ACK（同步-确认）报文作为响应。</li><li>第三步：客户端收到服务器的SYN-ACK报文后，再发送一个ACK（确认）报文给服务器，表示客户端接受服务器的响应。</li></ol><p>这样，三次握手完成，连接建立成功。通过三次握手，双方都确认了对方的确能收发数据，建立了可靠的连接。</p><p><strong>四次握手的实现原理</strong>：</p><ol><li>第一步：当客户端想要关闭连接时，发送一个FIN（结束）报文给服务器，表示客户端不再发送数据。</li><li>第二步：服务器收到FIN报文后，发送一个ACK报文作为响应，确认客户端的关闭请求。</li><li>第三步：服务器进入CLOSE_WAIT状态，等待直到它没有要发送的数据。</li><li>第四步：服务器发送一个FIN报文给客户端，表示服务器准备关闭连接。</li><li>第五步：客户端收到服务器的FIN报文后，发送一个ACK报文作为响应，确认服务器的关闭请求。</li><li>第六步：客户端进入TIME_WAIT状态，等待一段时间后才彻底关闭连接，确保服务器接收到自己的ACK报文。</li></ol><p>这样，四次握手完成，连接关闭成功。通过四次握手，双方都确认了彼此的关闭意图，并且确保数据完整性。</p><p>三次握手和四次握手的目的是为了建立和断开连接时的双向确认，确保通信双方的可靠性和数据的完整性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、TCP拥塞控制如何实现？&quot;&gt;&lt;a href=&quot;#1、TCP拥塞控制如何实现？&quot; class=&quot;headerlink&quot; title=&quot;1、TCP拥塞控制如何实现？&quot;&gt;&lt;/a&gt;1、TCP拥塞控制如何实现？&lt;/h3&gt;&lt;p&gt;当网络出现拥塞时，TCP拥塞控制使用一系列算法和机制来减少数据的发送速率，以避免进一步加剧拥塞情况。下面是TCP拥塞控制的正确实现过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;慢启动（Slow Start）：连接刚建立时，TCP发送方将拥塞窗口（Congestion Window）的大小设置为一个较小的值，通常为一个最大报文段长度（MSS）。随着每个确认报文的到达，拥塞窗口的大小逐渐增加。初始阶段，每收到一个确认就将拥塞窗口的值翻倍。这样可以逐渐增大数据传输的速率，直至网络开始出现拥塞。&lt;/li&gt;
&lt;li&gt;拥塞避免阶段（Congestion Avoidance）：一旦拥塞窗口的大小达到一个阈值（慢启动阈值），TCP发送方就会进入拥塞避免阶段。在这个阶段，每次成功接收到一个确认报文后，拥塞窗口的大小就会线性增加（并不是翻倍增加）。每经过一个往返时间（Round Trip Time，RTT），拥塞窗口的值只会增加一个MSS。&lt;/li&gt;
&lt;li&gt;拥塞检测（Congestion Detection）：TCP发送方通过以下两个条件来检测网络是否出现拥塞：一是发生超时，即在一定时间内未能收到确认报文；二是接收到重复的确认报文，表示网络中出现了丢包。当发生拥塞时，TCP发送方将执行拥塞控制算法。&lt;/li&gt;
&lt;li&gt;快速重传和快速恢复：当发生拥塞时，TCP发送方会采取快速重传和快速恢复机制。当发送方接收到连续的重复确认报文时，它会立即重传丢失的报文段，并减小拥塞窗口的大小。这样可以更快地恢复数据传输速率，而不用像慢启动那样从头开始。&lt;/li&gt;
&lt;li&gt;超时重传：如果在规定时间内没有收到确认报文，发送方将认为发生了拥塞，并进行超时重传。在超时重传中，发送方重新发送所有未确认的报文段，并将拥塞窗口的大小设置为一个较小的值，然后重新进行慢启动和拥塞避免过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过以上算法和机制，TCP拥塞控制实现了动态调整数据传输速率的功能，以适应网络的拥塞程度。它可以根据网络的状况来平衡数据发送的速率，避免网络拥塞和丢包，并提高网络的稳定性和吞吐量。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java面经" scheme="http://quanluo.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="计算机网络" scheme="http://quanluo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>每日Java面经（Day4）</title>
    <link href="http://quanluo.github.io/2023/07/06/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day4%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/07/06/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day4%EF%BC%89/</id>
    <published>2023-07-06T07:48:27.000Z</published>
    <updated>2023-07-06T09:57:58.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、线程有哪些状态？"><a href="#1、线程有哪些状态？" class="headerlink" title="1、线程有哪些状态？"></a>1、线程有哪些状态？</h3><p>在Java中，线程有以下几种状态：</p><ol><li>新建（New）：当我们创建一个线程实例但尚未调用其start()方法时，线程处于新建状态。此时线程并不会执行任何代码。</li><li>运行（Runnable）：当调用线程实例的start()方法后，线程进入运行状态。在运行状态中，线程可以被CPU调度执行任务。</li><li>阻塞（Blocked）：当线程在等待某个特定条件（如获取锁或等待I/O操作完成）时，它可能会进入阻塞状态。在这个状态下，线程暂时停止执行，并且不消耗CPU资源。</li><li>等待（Waiting）：线程进入等待状态是因为调用了wait()方法、join()方法或 LockSupport.park()方法。在等待状态下，线程会一直等待直到其他线程唤醒它。</li><li>超时等待（Timed Waiting）：线程进入超时等待状态是因为调用了Thread.sleep()方法、Object.wait()方法的指定时间版本，或者使用LockSupport.parkNanos()、LockSupport.parkUntil()方法。在指定的时间内，线程将会处于超时等待状态。</li><li>终止（Terminated）：线程执行完其run()方法的代码或者出现异常而终止后，进入终止状态。已终止的线程不会再被调度执行。</li></ol><a id="more"></a><h3 id="2、sleep-方法和-wait-方法区别"><a href="#2、sleep-方法和-wait-方法区别" class="headerlink" title="2、sleep() 方法和 wait() 方法区别?"></a>2、sleep() 方法和 wait() 方法区别?</h3><p>sleep()方法和wait()方法是用于线程控制的两个不同的方法，它们之间有以下几个区别：</p><ol><li>调用位置：sleep()方法是Thread类的静态方法，可以在任何地方直接调用；而wait()方法是Object类的方法，只能在同步代码块或同步方法中调用。</li><li>使用对象：sleep()方法不会释放锁，它仅仅是让当前线程休眠指定的时间，然后继续执行。而wait()方法会释放对象的锁，并使当前线程进入等待状态，直到其他线程调用相同对象的notify()或notifyAll()方法来唤醒等待的线程。</li><li>唤醒方式：通过调用notify()方法可以随机唤醒处于等待状态的一个线程（如果有多个等待线程，则按照线程优先级来选择）；而notifyAll()方法则会唤醒所有等待的线程。对于sleep()方法，线程会在指定的时间后自动苏醒。</li><li>对象锁：当线程调用wait()方法时，它会释放持有的对象锁，从而允许其他线程进入同步块或同步方法。而sleep()方法并不会释放对象锁。</li><li>唤醒条件：线程调用wait()方法进入等待状态后，只有其他线程调用相同对象的notify()或notifyAll()方法才能唤醒等待的线程。而调用sleep()方法的线程会在指定时间内自动苏醒，不需要其他线程的干预。</li></ol><p>综上所述，sleep()方法主要用于控制线程的休眠时间，不涉及同步和锁的问题；而wait()方法则用于线程之间的协作，当一个线程需要等待某个条件满足时，可以调用wait()方法使其进入等待状态，并释放对象锁，以便其他线程可以执行相关操作。</p><h3 id="3、偏向锁是什么？轻量级锁是什么？"><a href="#3、偏向锁是什么？轻量级锁是什么？" class="headerlink" title="3、偏向锁是什么？轻量级锁是什么？"></a>3、偏向锁是什么？轻量级锁是什么？</h3><ol><li>偏向锁（Biased Locking）：偏向锁是为了解决无竞争情况下的同步操作性能问题而引入的锁优化机制。当一个线程访问一个同步块时，如果该同步块没有被其他线程访问过，那么该线程会自动获取对象的偏向锁，并标记为已偏向。这样，在后续的操作中，该线程再次进入同步块时就不需要再进行加锁的操作，因为它已经持有了对象的偏向锁。偏向锁可以减少无竞争情况下的同步操作，提升程序性能。然而，如果有其他线程尝试竞争同一个锁，则偏向锁会被撤销，线程会转而使用轻量级锁或重量级锁。</li><li>轻量级锁（Lightweight Locking）：轻量级锁是针对低竞争情况下的锁优化技术。当一个线程访问一个同步块时，如果该同步块没有被其他线程占用，那么该线程会尝试使用CAS（Compare and Swap）操作将对象头部的标志位设置为 “锁定” 状态，来获取锁。这个过程是非阻塞的，所以称之为轻量级锁。如果CAS操作成功，表示该线程成功获取了锁，并且可以直接执行同步操作。如果CAS操作失败，则表示其他线程已经占用了锁，当前线程需要进行自旋等待，直到获取到锁或者自旋次数达到一定阈值后，转为使用重量级锁进行锁的升级。</li></ol><p>总结起来，偏向锁和轻量级锁都是为了优化多线程同步的性能。偏向锁适用于无竞争的情况，可以减少同步操作的开销；轻量级锁适用于低竞争的情况，可以减少线程间的竞争和上下文切换。而在竞争激烈的情况下，这两种锁机制可能会退化为重量级锁，以保证线程安全。</p><h3 id="4、讲一讲synchronized锁升级过程？"><a href="#4、讲一讲synchronized锁升级过程？" class="headerlink" title="4、讲一讲synchronized锁升级过程？"></a>4、讲一讲synchronized锁升级过程？</h3><p>synchronized 锁的升级过程如下：</p><ol><li>偏向锁（Biased Locking）阶段：当一个线程访问一个同步块时，如果该同步块没有被其他线程竞争，那么该线程会自动获取对象的偏向锁，并标记为已偏向。这个过程是非常快速的，不涉及任何同步操作。在偏向锁状态下，线程可以重入同步块而无需重新获取锁。</li><li>轻量级锁（Lightweight Locking）阶段：如果有另一个线程尝试竞争同一个锁，则偏向锁会被撤销，线程会尝试使用CAS（Compare and Swap）操作将对象头部的标志位设置为 “轻量级锁” 状态来获取锁。这个过程是非阻塞的，仍然尝试保持低开销。如果CAS操作成功，即当前线程成功获取了锁，可以直接执行同步操作。如果CAS操作失败，表示有其他线程已经占用了锁，则当前线程需要进行自旋等待，直到获取到锁或自旋次数达到一定阈值。</li><li>重量级锁（Heavyweight Locking）阶段：当自旋等待次数超过一定阈值时，轻量级锁会升级为重量级锁。此时，当前线程会进入阻塞状态，锁会被转化为互斥量（Mutex）实现，即通过操作系统提供的互斥机制来实现同步。</li></ol><p>需要注意的是，锁的升级过程是逐级升级的，即从偏向锁到轻量级锁，再到重量级锁。而且，锁的降级是不可行的，一旦锁升级为重量级锁，就无法再降级为轻量级锁或偏向锁。</p><p>这个升级过程是为了在不同竞争情况下提供更高效的同步操作，根据实际的场景和并发情况来选择合适的锁机制，以优化程序的性能。</p><h3 id="5、CAS了解多少？"><a href="#5、CAS了解多少？" class="headerlink" title="5、CAS了解多少？"></a>5、CAS了解多少？</h3><p>CAS（Compare And Swap，比较并交换）是一种原子操作，常用于并发编程中实现线程安全的同步操作。CAS 操作包含三个参数：内存地址 V、旧的预期值 A 和新的值 B。</p><p>CAS 的工作原理如下：</p><ol><li>首先，它会读取内存地址 V 的当前值。</li><li>接着，它会将读取到的值与预期值 A 进行比较。如果相等，则说明现在的内存值与预期值一致，可以执行接下来的操作。</li><li>如果相等，CAS 会原子地将新的值 B 写入内存地址 V，也就是把旧的内存值替换为新值。</li><li>如果不相等，说明其他线程已经修改了内存地址 V 的值，当前 CAS 操作失败，需要重新尝试。</li></ol><p>CAS 操作是基于硬件指令的支持，在底层实现了原子性的读-改-写操作。由于 CAS 是无锁操作，避免了传统锁机制中的竞争与上下文切换，因此具有较高的性能和可伸缩性。</p><p>CAS 在并发编程中广泛应用于无锁算法、乐观锁机制和并发数据结构的实现，例如 Java 中的 Atomic 原子类就是基于 CAS 实现的。然而，使用 CAS 时需要考虑内存一致性的问题，以及 CAS 操作可能导致的ABA问题（即值在操作过程中经历变化、又回到原值的情况），需要采取相应的处理措施来解决这些问题。</p><h3 id="6、CAS底层实现原理？"><a href="#6、CAS底层实现原理？" class="headerlink" title="6、CAS底层实现原理？"></a>6、CAS底层实现原理？</h3><ol><li>首先，它会读取内存地址 V 的当前值，并将其与预期值 A 进行比较。</li><li>如果比较结果相等，说明当前内存值与预期值一致，此时它会使用原子指令将新的值 B 写入内存地址 V，并返回操作成功。</li><li>如果比较结果不相等，说明其他线程已经修改了内存地址 V 的值，CAS 操作失败，需要重新尝试。</li></ol><h3 id="7、AQS了解多少？"><a href="#7、AQS了解多少？" class="headerlink" title="7、AQS了解多少？"></a>7、AQS了解多少？</h3><p>AQS（AbstractQueuedSynchronizer）是 Java 并发包中的一个抽象基类，用于构建同步器。它提供了一种框架，使开发者可以自定义各种并发组件，如锁、信号量、栅栏等。</p><p>AQS 的核心思想是使用一个基于先进先出原则的等待队列来管理线程的竞争和阻塞状态。AQS 内部维护了一个表示状态的变量，并通过对状态的操作来实现线程的排队和唤醒。通过继承 AQS 类并实现其中的方法，开发者可以定制化自己的同步器。</p><p>AQS 提供了一些基本的操作方法，如获取锁（acquire）和释放锁（release），同时还提供了一些辅助方法供子类使用。开发者可以通过继承 AQS 并重写这些方法来实现各种同步器，满足特定的需求。</p><p>在 Java 并发包中，很多重要的同步组件都是基于 AQS 实现的，比如 ReentrantLock、CountDownLatch、Semaphore 等。AQS 的设计提供了强大而灵活的支持，使得开发者能够更容易地构建高效且可靠的并发组件。</p><p>总之，AQS 是 Java 中用于构建同步器的抽象基类。通过继承 AQS 并实现其中的方法，开发者可以创建自定义的同步组件，实现并发控制。AQS 提供了强大的基础框架，使得并发编程变得更加简单和灵活。</p><h3 id="8、ReentrantLock公平锁实现原理？"><a href="#8、ReentrantLock公平锁实现原理？" class="headerlink" title="8、ReentrantLock公平锁实现原理？"></a>8、ReentrantLock公平锁实现原理？</h3><p>ReentrantLock（可重入锁）是Java中提供的一种同步机制，它有两种模式：非公平模式和公平模式。在这里，我将重点解释公平锁的实现原理。</p><p>公平锁的实现原理基于AbstractQueuedSynchronizer（AQS）的队列机制。当多个线程争夺锁时，公平锁会按照线程的先后顺序来获取锁，即先到先得的原则。</p><p>具体实现原理如下：</p><ol><li>当一个线程请求锁时，如果锁当前没有被其他线程持有，则该线程可以立即获得锁，并将锁的占有数加一。</li><li>如果锁已经被其他线程持有，或者有其他线程在等待队列中排队，则当前线程会被加入到等待队列中，并处于阻塞状态。</li><li>当锁被释放时，AQS 会按照队列的顺序唤醒等待队列中的第一个线程，使其获得锁。被唤醒的线程会再次尝试获取锁，只有当它位于等待队列头部并且成功获取锁时，才算真正获得了锁。</li></ol><p>总结来说，ReentrantLock 公平锁的实现原理是基于 AbstractQueuedSynchronizer 的等待队列机制。它按照线程的先后顺序来获取锁，并在释放锁时按照队列的顺序唤醒等待线程，从而实现了公平性。</p><h3 id="9、ReentrantLock非公平锁实现原理？"><a href="#9、ReentrantLock非公平锁实现原理？" class="headerlink" title="9、ReentrantLock非公平锁实现原理？"></a>9、ReentrantLock非公平锁实现原理？</h3><ol><li>当一个线程请求锁时，如果锁当前没有被其他线程持有，则该线程可以立即获得锁，并将锁的占有数加一。</li><li>如果锁已经被其他线程持有，当前线程会尝试使用 CAS（Compare and Swap）操作来尝试获取锁。</li><li>如果失败，说明锁被其他线程持有，当前线程会将自己插入到等待队列的尾部，并进入阻塞状态。</li><li>当锁被释放时，AQS 会唤醒等待队列中的头部线程，使其能够再次尝试获取锁。</li><li>被唤醒的线程再次尝试获取锁，只有当它成功获取锁时，才算真正获得了锁。如果获取失败，被唤醒的线程会继续留在等待队列中，等待下一次重新竞争锁。</li></ol><p>总结来说，ReentrantLock 的非公平模式允许线程在没有遵循先来先服务原则的情况下获取锁，并且是通过使用等待队列和 CAS 操作来实现的。这种模式可以提高性能，可以提高整体的吞吐量，但不保证公平性，可能会导致某些线程饥饿的情况。</p><h3 id="10、线程池有哪些核心参数？"><a href="#10、线程池有哪些核心参数？" class="headerlink" title="10、线程池有哪些核心参数？"></a>10、线程池有哪些核心参数？</h3><p>线程池的核心参数包括以下几个：</p><ol><li>核心线程数（Core Pool Size）：线程池中同时运行的核心线程数。当有任务提交给线程池时，如果核心线程数尚未达到上限，线程池会创建新的核心线程来处理任务。</li><li>最大线程数（Maximum Pool Size）：线程池中允许存在的最大线程数。当核心线程数已满且工作队列也已满时，线程池会创建新的非核心线程来处理任务，但不会超过最大线程数。</li><li>线程存活时间（Keep Alive Time）：当线程池中的线程数量超过核心线程数时，空闲线程的存活时间。如果一个线程在空闲时间超过设定的存活时间后仍未被使用，那么它将被终止并从线程池中移除。</li><li>工作队列（Work Queue）：用于保存等待执行的任务的队列。当线程池中的线程已满时，新的任务会被放入工作队列等待执行。</li><li>拒绝策略（Rejected Execution Handler）：当线程池和工作队列已经达到最大容量，并且无法接受新的任务时，拒绝策略决定如何处理这些被拒绝的任务。</li></ol><p>除了这些核心参数外，线程池的实现还可能包含其他非必需的参数，如线程名称前缀、任务超时时间等，它们可以根据具体的使用场景进行配置。</p><h3 id="11、讲讲线程池的工作方式？"><a href="#11、讲讲线程池的工作方式？" class="headerlink" title="11、讲讲线程池的工作方式？"></a>11、讲讲线程池的工作方式？</h3><p>线程池的工作方式如下所述：</p><ol><li>初始化线程池：线程池在创建时会初始化一定数量的核心线程，并将它们置于等待就绪状态。</li><li>提交任务：当有任务被提交给线程池时，线程池会按照一定的策略进行任务处理。通常情况下，线程池会先尝试使用空闲的核心线程来执行任务，如果所有核心线程都在执行任务，则将任务放入工作队列中。</li><li>任务处理：空闲的核心线程或者从工作队列中获取到任务的线程会执行任务。线程执行完一个任务后，会从工作队列中取下一个任务继续执行。</li><li>动态调整线程数量：如果工作队列中的任务数量持续增加，线程池可以根据设定的最大线程数动态地创建新的线程，以加快任务处理速度。相反，如果任务数量减少，线程池会逐渐回收多余的线程，以节省资源消耗。</li><li>异常处理：线程池需要对任务执行过程中可能出现的异常进行处理。一般情况下，线程池会捕获任务执行时抛出的异常，并将其记录下来，以便后续分析和处理。</li><li>关闭线程池：当任务处理完成或者不再需要线程池时，需要及时关闭线程池。关闭线程池的操作包括两个步骤：首先，停止接收新的任务，并等待已提交的任务执行完毕；然后，终止所有线程，释放资源。</li></ol><p>通过使用线程池，可以提高系统的并发性能，避免反复创建和销毁线程的开销，并有效地管理线程资源。</p><h3 id="12、如果线程到达-maximumPoolSize-仍然有新任务来临，并且该任务的优先级比较高，不允许直接丢弃，希望该任务立即执行，如何处理？"><a href="#12、如果线程到达-maximumPoolSize-仍然有新任务来临，并且该任务的优先级比较高，不允许直接丢弃，希望该任务立即执行，如何处理？" class="headerlink" title="12、如果线程到达 maximumPoolSize 仍然有新任务来临，并且该任务的优先级比较高，不允许直接丢弃，希望该任务立即执行，如何处理？"></a>12、如果线程到达 maximumPoolSize 仍然有新任务来临，并且该任务的优先级比较高，不允许直接丢弃，希望该任务立即执行，如何处理？</h3><p>如果线程池的线程数已达到最大值并且有高优先级的任务到达时，可以使用<code>CallerRunsPolicy</code>策略来处理。该策略会将任务交给提交任务的线程自己来执行，而不会在新建线程。</p><p>以下是一个示例代码，展示了如何使用<code>CallerRunsPolicy</code>策略(让调用者运行任务)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPoolExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池，其中核心线程数为2，最大线程数为4，工作队列容量为10</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置自定义的拒绝策略为CallerRunsPolicy</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务到线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"Task "</span> + taskId + <span class="string">" is running on thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个 <code>ThreadPoolExecutor</code> 对象，并设置了核心线程数为2，最大线程数为4，工作队列容量为10。然后，我们使用 <code>setRejectedExecutionHandler()</code> 方法设置了拒绝策略为 <code>CallerRunsPolicy</code>。</p><p>当线程池的线程数达到最大值并且工作队列已满时，如果有新的任务到达，该任务将由提交任务的线程自己来执行，而不会创建新的线程。这样可以确保新任务能够得到立即执行，但也需要注意潜在的性能影响。</p><p>请注意，使用<code>CallerRunsPolicy</code>策略时，任务的执行会发生在提交任务的线程上，而不是在线程池的线程上。</p><h3 id="补充，线程池的拒绝策略，JDK提供了四种拒绝策略"><a href="#补充，线程池的拒绝策略，JDK提供了四种拒绝策略" class="headerlink" title="补充，线程池的拒绝策略，JDK提供了四种拒绝策略"></a>补充，线程池的拒绝策略，JDK提供了四种拒绝策略</h3><p><strong>AbortPolicy</strong> 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p><p><strong>CallerRunsPolicy</strong> 让调用者运行任务</p><p><strong>DiscardPolicy</strong> 放弃本次任务</p><p><strong>DiscardOldestPolicy</strong> 放弃队列中最旧的任务，本任务取而代之，以便立即执行新到达的高优先级任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Predefined RejectedExecutionHandlers */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment">   * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment">   * unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment">   * is discarded.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Executes task r in the caller's thread, unless the executor</span></span><br><span class="line"><span class="comment">       * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              r.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                               <span class="string">" rejected from "</span> +</span><br><span class="line">                                               e.toString());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment">   * rejected task.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment">   * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment">   * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">       * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">       * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">       * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              e.getQueue().poll();</span><br><span class="line">              e.execute(r);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、线程有哪些状态？&quot;&gt;&lt;a href=&quot;#1、线程有哪些状态？&quot; class=&quot;headerlink&quot; title=&quot;1、线程有哪些状态？&quot;&gt;&lt;/a&gt;1、线程有哪些状态？&lt;/h3&gt;&lt;p&gt;在Java中，线程有以下几种状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建（New）：当我们创建一个线程实例但尚未调用其start()方法时，线程处于新建状态。此时线程并不会执行任何代码。&lt;/li&gt;
&lt;li&gt;运行（Runnable）：当调用线程实例的start()方法后，线程进入运行状态。在运行状态中，线程可以被CPU调度执行任务。&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）：当线程在等待某个特定条件（如获取锁或等待I/O操作完成）时，它可能会进入阻塞状态。在这个状态下，线程暂时停止执行，并且不消耗CPU资源。&lt;/li&gt;
&lt;li&gt;等待（Waiting）：线程进入等待状态是因为调用了wait()方法、join()方法或 LockSupport.park()方法。在等待状态下，线程会一直等待直到其他线程唤醒它。&lt;/li&gt;
&lt;li&gt;超时等待（Timed Waiting）：线程进入超时等待状态是因为调用了Thread.sleep()方法、Object.wait()方法的指定时间版本，或者使用LockSupport.parkNanos()、LockSupport.parkUntil()方法。在指定的时间内，线程将会处于超时等待状态。&lt;/li&gt;
&lt;li&gt;终止（Terminated）：线程执行完其run()方法的代码或者出现异常而终止后，进入终止状态。已终止的线程不会再被调度执行。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Java面经" scheme="http://quanluo.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="JUC" scheme="http://quanluo.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>每日Java面经（Day3）</title>
    <link href="http://quanluo.github.io/2023/07/05/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day3%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/07/05/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day3%EF%BC%89/</id>
    <published>2023-07-05T06:43:14.000Z</published>
    <updated>2023-07-05T08:33:47.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、了解哪些集合？"><a href="#1、了解哪些集合？" class="headerlink" title="1、了解哪些集合？"></a>1、了解哪些集合？</h3><ol><li><strong>List</strong>（列表）：List是有序的集合，可以包含重复元素。常见的List实现类有<strong>ArrayList</strong>（动态数组）、<strong>LinkedList</strong>（链表）和<strong>Vector</strong>（向量）等。</li><li><strong>Set</strong>（集合）：Set是不允许重复元素的集合，它没有顺序。常见的Set实现类有<strong>HashSet</strong>、<strong>TreeSet</strong>和<strong>LinkedHashSet</strong>等。</li><li><strong>Map</strong>（映射）：Map是一种键值对（Key-Value）的集合，每个键（Key）都是唯一的。常见的Map实现类有<strong>HashMap</strong>、<strong>TreeMap</strong>和<strong>LinkedHashMap</strong>等。</li><li>Queue（队列）：Queue是一种先进先出（FIFO）的集合，通常用于实现队列或任务调度等场景。常见的Queue实现类有<strong>LinkedList</strong>、<strong>PriorityQueue</strong>和<strong>ArrayDeque</strong>等。</li></ol><a id="more"></a><h3 id="2、HashMap-和-TreeMap-的区别？"><a href="#2、HashMap-和-TreeMap-的区别？" class="headerlink" title="2、HashMap 和 TreeMap 的区别？"></a>2、HashMap 和 TreeMap 的区别？</h3><p>HashMap和TreeMap是Java中两种常见的Map实现类，它们之间有以下几个主要区别：</p><ol><li>内部结构：HashMap使用哈希表（哈希桶数组 + 链表/红黑树），而TreeMap使用红黑树（平衡二叉搜索树）来存储键值对。</li><li>键的排序：HashMap中的键是无序的，没有特定的顺序。而TreeMap中的键是有序的，按照键的自然顺序或自定义比较器进行排序。因此，在TreeMap中迭代键值对时，其顺序是确定的。</li><li>性能：HashMap的插入、删除和查找操作的平均时间复杂度为O(1)，具有很高的性能。而TreeMap的插入、删除和查找操作的平均时间复杂度为O(logN)，其中N为元素的数量。</li><li>排序功能：由于TreeMap的键是有序的，因此它提供了一些与排序相关的方法，如firstKey()、lastKey()、higherKey()、lowerKey()等。这使得在需要按照键的顺序遍历或获取子映射时，TreeMap更加方便。</li><li>对象比较：HashMap使用equals()方法来判断键的相等性，而TreeMap使用compareTo()方法或自定义的比较器来判断键的顺序和相等性。因此，在使用自定义对象作为键时，需要确保对象正确实现了equals()和compareTo()方法，以便在HashMap和TreeMap中正常工作。</li></ol><p>总之，HashMap适用于大多数情况，它提供了较好的性能，但不保证键的顺序。而TreeMap适用于需要有序的键值对集合，它提供了排序功能，但相对于HashMap，性能稍低。选择使用哪种实现类取决于具体的需求和使用场景。</p><h3 id="3、HashMap-jdk8与jdk7区别？"><a href="#3、HashMap-jdk8与jdk7区别？" class="headerlink" title="3、HashMap jdk8与jdk7区别？"></a>3、HashMap jdk8与jdk7区别？</h3><p>JDK8中的HashMap相对JDK7进行了一些改进和优化，主要体现在以下几个方面：</p><ol><li>红黑树：在JDK8中，当链表长度超过阈值（默认为8）时，JDK8会将链表转换为红黑树。这样可以提高在链表较长时的查询和删除性能，使得HashMap在处理大量元素时具有更好的性能表现。</li><li>优化的哈希算法：JDK8对于计算哈希值的方法进行了优化，使得在正常情况下，哈希冲突的概率降低，从而提高HashMap的性能。</li><li>存储结构调整：JDK8中的HashMap在内部存储结构上进行了微调，包括对Node节点的存储方式做了改进，减少了内存消耗。</li><li>扩容优化：JDK8对HashMap的扩容机制进行了调整，采用了更加高效的方式。比如在进行扩容时，JDK8可以同时处理多个链表，从而减少了扩容过程中的迁移操作次数，提高了扩容的效率。</li><li>并发性优化：尽管HashMap仍然不是线程安全的，但在JDK8中，对于并发环境下的HashMap使用，提供了更好的性能和并发控制。JDK8的HashMap引入了新的方法<code>putIfAbsent()</code>和<code>remove(key, value)</code>，使用了CAS（Compare and Swap）机制来实现非阻塞的原子操作，以减少同步开销。</li></ol><p>总的来说，JDK8中的HashMap相对于JDK7进行了一些性能上的优化和改进。它在处理大量元素、哈希冲突较多的情况下表现更好，并且提供了更高效的扩容机制和非阻塞的原子操作，从而提升了HashMap的性能和并发安全性。</p><h3 id="4、HashMap为什么线程不安全？"><a href="#4、HashMap为什么线程不安全？" class="headerlink" title="4、HashMap为什么线程不安全？"></a>4、HashMap为什么线程不安全？</h3><p>HashMap在多线程环境下是不安全的，主要有以下原因：</p><ol><li>不同步操作：HashMap的实现不是线程安全的，它没有内部同步机制来保护并发访问。当多个线程同时操作HashMap时，可能导致数据结构被破坏，从而出现意想不到的结果。</li><li>破坏内部结构：HashMap的内部结构是由数组和链表（或红黑树）组成的。在并发修改的情况下，如果多个线程同时进行插入、删除或调整大小等操作，就会导致数据结构出现错误，例如链表断裂或环形链表等问题。</li><li>读写冲突：当一个线程正在对HashMap执行写操作（例如插入或删除元素），而另一个线程正在读取HashMap中的元素，就会产生读写冲突。这可能导致读取到不一致或无效的数据。</li><li>迭代异常：如果在迭代HashMap的过程中，其他线程对HashMap进行了修改，可能会导致ConcurrentModificationException异常或无限循环等问题。</li></ol><h3 id="5、JDK1-7中的-HashMap-使用头插法插入元素为什么会出现环形链表？"><a href="#5、JDK1-7中的-HashMap-使用头插法插入元素为什么会出现环形链表？" class="headerlink" title="5、JDK1.7中的 HashMap 使用头插法插入元素为什么会出现环形链表？"></a>5、JDK1.7中的 HashMap 使用头插法插入元素为什么会出现环形链表？</h3><p>在JDK1.7中的HashMap实现中，当发生哈希冲突（即两个或多个键映射到了同一个索引位置）时，HashMap采用的是头插法（也称为链表插入法）来处理冲突。头插法是指新插入的元素被放置在链表的头部。</p><p>然而，由于头插法的使用，在并发环境下，可能会导致环形链表的出现。这种情况发生在以下步骤中：</p><ol><li>在执行插入操作时，如果多个线程同时发生哈希冲突，它们可能会同时将自己的节点插入到链表的头部。</li><li>当两个线程同时插入到同一个桶（bucket）的头部时，它们都会修改桶的引用，使其指向自己的节点。</li><li>由于并发操作，这两个节点之间的先后顺序无法保证。因此，有可能一个节点插入后，另一个节点才能被插入，从而造成环形链表。</li></ol><p>当发生环形链表时，一些操作可能会导致无限循环，例如在遍历链表或者计算链表长度时。这会导致HashMap无法正常工作且性能下降。</p><p>为了解决这个问题，在JDK1.8及以后的版本中，HashMap采用了尾插法（也称为红黑树）来处理哈希冲突，从而避免了环形链表的产生。只有当链表长度超过一定阈值时，才会将链表转换为红黑树，进一步提高了HashMap在高并发情况下的性能和稳定性。</p><h3 id="6、哪种HashMap是线程安全的？"><a href="#6、哪种HashMap是线程安全的？" class="headerlink" title="6、哪种HashMap是线程安全的？"></a>6、哪种HashMap是线程安全的？</h3><p>在Java中，<code>java.util.concurrent</code>包提供了一个线程安全的版本的HashMap，即<code>ConcurrentHashMap</code>。<code>ConcurrentHashMap</code>是一种支持高并发操作的线程安全的哈希表实现。</p><p><code>ConcurrentHashMap</code>通过将整个存储空间分割为多个段（segments）来实现线程安全性。每个段相当于一个小的HashMap，拥有自己的锁。不同的线程可以同时访问不同的段，从而提高了并发性能。</p><p>相比于传统的HashMap，在高并发环境下，<code>ConcurrentHashMap</code>具有更好的性能和可伸缩性。多个线程可以同时读取和写入<code>ConcurrentHashMap</code>，而不会导致数据不一致或抛出异常。</p><p>需要注意的是，虽然<code>ConcurrentHashMap</code>是线程安全的，但是在某些情况下，仍然需要额外的同步措施来保证数据的原子性和一致性。例如，如果要进行原子的复合操作，比如<code>putIfAbsent()</code>、<code>compute()</code>等，仍然需要使用<code>put()</code>和<code>get()</code>等方法的组合，并在外部进行同步。</p><p>总结起来，如果需要在多线程环境下使用HashMap，并且保证线程安全性，推荐使用<code>ConcurrentHashMap</code>。它提供了更好的并发性能和线程安全性。</p><h3 id="7、ConcurrentHashMap-的1-7版本和1-8版本的实现原理？"><a href="#7、ConcurrentHashMap-的1-7版本和1-8版本的实现原理？" class="headerlink" title="7、ConcurrentHashMap 的1.7版本和1.8版本的实现原理？"></a>7、ConcurrentHashMap 的1.7版本和1.8版本的实现原理？</h3><ol><li>ConcurrentHashMap 1.7 版本的实现原理：<ul><li>1.7 版本的ConcurrentHashMap使用了分段锁（Segment）的机制。它将整个哈希表划分为多个段，每个段相当于一个小的HashMap。每个段都有自己的锁，不同的线程可以同时访问不同的段，从而提高并发性能。</li><li>在1.7版本中，每个Segment继承自ReentrantLock，使用独占锁来保护其内部的数据结构。这意味着在同一时间只能有一个线程进行写操作，但允许多个线程同时进行读操作。</li><li>每个Segment内部使用类似于HashMap的数据结构来存储键值对，每个键值对称为一个Entry。</li><li>通过控制对Segment加锁的粒度，1.7版本的ConcurrentHashMap在一定程度上减少了锁的竞争，提高了并发性能。</li></ul></li><li>ConcurrentHashMap 1.8 版本的实现原理：<ul><li>1.8 版本的ConcurrentHashMap摒弃了分段锁的方式，采用了更加先进的CAS(Compare and Swap)算法和synchronized关键字的组合来实现线程安全性。</li><li>在1.8版本中，ConcurrentHashMap使用了一种称为”红黑树”的数据结构来替代1.7版本中的链表。当一个桶（bucket）中的节点数量超过一定阈值时，该桶内的链表会转换成红黑树，以提高查找的效率。</li><li>1.8版本还引入了一种名为”扩容”的机制，它能够动态改变哈希表的大小以适应元素的增加。扩容时，ConcurrentHashMap会将每个桶中的元素进行重新哈希并重新分配到新的桶中，以保持负载均衡。</li><li>在1.8版本中，ConcurrentHashMap使用了更细粒度的锁控制，通过针对不同节点或树进行同步，减少了线程争用的程度，提高了并发性能。</li></ul></li></ol><p>综上所述，ConcurrentHashMap的1.7版本通过分段锁机制实现线程安全，而1.8版本则采用了CAS算法、红黑树和更细粒度的锁控制，进一步优化了性能和并发能力。</p><h3 id="补充：CAS-Compare-and-Swap-算法"><a href="#补充：CAS-Compare-and-Swap-算法" class="headerlink" title="补充：CAS(Compare and Swap)算法"></a>补充：CAS(Compare and Swap)算法</h3><p>CAS（Compare and Swap）算法是一种用于实现多线程并发操作的原子性操作。它通常用于解决多线程环境下的数据竞争问题，保证共享变量的原子性操作，避免竞态条件。</p><p>CAS 算法的基本思想是比较当前变量的值与期望的值是否相等，如果相等，则将变量的值更新为新的值；如果不相等，则说明其他线程已经修改了变量的值，当前线程需要重新尝试。</p><p>CAS 算法的执行过程如下：</p><ol><li>读取共享变量的当前值和期望的值。</li><li>比较当前值和期望值是否相等，如果相等，则执行步骤4；如果不相等，则执行步骤3。</li><li>其他线程已经修改了变量的值，当前线程需要重新读取最新的值，并重复步骤2。</li><li>将新的值设为共享变量的值。</li></ol><p>CAS 算法通过原子性地比较和交换操作来实现多线程间对共享变量的安全访问。由于 CAS 仅在操作变量时才会加锁，相比传统的锁机制，它减少了锁的使用，减少了线程间的竞争和线程上下文切换的开销，提高了并发性能。</p><p>然而，CAS 算法也存在一些问题，例如ABA问题和自旋等待。为了解决这些问题，Java 提供了 Atomic 包中的原子类，如 AtomicBoolean、AtomicInteger 等，它们封装了 CAS 算法，提供了更方便和可靠的原子操作。</p><p>总而言之，CAS（Compare and Swap）算法是一种基于比较和交换的原子操作，用于解决多线程环境下的数据竞争问题，保证共享变量的原子性操作。</p><h3 id="8、CAS机制在ConcurrentHashMap有哪些具体体现？"><a href="#8、CAS机制在ConcurrentHashMap有哪些具体体现？" class="headerlink" title="8、CAS机制在ConcurrentHashMap有哪些具体体现？"></a>8、CAS机制在ConcurrentHashMap有哪些具体体现？</h3><ol><li>put 方法：当需要插入或更新节点时，ConcurrentHashMap 使用 CAS 操作来保证并发安全。CAS 的原理是比较当前节点的值和期望的值是否相等，如果相等，则更新节点的值；如果不相等，则说明有其他线程已经修改了节点的值，当前线程需要重新尝试。</li><li>remove 方法：在删除节点时，也使用了 CAS 操作。首先，通过 CAS 将节点的值设置为特定的标记，表示该节点被删除。之后，通过 CAS 将节点从链表或红黑树中移除。</li><li>replace 方法：用于替换指定键对应的节点值。ConcurrentHashMap 使用 CAS 操作来找到该节点并进行替换。</li></ol><p>需要注意的是，并发情况下，可能存在多个线程竞争同一个节点，CAS 机制只能保证一个线程成功执行操作，对于其他线程，需要重新尝试。这样可以避免加锁带来的竞争和开销，提高并发性能。</p><p>总结起来，CAS 机制在 ConcurrentHashMap 中用于保证并发更新操作的原子性和一致性，例如插入、删除和替换节点等。同时，它通过比较节点的值来检测并发冲突，并确保只有一个线程能够成功地修改节点的值。</p><h3 id="9、ConcurrentHashMap为什么在1-7使用分段锁，1-8使用CAS-synchronized？"><a href="#9、ConcurrentHashMap为什么在1-7使用分段锁，1-8使用CAS-synchronized？" class="headerlink" title="9、ConcurrentHashMap为什么在1.7使用分段锁，1.8使用CAS + synchronized？"></a>9、ConcurrentHashMap为什么在1.7使用分段锁，1.8使用CAS + synchronized？</h3><p>在 Java 1.7 中，ConcurrentHashMap 使用了分段锁（Segmented Locking）的机制来实现并发安全。这是因为在早期版本中，Java 的并发包没有提供像 CAS（Compare and Swap）这样的原子操作支持，所以使用了分段锁来保证并发操作的线程安全性。</p><p>分段锁的思想是将 ConcurrentHashMap 的整个数据结构分割成多个独立的段（Segment），每个段维护一个独立的哈希表，而不是对整个表加锁。这样，不同的线程可以同时访问不同的段，从而提高并发性能。</p><p>每个段都有自己的锁，读操作可以并发进行，只有写操作需要获取对应段的锁。这样，在多线程环境下，读操作和写操作可以并行执行，提高了并发性能。</p><p>然而，分段锁机制也存在一些问题。例如，每个段都需要维护自己的锁，会占用较多的内存空间。另外，在高并发的情况下，多个线程同时进行写操作可能会导致锁竞争，性能瓶颈。</p><p>在 Java 1.8 中，ConcurrentHashMap 进行了重大改进。引入了 CAS 和 synchronized 结合的方式来实现并发安全。CAS 提供了原子性的操作，而 synchronized 关键字能够保证代码块的互斥性。</p><p>Java 1.8 中的 ConcurrentHashMap 使用了数组+链表+红黑树的结构来组织数据，同时利用 CAS 操作确保对元素的插入、修改和删除是线程安全的。当并发冲突较少时，使用 CAS 进行原子操作；当发生较大的并发冲突时，使用 synchronized 关键字来进行互斥访问，将链表转换为红黑树，提高查询的效率。</p><p>这种改进带来了更好的并发性能和内存利用率。CAS 和 synchronized 结合的方式在大部分情况下能够提供更好的性能，适应了更广泛的并发场景。</p><p>综上所述，ConcurrentHashMap 在 Java 1.7 使用分段锁是因为早期的版本没有提供 CAS（Compare and Swap）等原子操作支持；而在 Java 1.8 中使用 CAS + synchronized 的方式则是为了提高并发性能和内存利用率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、了解哪些集合？&quot;&gt;&lt;a href=&quot;#1、了解哪些集合？&quot; class=&quot;headerlink&quot; title=&quot;1、了解哪些集合？&quot;&gt;&lt;/a&gt;1、了解哪些集合？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;List&lt;/strong&gt;（列表）：List是有序的集合，可以包含重复元素。常见的List实现类有&lt;strong&gt;ArrayList&lt;/strong&gt;（动态数组）、&lt;strong&gt;LinkedList&lt;/strong&gt;（链表）和&lt;strong&gt;Vector&lt;/strong&gt;（向量）等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set&lt;/strong&gt;（集合）：Set是不允许重复元素的集合，它没有顺序。常见的Set实现类有&lt;strong&gt;HashSet&lt;/strong&gt;、&lt;strong&gt;TreeSet&lt;/strong&gt;和&lt;strong&gt;LinkedHashSet&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt;（映射）：Map是一种键值对（Key-Value）的集合，每个键（Key）都是唯一的。常见的Map实现类有&lt;strong&gt;HashMap&lt;/strong&gt;、&lt;strong&gt;TreeMap&lt;/strong&gt;和&lt;strong&gt;LinkedHashMap&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;Queue（队列）：Queue是一种先进先出（FIFO）的集合，通常用于实现队列或任务调度等场景。常见的Queue实现类有&lt;strong&gt;LinkedList&lt;/strong&gt;、&lt;strong&gt;PriorityQueue&lt;/strong&gt;和&lt;strong&gt;ArrayDeque&lt;/strong&gt;等。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Java面经" scheme="http://quanluo.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="集合" scheme="http://quanluo.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>每日Java面经（Day2）</title>
    <link href="http://quanluo.github.io/2023/07/04/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day2%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/07/04/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day2%EF%BC%89/</id>
    <published>2023-07-04T06:53:59.000Z</published>
    <updated>2023-07-04T13:19:15.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Java-线程池几种实现方式"><a href="#1、Java-线程池几种实现方式" class="headerlink" title="1、Java 线程池几种实现方式"></a>1、Java 线程池几种实现方式</h3><h4 id="1-FixedThreadPool（固定大小线程池）："><a href="#1-FixedThreadPool（固定大小线程池）：" class="headerlink" title="1. FixedThreadPool（固定大小线程池）："></a>1. FixedThreadPool（固定大小线程池）：</h4><ul><li>使用固定数量的线程处理任务。</li><li>可以使用<code>Executors.newFixedThreadPool(int)</code>方法创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.execute(<span class="keyword">new</span> MyTask());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><h4 id="2-CachedThreadPool（缓存线程池）："><a href="#2-CachedThreadPool（缓存线程池）：" class="headerlink" title="2. CachedThreadPool（缓存线程池）："></a>2. <code>CachedThreadPool</code>（缓存线程池）：</h4><a id="more"></a><ul><li>根据需要动态创建线程。</li><li>可以使用<code>Executors.newCachedThreadPool()</code>方法创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">executor.execute(<span class="keyword">new</span> MyTask());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><h4 id="3-SingleThreadExecutor（单线程线程池）："><a href="#3-SingleThreadExecutor（单线程线程池）：" class="headerlink" title="3. SingleThreadExecutor（单线程线程池）："></a>3. <code>SingleThreadExecutor</code>（单线程线程池）：</h4><ul><li>只有一个工作线程，按顺序执行任务。</li><li>可以使用<code>Executors.newSingleThreadExecutor()</code>方法创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.execute(<span class="keyword">new</span> MyTask());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><h4 id="4-ScheduledThreadPool（定时任务线程池）："><a href="#4-ScheduledThreadPool（定时任务线程池）：" class="headerlink" title="4. ScheduledThreadPool（定时任务线程池）："></a>4. <code>ScheduledThreadPool</code>（定时任务线程池）：</h4><ul><li>定期执行或延迟执行任务。</li><li>可以使用<code>Executors.newScheduledThreadPool(int)</code>方法创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">executor.schedule(<span class="keyword">new</span> MyTask(), <span class="number">1</span>, TimeUnit.SECONDS);  <span class="comment">// 延迟1秒后执行</span></span><br><span class="line">executor.scheduleAtFixedRate(<span class="keyword">new</span> MyTask(), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">// 每2秒执行一次</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><h4 id="5-WorkStealingPool（工作窃取线程池）："><a href="#5-WorkStealingPool（工作窃取线程池）：" class="headerlink" title="5. WorkStealingPool（工作窃取线程池）："></a>5. <code>WorkStealingPool</code>（工作窃取线程池）：</h4><ul><li>基于任务分解的线程池算法，实现负载均衡。</li><li>可以使用<code>Executors.newWorkStealingPool(int)</code>方法创建（Java 8+）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newWorkStealingPool();</span><br><span class="line">executor.execute(<span class="keyword">new</span> MyTask());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure><p>上述代码示例中，<code>MyTask</code>代表要执行的任务，可以通过实现<code>Runnable</code>接口或<code>Callable</code>接口来定义具体的任务逻辑。调用<code>execute()</code>方法将任务提交给线程池执行，<code>shutdown()</code>方法用于关闭线程池。</p><h3 id="2、常见的线程池参数及其作用"><a href="#2、常见的线程池参数及其作用" class="headerlink" title="2、常见的线程池参数及其作用"></a>2、常见的线程池参数及其作用</h3><ol><li><code>corePoolSize</code>（核心线程数）：<ul><li>指定线程池中保留的核心线程数，即使处于空闲状态也不会被销毁。</li><li>控制着线程池的基本规模。</li></ul></li><li><code>maximumPoolSize</code>（最大线程数）：<ul><li>指定线程池中允许存在的最大线程数（包括核心线程和非核心线程）。</li><li>决定了线程池的最大容量。</li></ul></li><li><code>keepAliveTime</code>（线程空闲时间）：<ul><li>当线程池中的线程数量超过核心线程数时，多余的空闲线程在等待新任务到来时的存活时间。</li><li>超过该时间后，空闲线程将被销毁，直到线程池中的线程数量不超过核心线程数。</li></ul></li><li><code>unit</code>（时间单位）：<ul><li>用于指定<code>keepAliveTime</code>参数的时间单位，如<code>TimeUnit.SECONDS</code>表示秒。</li></ul></li><li><code>workQueue</code>（任务队列）：<ul><li>用于保存等待执行的任务的阻塞队列。</li><li>可以选择适合业务需求的不同类型的阻塞队列，如<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>等。</li></ul></li><li><code>threadFactory</code>（线程工厂）：<ul><li>用于创建线程的工厂对象，用于自定义线程的创建方式（如线程名、优先级等）。</li><li>可以使用<code>ThreadFactory</code>接口的默认实现类<code>DefaultThreadFactory</code>，也可以自定义实现。</li></ul></li><li><code>rejectedExecutionHandler</code>（任务拒绝处理器）：<ul><li>当线程池无法接受新任务时，用于处理被拒绝的任务。</li><li>可以选择不同的处理策略，如<code>ThreadPoolExecutor.AbortPolicy</code>（默认）表示抛出异常，<code>ThreadPoolExecutor.DiscardPolicy</code>表示默默丢弃等。</li></ul></li></ol><p>这些参数可以在创建线程池时传递给相关的构造函数或方法进行配置。根据具体的业务需求和性能要求，可以灵活地调整这些参数来优化线程池的行为和性能。</p><p>举例来说，对于一个固定大小的线程池，可以通过设置合适的核心线程数和最大线程数来平衡并发度和资源消耗；对于一个可缓存的线程池，可以调整线程空闲时间和任务队列的容量来控制线程的创建和销毁；对于一个定时任务线程池，可以设置合适的核心线程数和任务队列类型来满足定时任务的执行需求。</p><h3 id="3、为什么一般不推荐直接使用Executors，而是建议使用ThreadPoolExecutor来进行线程池的创建和配置"><a href="#3、为什么一般不推荐直接使用Executors，而是建议使用ThreadPoolExecutor来进行线程池的创建和配置" class="headerlink" title="3、为什么一般不推荐直接使用Executors，而是建议使用ThreadPoolExecutor来进行线程池的创建和配置"></a>3、为什么一般不推荐直接使用Executors，而是建议使用ThreadPoolExecutor来进行线程池的创建和配置</h3><p>一般不推荐直接使用<code>Executors</code>类提供的静态工厂方法来创建线程池，而是建议使用<code>ThreadPoolExecutor</code>类进行线程池的创建和配置。以下是一些主要原因：</p><ol><li><strong>控制线程池的行为</strong>：<code>Executors</code>提供的静态工厂方法返回的线程池实现具有固定的默认配置，无法进行细粒度的调整。而使用<code>ThreadPoolExecutor</code>可以通过构造函数或setter方法来指定各个参数，能够更灵活地控制线程池的行为和性能。</li><li><strong>避免资源耗尽</strong>：<code>Executors</code>提供的静态工厂方法的默认配置可能不适合所有场景，比如默认的无界队列可能导致内存溢出。而使用<code>ThreadPoolExecutor</code>可以根据具体需求选择适当的任务队列类型，防止由于任务积压导致的资源耗尽问题。</li><li><strong>自定义线程创建和销毁逻辑</strong>：<code>Executors</code>提供的静态工厂方法对于线程的创建和销毁逻辑较为简单，并不能满足所有需求。而使用<code>ThreadPoolExecutor</code>，可以自定义线程工厂对象来灵活控制线程的创建方式，并通过重写<code>beforeExecute()</code>和<code>afterExecute()</code>等钩子方法来扩展线程执行前后的处理逻辑。</li><li><strong>提供更多的拒绝策略选项</strong>：<code>Executors</code>提供的静态工厂方法对于任务拒绝处理器的选择比较有限，只提供了一些基本的拒绝策略。而使用<code>ThreadPoolExecutor</code>可以通过自定义实现<code>RejectedExecutionHandler</code>接口来灵活选择和实现任务拒绝处理的策略。</li></ol><p>总之，虽然<code>Executors</code>提供了一种简洁的方式来创建线程池，但是由于其默认配置的局限性以及对于个性化需求的不适应性，推荐使用<code>ThreadPoolExecutor</code>来手动创建和配置线程池，以获得更好的灵活性和可控性。</p><h3 id="4、说一下java中的各种锁，以及锁升级过程"><a href="#4、说一下java中的各种锁，以及锁升级过程" class="headerlink" title="4、说一下java中的各种锁，以及锁升级过程"></a>4、说一下java中的各种锁，以及锁升级过程</h3><h4 id="在Java中，有多种类型的锁可用于实现线程之间的同步和并发控制。以下是一些常见的锁及其特点："><a href="#在Java中，有多种类型的锁可用于实现线程之间的同步和并发控制。以下是一些常见的锁及其特点：" class="headerlink" title="在Java中，有多种类型的锁可用于实现线程之间的同步和并发控制。以下是一些常见的锁及其特点："></a>在Java中，有多种类型的锁可用于实现线程之间的同步和并发控制。以下是一些常见的锁及其特点：</h4><ol><li><strong>synchronized关键字</strong>：<ul><li>是Java内置的关键字，用于实现基本的互斥同步。</li><li>采用悲观锁机制，当某个线程获取到锁后，其他线程将被阻塞等待。</li><li>可以用于同步代码块或方法，也可以用于修饰静态方法或类。</li></ul></li><li><strong>ReentrantLock类</strong>：<ul><li>是Java.util.concurrent（JUC）包中提供的可重入锁实现。</li><li>提供了与<code>synchronized</code>相似的功能，但具有更高的灵活性和扩展性。</li><li>支持公平和非公平性，可以手动控制锁的获取和释放。</li></ul></li><li><strong>ReadWriteLock接口</strong>：<ul><li>是JUC包中提供的读写锁机制，用于优化读多写少的场景。</li><li>读锁（共享锁）允许多个线程同时读取共享资源。</li><li>写锁（排他锁）在写操作时独占资源，阻塞其他线程的读写操作。</li></ul></li><li><strong>StampedLock类</strong>：<ul><li>是JUC包中引入的乐观读锁机制，用于提供更高的并发性能。</li><li>乐观读锁不会阻塞写锁，但读取数据时需要进行额外的验证。</li><li>支持获取乐观读锁、写锁和悲观读锁（类似于读写锁）。</li></ul></li></ol><h4 id="锁升级是指从低级别的锁转换为高级别的锁机制。在Java中，存在以下几种常见的锁升级过程："><a href="#锁升级是指从低级别的锁转换为高级别的锁机制。在Java中，存在以下几种常见的锁升级过程：" class="headerlink" title="锁升级是指从低级别的锁转换为高级别的锁机制。在Java中，存在以下几种常见的锁升级过程："></a>锁升级是指从低级别的锁转换为高级别的锁机制。在Java中，存在以下几种常见的锁升级过程：</h4><ol><li><strong>偏向锁升级为轻量级锁</strong>：<ul><li>当只有一个线程访问同步代码块时，JVM会将对象的标记置为该线程的Thread ID，表示偏向锁状态。</li><li>如果其他线程尝试获取同步锁，偏向锁将升级为轻量级锁。</li></ul></li><li><strong>轻量级锁升级为重量级锁</strong>：<ul><li>轻量级锁是基于CAS（比较并交换）操作实现的，它允许多个线程同时获取锁。</li><li>当线程自旋获取锁的时间过长或自旋次数超过阈值时，轻量级锁将升级为重量级锁。</li></ul></li><li><strong>自旋锁优化</strong>：<ul><li>在某些场景下，JVM可能会将轻量级锁或重量级锁替换为自旋锁。</li><li>自旋锁允许线程在获取锁之前进行短时间的忙等待，减少线程切换开销。</li></ul></li></ol><p>需要注意的是，锁升级过程是由JVM自动进行的，开发人员无需手动干预。JVM会根据线程的竞争情况和锁的状态来选择合适的锁机制，以提供更好的性能和并发控制。</p><h3 id="5、Java中-i-如何保证线程安全"><a href="#5、Java中-i-如何保证线程安全" class="headerlink" title="5、Java中 i++ 如何保证线程安全"></a>5、Java中 i++ 如何保证线程安全</h3><p>在Java中，<code>i++</code>操作本身是非线程安全的，因为它涉及到读取、修改和写入一个共享的变量。如果多个线程同时执行<code>i++</code>操作，可能会导致竞态条件和不确定的结果。</p><p>为了保证对<code>i++</code>操作的线程安全，常见的做法是使用同步机制，如<code>synchronized</code>关键字或<code>ReentrantLock</code>。下面是两种常见的方式：</p><p>1.<strong>使用synchronized关键字</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 共享的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;  <span class="comment">// 线程安全的自增操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>使用ReentrantLock</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 共享的变量</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i++;  <span class="comment">// 线程安全的自增操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些同步机制能够确保在同一时刻只有一个线程能够执行<code>increment()</code>方法，从而避免了竞态条件。当一个线程获取到锁并执行自增操作时，其他线程将被阻塞，直到锁被释放。</p><p>需要注意的是，使用同步机制会带来一定的性能开销，因为线程会竞争锁并进行上下文切换。在某些情况下，可以考虑使用原子类（如<code>AtomicInteger</code>）来实现线程安全的自增操作，它们利用了底层硬件指令提供的原子性保证，避免了显式的锁机制。</p><p><strong>补充：原子类（如<code>AtomicInteger</code>）：</strong></p><p>当需要实现线程安全的自增操作时，可以考虑使用原子类，例如<code>AtomicInteger</code>。原子类是Java提供的一组线程安全的操作类，使用了底层的CAS（比较并交换）操作，能够保证某个操作的原子性，避免了显式的锁机制。</p><p>对于自增操作，<code>AtomicInteger</code>类提供了<code>incrementAndGet()</code>方法，它会以原子方式将当前值加1，并返回新的值。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  <span class="comment">// 初始值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();  <span class="comment">// 原子自增操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>AtomicInteger</code>的实例 <code>count</code> 被用作计数器。通过调用 <code>incrementAndGet()</code> 方法，可以实现线程安全的自增操作，而无需额外的同步机制。</p><p><code>AtomicInteger</code> 的 <code>incrementAndGet()</code> 操作是原子的，因此多个线程可以同时调用该方法而不会导致竞态条件。它利用了底层的硬件指令提供的原子性保证，确保自增操作的完整性。</p><p>需要注意的是，<code>AtomicInteger</code> 只能保证单个操作的原子性，如果需要进行多个操作的复合操作，仍然需要考虑使用同步机制，如<code>synchronized</code>或<code>ReentrantLock</code>。</p><p>总之，通过使用<code>AtomicInteger</code> 类来实现线程安全的自增操作，可以简化代码，减少同步控制的开销，并且保证数据的一致性。</p><h3 id="6、简单说一下HashMap和ConcurrentHashMap"><a href="#6、简单说一下HashMap和ConcurrentHashMap" class="headerlink" title="6、简单说一下HashMap和ConcurrentHashMap"></a>6、简单说一下HashMap和ConcurrentHashMap</h3><p><code>HashMap</code>和<code>ConcurrentHashMap</code>都是Java中常用的Map实现，用于存储键值对数据。它们具有相似的功能，但在并发环境下存在一些重要的区别。</p><p><strong>HashMap</strong>:</p><ul><li><code>HashMap</code>是非线程安全的，适用于单线程环境或者多线程环境下不存在并发写操作的情况。</li><li>HashMap的实现是基于哈希表（Hash Table）的，通过将键映射到存储桶（bucket）上来实现快速存取。</li><li>在HashMap中，可以使用<code>put(key, value)</code>方法添加键值对，使用<code>get(key)</code>方法获取特定键的值。</li><li>由于HashMap是非线程安全的，如果多个线程同时对HashMap进行写操作，可能会导致数据不一致和死循环等问题。</li></ul><p><strong>ConcurrentHashMap</strong>:</p><ul><li><code>ConcurrentHashMap</code>是线程安全的HashMap实现，适用于高度并发的环境。</li><li>ConcurrentHashMap的实现也基于哈希表，但与HashMap不同的是，ConcurrentHashMap在桶级别上使用了锁机制来实现并发访问控制。</li><li>ConcurrentHashMap提供了诸如<code>put(key, value)</code>、<code>get(key)</code>等线程安全的方法，可以在多线程环境下安全地进行读写操作。</li><li>除了并发安全性外，ConcurrentHashMap还提供了更好的性能和可伸缩性，适用于高并发读写的场景。</li><li>注意，虽然ConcurrentHashMap在写操作上是线程安全的，但仍然会有一定的开销，因此在读多写少的情况下，可能会有更适合的替代方案。</li></ul><p>总结：</p><ul><li>如果在单线程环境或者不存在并发写操作的场景中，可以使用HashMap。</li><li>如果在高并发环境下，需要安全地进行读写操作，可以选择ConcurrentHashMap来保证线程安全性和性能。</li><li>需要注意的是，在使用ConcurrentHashMap时，仍然需要注意避免可能出现的竞态条件和需要原子性操作的场景，例如针对同一个键的复合操作。</li></ul><h3 id="7、-Autowired和-Resource区别"><a href="#7、-Autowired和-Resource区别" class="headerlink" title="7、@Autowired和@Resource区别"></a>7、@Autowired和@Resource区别</h3><p><code>@Autowired</code>和<code>@Resource</code>是Java中常用的依赖注入（Dependency Injection）注解，用于实现对象之间的自动装配。它们有一些区别和使用场景上的差异。</p><p><strong>@Autowired</strong>:</p><ul><li><code>@Autowired</code>是Spring框架提供的注解，用于进行自动装配。</li><li>在使用<code>@Autowired</code>时，Spring会自动在容器中查找匹配类型的Bean，并将其注入到标记了<code>@Autowired</code>注解的字段、构造方法或者setter方法中。</li><li><code>@Autowired</code>默认通过类型（Type）进行自动装配，如果存在多个匹配的Bean时，可以结合<code>@Qualifier</code>注解指定具体要注入的Bean。</li><li><code>@Autowired</code>是按照类型进行自动装配的，不支持按照名称进行装配。</li></ul><p><strong>@Resource</strong>:</p><ul><li><code>@Resource</code>是Java EE标准的注解，也可以在Spring框架中使用，用于进行自动装配。</li><li><code>@Resource</code>可以根据字段名、字段类型以及通过名称（Name）指定要注入的Bean。</li><li><code>@Resource</code>的name属性可以指定具体要注入的Bean的名称，如果没有指定，则默认按照字段名或者类型进行查找匹配的Bean。</li><li><code>@Resource</code>支持按照名称进行装配，如果找不到与名称匹配的Bean，则会抛出异常。</li></ul><p>总结：</p><ul><li><code>@Autowired</code>是Spring框架提供的注解，使用更为广泛。</li><li><code>@Resource</code>是Java EE标准的注解，可以在Spring中使用，更加灵活。</li><li><code>@Autowired</code>按照类型进行自动装配，支持结合<code>@Qualifier</code>指定具体要注入的Bean。</li><li><code>@Resource</code>支持按照名称进行自动装配，也可以通过字段名、字段类型和名称指定要注入的Bean。</li><li>如果只考虑Spring框架，一般推荐使用<code>@Autowired</code>，如果需要兼容Java EE平台，可以考虑使用<code>@Resource</code>。</li></ul><h3 id="8、简单说一下Redis为什么这么快"><a href="#8、简单说一下Redis为什么这么快" class="headerlink" title="8、简单说一下Redis为什么这么快"></a>8、简单说一下Redis为什么这么快</h3><p>Redis之所以被认为是一个快速的数据存储系统，主要有以下几个原因：</p><p><strong>1. 内存存储：</strong> Redis主要将数据存储在内存中，而不是磁盘上。相对于磁盘访问，内存访问速度更快，因此Redis能够实现低延迟的读写操作。</p><p><strong>2. 单线程模型：</strong> Redis采用单线程模型来处理所有的客户端请求。这样可以避免多线程的锁开销和线程上下文切换的开销，并减少了并发竞争带来的性能损失。此外，Redis通过使用非阻塞I/O和事件驱动模型，在单线程下也能够处理高并发的请求。</p><p><strong>3. 高效的数据结构：</strong> Redis提供了多种高效的数据结构，如字符串、哈希表、列表、集合和有序集合等。这些数据结构在内部都经过优化，可以实现快速的插入、读取和删除操作。</p><p><strong>4. 持久化机制：</strong> Redis支持将数据持久化到磁盘中，以便于在重启后恢复数据。Redis提供了两种持久化方式：快照（snapshotting，Redis DataBase，<strong>RDB</strong>）和日志（append-only file，<strong>AOF</strong>）。快照会将整个数据集保存到磁盘中，而AOF则记录了对数据集的修改操作，通过重放这些操作来恢复数据。</p><p><strong>5. 网络优化：</strong> Redis使用高性能的网络库，通过减少网络开销和优化传输协议来提高网络传输效率。此外，Redis支持连接池和管道（pipeline）等技术，可以进一步提升网络通信的效率。</p><p><strong>6. 高级功能支持：</strong> Redis还支持一些高级功能，如发布/订阅、事务和Lua脚本。这些功能在一定程度上提升了Redis的灵活性和可扩展性。</p><p>需要注意的是，尽管Redis非常快速，但它也具有一些局限性。由于数据存储在内存中，所以受到内存容量的限制；并且在持久化过程中可能出现数据丢失的情况。因此，在设计应用程序时需要根据实际需求进行权衡和选择。</p><h3 id="9、说一下Redis的两种持久化机制：RDB和AOF"><a href="#9、说一下Redis的两种持久化机制：RDB和AOF" class="headerlink" title="9、说一下Redis的两种持久化机制：RDB和AOF"></a>9、说一下Redis的两种持久化机制：RDB和AOF</h3><p>Redis支持两种不同的持久化机制：RDB（快照）和AOF（追加文件）。</p><p><strong>RDB（Redis DataBase）持久化：</strong> RDB持久化是将Redis在某个时间点的数据集快照写入磁盘。它会周期性地将内存中的数据集以二进制的形式保存到磁盘文件中。RDB持久化是一种紧凑且高效的持久化方式，适用于备份、灾难恢复以及通过恢复保存的数据集来重新启动Redis。但是，由于数据集需要完全写入磁盘，因此在发生故障时可能会出现数据丢失。默认情况下，Redis每15分钟如果有至少1个键发生变化，就会执行一次自动保存。</p><p><strong>AOF（Append Only File）持久化：</strong> AOF持久化是通过以追加的方式记录每个写操作命令来保证数据的持久化。这样可以确保每个写操作都被记录下来，并最终重放到Redis中，从而恢复原始数据。AOF文件是一个文本文件，它包含了Redis服务器执行的所有写操作命令。相比RDB持久化，AOF持久化提供了更好的数据安全性，但相应地也会增加磁盘空间的占用和对磁盘的写入频率。Redis提供了不同的AOF策略，如always、everysec和no，以允许根据需求进行配置。</p><p>在实际应用中，可以根据具体需求选择适合的持久化方式。如果对数据安全性要求较高，并且可以接受一定的性能损失和磁盘空间占用，推荐使用AOF持久化。如果对性能要求较高，并且可以容忍一定程度的数据丢失，那么可以选择RDB持久化。在某些情况下，也可以同时开启RDB和AOF持久化，以提供更好的数据保护和恢复能力。</p><p>需要注意的是，持久化机制只是Redis的一部分功能，它并不影响Redis的高性能特点。无论选择哪种持久化方式，Redis都仍然是一个快速的键值存储数据库。</p><h3 id="10、说一下常见的索引类型以及优化"><a href="#10、说一下常见的索引类型以及优化" class="headerlink" title="10、说一下常见的索引类型以及优化"></a>10、说一下常见的索引类型以及优化</h3><p>在数据库中，索引是一种数据结构，用于提高数据库查询的效率。常见的索引类型包括以下几种：</p><ol><li><strong>B树索引（B-Tree Index）：</strong> B树索引是最常见和广泛使用的索引类型。它适用于范围查询和精确匹配，并且支持快速插入和删除操作。B树索引将数据按照键值有序地组织在树状结构中，并提供了快速的搜索和遍历功能。</li><li><strong>B+树（B+Tree）</strong>：B+树是在B树基础上演化而来的一种树状数据结构。与B树不同，B+树的所有关键字都被存储在叶子节点上，而非内部节点。叶子节点通过指针连接形成一个有序链表，这样可以更高效地支持范围查询和排序操作。B+树常用于磁盘或其他需要大规模数据存储的场景，如数据库系统的索引结构。</li><li><strong>哈希索引（Hash Index）：</strong> 哈希索引基于哈希函数将键值映射为索引位置，适用于等值查询。它具有快速的查找速度，但不支持范围查询和排序操作。由于哈希冲突的存在，哈希索引可能需要解决冲突问题。</li><li><strong>全文索引（Full-Text Index）：</strong> 全文索引用于对文本内容进行关键字搜索。它可以解析文本并创建反向索引，以便快速搜索包含指定关键字的文档。全文索引适用于文本搜索引擎和内容管理系统等应用。</li></ol><p>优化数据库索引是提高数据库性能的重要手段。以下是一些常见的索引优化技巧：</p><ol><li><strong>选择合适的索引字段：</strong> 对于经常用于查询的字段，应该考虑创建索引以提高查询性能。可以根据查询的频率、过滤条件和排序要求来选择合适的索引字段。</li><li><strong>避免过多的索引：</strong> 虽然索引可以加速查询，但过多的索引会增加数据插入和更新的成本，并占用更多的存储空间。因此，需要权衡索引数量和查询性能之间的关系，避免创建不必要的索引。</li><li><strong>定期维护和优化索引：</strong> 索引需要进行定期的维护和优化操作，以确保其在查询过程中的高效性。可以使用数据库提供的工具或命令来重新生成或重建索引，以消除索引碎片和提高性能。</li><li><strong>联合索引的使用：</strong> 对于经常同时查询多个字段的情况，可以考虑创建联合索引。联合索引可以提高联合条件查询的性能，减少查询的扫描范围。</li><li><strong>注意索引的选择性：</strong> 索引的选择性表示索引列中具有唯一值的比例。选择性越高，查询性能越好。因此，在选择索引字段时，应考虑选择具有较高选择性的字段。</li><li><strong>定期监控和调整索引：</strong> 随着数据库使用情况的变化，索引的性能可能会发生变化。因此，需要定期监控查询的执行计划和性能，并根据实际情况进行适时的索引调整和重建。</li></ol><p>综上所述，索引优化是提高数据库查询性能的重要策略。通过选择合适的索引类型、设计良好的索引策略以及定期维护和优化索引，可以有效地提高数据库的查询效率。</p><h3 id="11、MySQL的默认索引结构是B-树还是B树"><a href="#11、MySQL的默认索引结构是B-树还是B树" class="headerlink" title="11、MySQL的默认索引结构是B+树还是B树"></a>11、MySQL的默认索引结构是B+树还是B树</h3><p>MySQL的默认索引结构是B+树。从MySQL 8.0版本开始，InnoDB存储引擎作为MySQL的默认引擎，它使用B+树作为索引结构。</p><p>B+树在数据库系统中被广泛应用，因为它对范围查询和排序操作有很好的支持，并且能够处理大规模数据。同时，B+树也适合于磁盘存储，因为它提供了良好的顺序访问性能。</p><p>B+树的特点是非叶子节点存储键值和子节点的指针，而叶子节点存储键值和对应数据的指针，并通过指针连接形成有序链表。这使得B+树在范围查询、排序以及插入删除操作上表现出色。</p><p>需要注意的是，虽然MySQL的默认索引结构是B+树，但MySQL也支持其他类型的索引，如哈希索引、全文索引等。这些不同类型的索引可以根据具体需求进行选择。</p><h3 id="12、说说常用的设计模式"><a href="#12、说说常用的设计模式" class="headerlink" title="12、说说常用的设计模式"></a>12、说说常用的设计模式</h3><p>设计模式是一种在软件设计中常用的解决问题的方法论，它提供了经过验证和复用的解决方案。以下是一些常用的设计模式：</p><ol><li><strong>单例模式（Singleton Pattern）：</strong> 单例模式用于确保一个类只有一个实例，并提供全局访问点。这在需要控制资源共享或限制对象创建数量的情况下非常有用。</li><li><strong>工厂模式（Factory Pattern）：</strong> 工厂模式通过使用一个共同的接口来创建对象，隐藏具体实现细节。它可以根据不同的条件创建不同的对象，使客户端代码与具体对象的创建解耦。</li><li><strong>观察者模式（Observer Pattern）：</strong> 观察者模式定义了一种一对多的依赖关系，当一个对象状态发生变化时，它的所有依赖对象都会收到通知并自动更新。这在实现发布-订阅模式和事件驱动系统时特别有用。</li><li><strong>装饰器模式（Decorator Pattern）：</strong> 装饰器模式允许在不改变原有对象结构的情况下，通过将对象包装在一个装饰器类中来动态地添加新的功能。这种模式可以灵活地扩展对象的功能。</li><li><strong>策略模式（Strategy Pattern）：</strong> 策略模式定义了一系列可互换的算法，并将每个算法封装在单独的类中，使它们可以相互替换。这样可以使算法的变化独立于使用算法的客户端。</li><li><strong>适配器模式（Adapter Pattern）：</strong> 适配器模式用于将一个类的接口转换成客户端所期望的另一个接口。它允许不兼容的类能够合作，提高代码的复用性。</li><li><strong>模板方法模式（Template Method Pattern）：</strong> 模板方法模式定义了一个算法的骨架，将一些步骤的实现延迟到子类中。这样可以在不改变算法结构的情况下，通过子类来改变特定步骤的实现。</li><li><strong>建造者模式（Builder Pattern）：</strong> 建造者模式用于创建复杂对象，通过将对象的构造过程分离出来，使得可以使用相同的构造过程来构建不同的表示。</li></ol><p>以上只是一些常见的设计模式，实际上还有很多其他的设计模式，每种模式都有其适用的场景和优缺点。选择合适的设计模式可以提高代码的可维护性、扩展性和重用性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Java-线程池几种实现方式&quot;&gt;&lt;a href=&quot;#1、Java-线程池几种实现方式&quot; class=&quot;headerlink&quot; title=&quot;1、Java 线程池几种实现方式&quot;&gt;&lt;/a&gt;1、Java 线程池几种实现方式&lt;/h3&gt;&lt;h4 id=&quot;1-FixedThreadPool（固定大小线程池）：&quot;&gt;&lt;a href=&quot;#1-FixedThreadPool（固定大小线程池）：&quot; class=&quot;headerlink&quot; title=&quot;1. FixedThreadPool（固定大小线程池）：&quot;&gt;&lt;/a&gt;1. FixedThreadPool（固定大小线程池）：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用固定数量的线程处理任务。&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;Executors.newFixedThreadPool(int)&lt;/code&gt;方法创建。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executor = Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executor.execute(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyTask());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executor.shutdown();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-CachedThreadPool（缓存线程池）：&quot;&gt;&lt;a href=&quot;#2-CachedThreadPool（缓存线程池）：&quot; class=&quot;headerlink&quot; title=&quot;2. CachedThreadPool（缓存线程池）：&quot;&gt;&lt;/a&gt;2. &lt;code&gt;CachedThreadPool&lt;/code&gt;（缓存线程池）：&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Java面经" scheme="http://quanluo.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日Java面经（Day1）</title>
    <link href="http://quanluo.github.io/2023/07/03/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day1%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/07/03/%E6%AF%8F%E6%97%A5Java%E9%9D%A2%E7%BB%8F%EF%BC%88Day1%EF%BC%89/</id>
    <published>2023-07-03T09:21:06.000Z</published>
    <updated>2023-07-03T13:07:06.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、HttpServletRequest-如何重复读body？"><a href="#1、HttpServletRequest-如何重复读body？" class="headerlink" title="1、HttpServletRequest 如何重复读body？"></a>1、HttpServletRequest 如何重复读body？</h3><p>在标准的<code>HttpServletRequest</code>中，只能通过一次读取<code>request.getInputStream()</code>或<code>request.getReader()</code>来获取请求体的内容。一旦读取完成，就无法再次重复读取。这是因为请求体是一个流式数据，只能读取一次。</p><p>但是，如果您想在需要时多次访问请求体的内容，您可以考虑将请求体内容保存到一个临时变量或者使用缓冲区来存储它。下面是一个示例代码，展示了如何将请求体内容保存为字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取请求体内容并保存</span></span><br><span class="line">StringBuilder requestBody = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">BufferedReader reader = request.getReader();</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    requestBody.append(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要的地方使用请求体内容</span></span><br><span class="line">String requestBodyString = requestBody.toString();</span><br><span class="line"><span class="comment">// 使用 requestBodyString 进行后续操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要再次访问请求体内容时，可以使用 requestBodyString 变量</span></span><br></pre></td></tr></table></figure><p>请注意，将请求体保存为字符串或其他形式的变量可能会导致内存占用增加。因此，如果请求体非常大或者频繁访问请求体内容会对性能产生不利影响，您可能需要重新评估您的需求并考虑其他解决方案。</p><a id="more"></a><h3 id="2、说一下你对-JMM-的理解"><a href="#2、说一下你对-JMM-的理解" class="headerlink" title="2、说一下你对 JMM 的理解"></a>2、说一下你对 JMM 的理解</h3><p>JMM（Java内存模型）是Java程序中用来定义多线程并发访问共享内存的规范。它确保了不同线程之间对共享变量的读写操作具有可见性、有序性和原子性。</p><ol><li>可见性：JMM保证一个线程对共享变量的修改对其他线程是可见的。当一个线程修改了共享变量的值，JMM会将这个修改刷新到主内存中，并让其他线程可以看到最新的值。</li><li>有序性：JMM通过禁止特定类型的指令重排序，保证了程序执行的顺序一致性。即使在编译器或处理器的优化过程中，指令也不能被乱序执行，从而确保了多线程环境下的正确性。</li><li>原子性：JMM保证基本数据类型（如int、long等）的读写操作是原子的。即一个线程对该变量的操作要么完全执行，要么完全不执行，不存在中间状态。</li></ol><p>JMM通过使用”happens-before”（先行发生）关系来建立多线程之间操作的顺序关系。如果某个操作A happens-before 某个操作B，那么线程执行操作A之前的所有操作都会在执行操作B时完成。</p><ol><li>happens-before关系：JMM中的happens-before关系是一种顺序保证，它规定了在多线程环境下，指令的执行顺序。如果一个操作happens-before另一个操作，那么前一个操作的结果对于后一个操作是可见的。happens-before关系可以由各种操作和同步机制（如volatile、锁、线程的启动和终止等）建立。</li></ol><p>作为开发者需要了解JMM的概念和规则，以确保正确地处理多线程并发访问共享数据的问题。这包括使用volatile关键字、synchronized关键字、Locks（锁）、Atomic类（原子类）等来实现线程间的协调与同步，以避免出现竞态条件、死锁等并发问题。同时，合理使用JMM提供的内存屏障指令（如volatile的写-读内存屏障）可以进一步优化并发性能。</p><h3 id="3、synchronized-如何实现可重入锁"><a href="#3、synchronized-如何实现可重入锁" class="headerlink" title="3、synchronized 如何实现可重入锁"></a>3、synchronized 如何实现可重入锁</h3><p>synchronized关键字在Java中实现了可重入锁（也称为递归锁）。可重入锁允许线程多次获得同一个锁而不会导致死锁。</p><p>当一个线程进入一个synchronized方法或代码块时，它会尝试获得该方法或代码块的锁。如果锁没有被其他线程持有，那么该线程将获得锁并继续执行。此时，JVM会记下锁的持有线程和持有计数器。</p><p>如果同一个线程再次进入同一个synchronized方法或代码块，它会检查当前线程是否已经持有该锁。如果是，则允许线程继续执行，同时增加持有计数器（+1）。这个过程可以一直嵌套下去。</p><p>当线程退出synchronized方法或代码块时，它会将持有计数器减1（-1）。只有当持有计数器减为0时，其他线程才有机会获得这个锁。</p><p>这种设计实现了可重入锁的原理。通过持有计数器，线程可以多次获得同一个锁，而不会出现死锁的情况。同时，每个线程都需要在释放锁之前将持有计数器减1，确保锁的正常释放。</p><p>需要注意的是，可重入锁是基于线程的，而不是基于方法或代码块的。也就是说，线程可以多次进入同一个synchronized方法或代码块，但不同的线程之间仍然需要竞争锁的获取。此外，可重入锁的机制只适用于同一个锁对象，不同的锁对象之间无法实现可重入性。</p><p>以下是一个使用synchronized实现可重入锁的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        synchronizedMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"外层同步代码块"</span>);</span><br><span class="line">            synchronizedMethod2(); <span class="comment">// 调用内层同步方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"内层同步代码块"</span>);</span><br><span class="line">            <span class="comment">// 执行其他操作...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在上面的示例中，我们定义了一个静态对象lock作为互斥锁。synchronizedMethod方法是外层同步方法，它使用synchronized(lock)来获取锁。在synchronizedMethod方法中，我们调用了syncronizedMethod2方法作为内层同步方法。</span></span><br><span class="line"><span class="comment">当一个线程执行synchronizedMethod方法时，它会首先获得lock对象的锁并进入外层同步代码块。然后，它调用了syncronizedMethod2方法作为内层同步方法。由于是同一个锁对象，线程可以再次成功获取该锁，并进入内层同步代码块执行。</span></span><br><span class="line"><span class="comment">该代码示例展示了可重入锁的特性。无论是外层同步代码块还是内层同步代码块，线程都可以多次进入，并且退出时会按照持有计数器逐级减少。这种机制确保了可重入锁的功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4、请详细讲一下ReentrantLock实现原理"><a href="#4、请详细讲一下ReentrantLock实现原理" class="headerlink" title="4、请详细讲一下ReentrantLock实现原理"></a>4、请详细讲一下ReentrantLock实现原理</h3><p>ReentrantLock是Java中的一个可重入锁实现，它提供了与synchronized相似的功能，但具有更高的灵活性和可扩展性。下面是ReentrantLock实现原理的详细解释：</p><ol><li>内部锁机制： ReentrantLock内部使用一个同步器（Sync）来提供锁的功能。在Java 5之前，ReentrantLock使用的是自定义的同步器AbstractQueuedSynchronizer（AQS）。而在Java 5及之后的版本中，ReentrantLock改为使用更高效的Sync实现，即非公平锁NonfairSync或公平锁FairSync。</li><li>非公平锁与公平锁：<ul><li>非公平锁：指线程获取锁时不考虑其他等待线程的情况，直接尝试获取锁。这种方式可能导致后续等待时间较长的线程一直无法获得锁，从而产生饥饿现象，但是在大多数情况下能够获得更高的吞吐量。</li><li>公平锁：指线程获取锁时会考虑其他等待线程的情况，遵循先来先服务的原则。这种方式可以防止某些线程一直等待锁而无法获取，但是由于需要更多的线程切换和调度开销，吞吐量通常较低。</li></ul></li><li>实现原理： ReentrantLock的Sync同步器内部使用了一个state变量来表示锁状态，当state为0时表示未被锁定，大于0时表示已被某个线程获取并且持有锁。另外，每个线程都有一个记录当前持有锁次数的计数器。<ul><li>获取锁（lock）：当一个线程调用lock()方法时，它会尝试对state进行CAS（比较交换）操作从而将其置为1。如果CAS成功，表示该线程成功获得了锁，并将持有计数器加1。如果CAS失败，则可能存在其他线程持有锁，这时当前线程会进入等待队列中。</li><li>释放锁（unlock）：当一个线程调用unlock()方法时，它会将持有计数器减1。如果计数器变为0，说明当前线程已经完全释放了锁，并将state重置为0，表示锁已释放。此时，等待队列中的其他线程有机会竞争锁。</li></ul></li><li>可重入性： ReentrantLock实现了可重入锁的特性，允许同一个线程多次获得同一个锁而不会导致死锁。这是通过持有计数器和线程标识符来实现的。当一个线程再次获取锁时，会检查当前的锁持有者是否为自己，如果是，则计数器加1，否则需要竞争锁。</li></ol><p>ReentrantLock提供了更多的功能和灵活性，例如可定时的、可中断的锁获取、公平锁与非公平锁的选择等。但相对于synchronized，使用ReentrantLock需要显式地手动获取和释放锁，并且需要在finally块中释放锁，以确保在任何情况下都能正确释放锁资源，防止死锁的发生。</p><p>下面是一个使用ReentrantLock实现可重入锁的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">我们使用ReentrantLock实现了可重入锁。通过lock()方法获取锁，并在finally块中使用unlock()方法释放锁，以确保在任何情况下都能正确释放锁资源，防止死锁的发生。</span></span><br><span class="line"><span class="comment">在main方法中，我们首先获取锁，执行外部代码块，然后调用outerMethod方法，在outerMethod方法中再次获取锁，执行中间代码块，最后调用innerMethod方法，在innerMethod方法中第三次获取锁，执行内部代码块。</span></span><br><span class="line"><span class="comment">由于ReentrantLock是可重入锁，所以在这个示例中，我们同一个线程多次获取了同一个锁，但没有出现死锁的情况。这是因为ReentrantLock内部通过持有计数器和线程标识符来实现可重入性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 第一次获取锁</span></span><br><span class="line">            System.out.println(<span class="string">"执行外部代码块"</span>);</span><br><span class="line">            outerMethod();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 第二次获取锁</span></span><br><span class="line">            System.out.println(<span class="string">"执行中间代码块"</span>);</span><br><span class="line">            innerMethod();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 第三次获取锁</span></span><br><span class="line">            System.out.println(<span class="string">"执行内部代码块"</span>);</span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、AQS-阻塞队列有长度限制吗？"><a href="#5、AQS-阻塞队列有长度限制吗？" class="headerlink" title="5、AQS 阻塞队列有长度限制吗？"></a>5、AQS 阻塞队列有长度限制吗？</h3><p>在AQS（AbstractQueuedSynchronizer 抽象排队同步器）的阻塞队列中，是没有固定长度限制的。AQS本身并不提供阻塞队列的实现，但它是许多并发类的基础，如ReentrantLock、Semaphore、CountDownLatch等。</p><p>对于具体的阻塞队列实现类（如ArrayBlockingQueue、LinkedBlockingQueue等），它们可能会限制队列的容量或长度，但这与AQS本身无关。这些实现类一般会提供一个构造方法来指定队列的容量限制。</p><p>例如，ArrayBlockingQueue是一个基于数组的有界阻塞队列，其容量由构造方法中的参数指定。只能存储固定数量的元素，一旦队列满了，后续的插入操作将会被阻塞。而LinkedBlockingQueue则是一个基于链表的可选有界或无界阻塞队列，如果创建时没有指定容量，则默认为无界队列。</p><p>在使用阻塞队列时，我们可以根据具体的需求选择适合的阻塞队列实现，有界队列可以帮助我们控制队列的长度，而无界队列则可以灵活地处理不确定数量的任务。不同的实现类会有不同的特点和适用场景，我们可以根据具体情况进行选择和使用。</p><h3 id="6、ReentrantLock-支持公平锁吗，怎么实现的？"><a href="#6、ReentrantLock-支持公平锁吗，怎么实现的？" class="headerlink" title="6、ReentrantLock 支持公平锁吗，怎么实现的？"></a>6、ReentrantLock 支持公平锁吗，怎么实现的？</h3><p>是的，ReentrantLock支持公平锁。公平锁是指多个线程按照申请锁的顺序来获取锁的机制，即先到先得。</p><p>在ReentrantLock中，可以通过构造方法来创建公平锁或非公平锁，默认情况下是非公平锁。要创建公平锁，可以将fair参数设置为true。</p><p>示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">// 创建公平锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Worker "</span> + id + <span class="string">" is trying to acquire the lock."</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Worker "</span> + id + <span class="string">" has acquired the lock."</span>);</span><br><span class="line">                <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Worker "</span> + id + <span class="string">" is releasing the lock."</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用ReentrantLock创建了一个公平锁，通过设置构造方法中的fair参数为true。然后创建了5个Worker线程，每个线程都会尝试获取锁并输出相应的信息。</p><p>如果是公平锁，则Worker线程会按照先到先得的顺序依次获取到锁，输出的结果可能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Worker <span class="number">1</span> is trying to acquire the lock.</span><br><span class="line">Worker <span class="number">1</span> has acquired the lock.</span><br><span class="line">Worker <span class="number">1</span> is releasing the lock.</span><br><span class="line">Worker <span class="number">2</span> is trying to acquire the lock.</span><br><span class="line">Worker <span class="number">2</span> has acquired the lock.</span><br><span class="line">Worker <span class="number">2</span> is releasing the lock.</span><br><span class="line">Worker <span class="number">3</span> is trying to acquire the lock.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果是非公平锁，则线程获取锁的顺序是不确定的。</p><p>需要注意的是，实际运行中，公平锁可能会导致性能下降，因为需要维护一个有序队列来记录线程的申请顺序。因此，在选择公平锁还是非公平锁时，需要根据具体场景和需求进行权衡和选择。</p><h3 id="7、请说一下公平锁和非公平锁的适用场景有哪些？"><a href="#7、请说一下公平锁和非公平锁的适用场景有哪些？" class="headerlink" title="7、请说一下公平锁和非公平锁的适用场景有哪些？"></a>7、请说一下公平锁和非公平锁的适用场景有哪些？</h3><p>公平锁和非公平锁都有各自适用的场景，如：</p><ol><li>公平锁适用场景：<ul><li>当系统对线程的执行顺序有严格要求时，即按照线程申请锁的先后顺序进行处理。</li><li>在高并发环境下，避免某些线程长时间被饿死（始终得不到锁），确保每个线程公平地获取资源。</li><li>对于一些对锁竞争不是特别激烈的情况，可以使用公平锁提高代码的可读性和可维护性。</li></ul></li><li>非公平锁适用场景：<ul><li>当对性能要求较高且对线程的执行顺序没有强制要求时，可以使用非公平锁。</li><li>在某些场景下，当一个线程频繁地申请锁并且持有锁的时间较长时，非公平锁可能会提供更好的吞吐量。</li><li>当已经知道在特定场景下非公平锁可以提供更好的性能，并且确认由于应用特性或负载模式造成的可能优势时，可以选择非公平锁。</li></ul></li></ol><p>需要注意的是，非公平锁并不是不考虑线程的执行顺序，而是在锁可用时，会尝试直接获取锁，只有在锁不可用时才进入等待队列。而公平锁则会先检查是否有前面排队的线程，如果有则进入等待队列，保证了线程按照申请的先后顺序获得锁。</p><p>在实际应用中，我们需要根据具体的业务场景和性能需求来选择合适的锁类型。如果对执行顺序有严格要求或者考虑公平性的问题，可以选择公平锁；如果追求更高的吞吐量或者确定非公平锁在特定场景下可以带来优势，可以选择非公平锁。</p><h3 id="8、说一下你对方法区的理解"><a href="#8、说一下你对方法区的理解" class="headerlink" title="8、说一下你对方法区的理解"></a>8、说一下你对方法区的理解</h3><p>方法区（Method Area）是Java虚拟机（JVM）的一个重要组成部分，它是线程共享的内存区域之一。在Java 8及之前的版本中，方法区是虚拟机规范的一部分。从Java 8开始，方法区被移除，并由元空间（Metaspace）取代。</p><p>方法区主要用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它的生命周期与虚拟机的生命周期保持一致，即虚拟机启动时被创建，虚拟机关闭时被销毁。</p><p>在方法区中，主要包含以下内容：</p><ol><li><strong>类信息</strong>：方法区保存了每个类的完整结构信息，包括类的字段、方法、父类、接口以及常量池等。</li><li><strong>运行时常量池</strong>：方法区中的运行时常量池是每个类的常量池的运行时表示形式，包含了编译期生成的各种字面量和符号引用。</li><li><strong>静态变量</strong>：方法区中存储了类的静态变量，它们在类加载时被创建，存在于整个生命周期中。</li><li><strong>即时编译器编译后的代码</strong>：在方法区中，即时编译器将字节码编译为机器码，并将编译后的代码存储在方法区供后续使用。</li></ol><p>需要注意的是，在Java 8及之前的版本中，方法区的大小是通过-Xmx和-XX:MaxPermSize参数进行设置的。而在Java 8及以后的版本中，方法区由元空间（Metaspace）取代，并且元空间的大小默认不受限制，可根据需要动态分配。</p><p>总结来说，方法区是用于存储类信息、常量、静态变量和即时编译器生成的代码等数据的内存区域。它在虚拟机启动时被创建，在虚拟机关闭时被销毁。</p><p>补充：</p><ol><li>字面量（Literal）： 字面量是指在源代码中直接出现的常量值。在编译期间，Java编译器会将源代码中的字面量转换为对应的字节码表示。常见的字面量包括整数、浮点数、字符、字符串、布尔值等。例如，源代码中的”Hello World”字符串字面量会在编译时被转换为相应的字节码指令。</li><li>符号引用（Symbol Reference）： 符号引用是指在Java源代码中使用的类、方法、字段等的符号名称。在编译期间，编译器会将这些符号引用转化为符号引用表来描述，并在链接阶段进一步解析为直接引用。符号引用包括类的全限定名、方法的签名、字段的名称等。例如，当源代码中使用到一个类或者方法时，编译器会将其表示为符号引用，待链接时再通过符号引用表找到对应的直接引用。</li></ol><h3 id="9、说一下Java对象的生命周期"><a href="#9、说一下Java对象的生命周期" class="headerlink" title="9、说一下Java对象的生命周期"></a>9、说一下Java对象的生命周期</h3><p>Java对象的生命周期可以分为以下几个阶段：</p><ol><li><strong>创建阶段</strong>（Creation）： 在创建阶段，通过关键字<code>new</code>或者其他实例化方式（如反射、对象池等），在堆内存中为对象分配内存空间，并调用对象的构造方法进行初始化。在这个阶段中，对象已经被创建，但还没有被完全初始化。</li><li><strong>使用阶段</strong>（Usage）： 在使用阶段，对象被引用并用于程序的各种操作。此时，可以通过对象的引用调用其方法、访问其属性等。</li><li><strong>不可达阶段</strong>（Unreachable）： 当对象不再被任何引用所指向时，进入不可达阶段。对象可能因为引用被置为null、超出了引用的作用域、或者引用被重新赋值而变得不可达。在此阶段，对象仍然存在于堆内存中，但无法通过任何途径访问。</li><li><strong>垃圾收集阶段</strong>（Garbage Collection）： 一旦对象进入不可达阶段，Java虚拟机的垃圾收集器将扫描内存，检测并回收这些不可达的对象。垃圾收集过程会释放对象占用的内存空间，并可能执行一些清理操作，如执行finalize()方法、关闭文件句柄等。</li><li><strong>回收阶段</strong>（Finalization）： 在垃圾收集阶段中，可能会对不可达对象执行finalize()方法。finalize()方法是对象的一个特殊方法，用于在对象被垃圾收集之前进行清理工作。但需要注意的是，finalize()方法的执行并不能保证实时性和可靠性。</li><li><strong>内存回收阶段</strong>（Memory Reclaim）： 在垃圾收集完成后，空闲的内存将被回收，并可以供给未来的对象创建和分配使用。</li></ol><p>需要注意的是，Java的内存管理是自动的，开发人员无需显式地释放对象占用的内存，而是由垃圾收集器负责管理和回收不再使用的对象。对象的生命周期由Java虚拟机自动进行管理，开发人员主要关注对象的创建、使用和适时地释放引用。</p><p>总结来说，Java对象的生命周期包括创建、使用、不可达、垃圾收集、回收等阶段。通过自动的垃圾收集机制，Java虚拟机负责管理对象的内存分配和回收，开发人员可以专注于对象的使用和逻辑处理。</p><h3 id="10、说一下Spring-Bean的生命周期"><a href="#10、说一下Spring-Bean的生命周期" class="headerlink" title="10、说一下Spring Bean的生命周期"></a>10、说一下Spring Bean的生命周期</h3><h4 id="第一种理解："><a href="#第一种理解：" class="headerlink" title="第一种理解："></a>第一种理解：</h4><p><strong>Bean的生命周期概括起来有四个阶段：</strong></p><p>​    <strong>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</strong></p><p>1、实例化<br>实例化一个Bean，即new。<br>2、IOC依赖注入<br>按照Spring上下文对实例化的Bean进行配置。<br>3、setBeanName实现<br>如果这个Bean已经实现了BeanNameAware接口，就会调用它实现的setBeanName(String)方法，此处传递的是Spring配置文件中Bean的id值。<br>4、setBeanFactory实现<br>如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(BeanFactory)方法，传递的是Spring工厂自身。<br>5、setApplicationContext实现<br>如果这个Bean实现了ApplicationContextAware接口，会调用它实现的setApplicationContext(ApplicationContext)方法，传递的是Spring的上下文。<br>6、postProcessBeforeInitialization实现-初始化预处理<br>如果这个Bean实现了BeanPostProcessor接口，将会调用它实现的postProcessBeforeInitialization(Object obj,String s)方法。BeanPostProcessor被用作Bean内容修改，并且由于这个是在Bean初始化结束的时候调用的这个方法，也可以被用于内存或缓存技术。<br>7、init-method<br>如果这个bean在Spring配置文件中配置了init-method属性，会自动调用其配置的初始化方法。或则@Bean(initMethod=”…”)指定的方法<br>8、postProcessAfterInitialization<br>如果这个Bean实现了BeanPostProcessor接口，将会调用它实现的postProcessAfterInitialization(Object obj,String s)方法。<br>以上工作完成以后就可以应用这个Bean了。<br>9、Destory过期自动清理<br>当Bean不再需要时，如果这个Bean实现了DisposableBean这个接口，会调用其实现的.destory()方法。<br>10、destory-method<br>如果这个bean在Spring配置文件中配置了destory-method属性，会自动调用其配置的销毁方法。或者@Bean(destroyMethod=”…”)指定的方法</p><p><img src="https://img-blog.csdnimg.cn/b2a76a505aea4bd78e6c41538db244bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCY6aOOeWY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h4 id="第二种理解："><a href="#第二种理解：" class="headerlink" title="第二种理解："></a>第二种理解：</h4><p>一、Spring Bean的生命周期总共分为4个阶段</p><blockquote><p>一阶段：Bean的实例化和DI（dependency injection）</p><p>二阶段：检查Spring Awareness</p><p>三阶段：创建<a href="https://so.csdn.net/so/search?q=bean生命周期&spm=1001.2101.3001.7020" target="_blank" rel="noopener">bean生命周期</a>回调</p><p>四阶段：销毁bean生命周期回调</p></blockquote><p>二、4个阶段<br>1、Bean的实例化和DI（dependency injection）<br>1.1  扫描XML文件、注释类（例：@Component）、配置类中bean的定义（@Configuration -&gt; @Bean）</p><p>1.2  创建Bean实例</p><p>1.3  注入Bean依赖项（调用setter或构造方法，为自动装配字段设置值）</p><p>2、 检查Spring Awareness（以下只是几个例子）<br>2.1  如果Bean实现了BeanNameAware接口，则调用setBeanName(…)；</p><p>2.2  如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader(…)；</p><p>2.3  如果Bean实现了ApplicationContextAware接口，则调用setApplicationContext(…)；</p><p>Aware接口用于告知Spring容器某个Bean需要某些特殊的处理，从而让Spring容器在创建Bean的过程中对它进行处理。 </p><p>ApplicationContextAware：让Bean实现这个接口可以让它获得一个ApplicationContext实例。</p><p>BeanFactoryAware：让Bean实现这个接口可以让它获得一个BeanFactory实例。</p><p>BeanNameAware：让Bean实现这个接口可以让它获得它自己在容器中的名字。</p><p>ServletContextAware：让Bean实现这个接口可以让它获得一个ServletContext实例。</p><p>ResourceLoaderAware：让Bean实现这个接口可以让它获得一个ResourceLoader实例。</p><p> 3、创建Bean生命周期回调<br>3.1  @PostConstruct注释，注释回调的方法上，1、2阶段Bean创建完毕即调用；</p><p>3.2  实现InitializingBean接口，调用afterPropertiesSet(…)，1、2阶段Bean创建完毕即调用；</p><p>3.3  Bean定义中包含init-method（在XML中标签<bean>的属性）或@Bean(initMethod=”…”)指定的方法，1、2阶段Bean创建完毕即调用；</p><p> 4、销毁bean生命周期回调<br>4.1  @PreDestroy注释，注释回调方法上，销毁Bean之前调用；</p><p>4.2  实现DisposableBean接口，调用destroy(…)，销毁Bean之前调用；</p><p>4.3  Bean定义中包含destroy-method（在XML中标签<bean>的属性）或@Bean(destroyMethod=”…”)指定的方法，销毁Bean之前调用；</p><h3 id="11、对象何时被回收，哪些对象可以作为-GC-Roots-根节点？"><a href="#11、对象何时被回收，哪些对象可以作为-GC-Roots-根节点？" class="headerlink" title="11、对象何时被回收，哪些对象可以作为 GC Roots 根节点？"></a>11、对象何时被回收，哪些对象可以作为 GC Roots 根节点？</h3><p>当对象在Java中不再被引用时，它将成为垃圾收集（Garbage Collection）的候选对象。具体来说，以下情况下对象可能被回收：</p><ol><li>引用计数法：<ul><li>如果使用引用计数法进行垃圾收集，当对象的引用计数变为0时，即没有任何活动引用指向该对象时，对象将被回收。（补充：引用计数无法解决循环引用的问题，例如循环依赖，BeanA依赖BeanB，BeanB又依赖BeanA，导致BeanA和BeanB引用计数一直为1无法为0而一直无法被gc视为垃圾而回收掉） </li></ul></li><li>可达性分析法：<ul><li>Java使用可达性分析法来判断对象是否可被回收。通过GC Roots作为起点，遍历对象引用链，如果对象不可达（无法从GC Roots到达），则认为该对象是不可达的，即可被回收。</li></ul></li></ol><p>GC Roots包括以下几种类型的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象：活动线程的栈帧中保存了局部变量，如果局部变量引用了某个对象，那么该对象就被视为GC Roots。</li><li>方法区中类静态属性引用的对象：所有被类的静态字段引用的对象都被视为GC Roots。</li><li>方法区中常量引用的对象：常量池中的常量引用的对象也是GC Roots。</li><li>本地方法栈中JNI（Java Native Interface）引用的对象：JNI是Java与其他本地语言进行交互的接口，在JNI代码中使用的对象也是GC Roots。</li></ul><p>除了以上GC Roots的对象，其他所有对象都可能被判定为不可达而被回收。</p><p>需要注意的是，Java垃圾收集器并不保证会立即回收所有不可达对象，而是在合适的时机进行垃圾回收。具体的回收策略和时机是由垃圾收集器决定的。</p><h3 id="12、请简单介绍下JVM有哪些垃圾回收算法？"><a href="#12、请简单介绍下JVM有哪些垃圾回收算法？" class="headerlink" title="12、请简单介绍下JVM有哪些垃圾回收算法？"></a>12、请简单介绍下JVM有哪些垃圾回收算法？</h3><p>JVM（Java虚拟机）中常见的垃圾回收算法包括以下几种：</p><ol><li>标记-清除算法（Mark and Sweep）：首先标记出所有活动对象，然后清除掉未被标记的对象。该算法容易产生内存碎片。</li><li>复制算法（Copying）：将可用内存分为两块，每次只使用其中一块。当当前块内存使用满后，将活动对象复制到另一块未使用的内存上，并清理之前的内存。该算法消耗较大的内存空间。</li><li>标记-整理算法（标记-压缩算法）（Mark and Compact）：首先标记出所有活动对象，然后将这些对象向一端移动，然后清理掉端边界以外的全部内存。该算法可以解决内存碎片问题。</li><li>分代收集算法（Generational）：根据对象的生命周期将堆分为多个区域，通常分为新生代和老年代。新生代中的对象生命周期较短，采用复制算法进行回收；老年代中的对象生命周期较长，采用标记-清除或标记-整理算法进行回收。</li></ol><p>这些垃圾回收算法具有不同的特点和应用场景，并根据具体情况选择合适的算法进行垃圾回收，以优化内存的使用和程序的性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、HttpServletRequest-如何重复读body？&quot;&gt;&lt;a href=&quot;#1、HttpServletRequest-如何重复读body？&quot; class=&quot;headerlink&quot; title=&quot;1、HttpServletRequest 如何重复读body？&quot;&gt;&lt;/a&gt;1、HttpServletRequest 如何重复读body？&lt;/h3&gt;&lt;p&gt;在标准的&lt;code&gt;HttpServletRequest&lt;/code&gt;中，只能通过一次读取&lt;code&gt;request.getInputStream()&lt;/code&gt;或&lt;code&gt;request.getReader()&lt;/code&gt;来获取请求体的内容。一旦读取完成，就无法再次重复读取。这是因为请求体是一个流式数据，只能读取一次。&lt;/p&gt;
&lt;p&gt;但是，如果您想在需要时多次访问请求体的内容，您可以考虑将请求体内容保存到一个临时变量或者使用缓冲区来存储它。下面是一个示例代码，展示了如何将请求体内容保存为字符串：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读取请求体内容并保存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringBuilder requestBody = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BufferedReader reader = request.getReader();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String line;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((line = reader.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    requestBody.append(line);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在需要的地方使用请求体内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String requestBodyString = requestBody.toString();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 requestBodyString 进行后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当需要再次访问请求体内容时，可以使用 requestBodyString 变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;请注意，将请求体保存为字符串或其他形式的变量可能会导致内存占用增加。因此，如果请求体非常大或者频繁访问请求体内容会对性能产生不利影响，您可能需要重新评估您的需求并考虑其他解决方案。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java面经" scheme="http://quanluo.github.io/tags/Java%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Spring 如何解决 Bean 的循环依赖问题(转载)</title>
    <link href="http://quanluo.github.io/2023/07/01/%E6%B5%85%E8%B0%88-Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://quanluo.github.io/2023/07/01/%E6%B5%85%E8%B0%88-Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/</id>
    <published>2023-07-01T07:03:10.000Z</published>
    <updated>2023-07-01T07:52:34.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h2><p>通俗来讲，循环依赖指的是<strong>一个实例或多个实例存在相互依赖的关系</strong>（类之间循环嵌套引用）。</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中 <code>AService</code> 依赖了 <code>BService</code>，<code>BService</code> 也依赖了 <code>AService</code>，这就是两个对象之间的相互依赖。当然循环依赖还包括 <strong>自身依赖、多个实例之间相互依赖</strong>。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/82fcae531d9a47b09a72c05c85c67aa1.png#pic_center" alt="在这里插入图片描述"></p><p>正常运行上面的代码调用 <code>AService</code> 对象并不会出现问题，也就是说普通对象就算出现循环依赖也不会存在问题，因为对象之间存在依赖关系是很常见的，那么为什么被 Spring 容器管理后的对象会出现循环依赖问题呢？</p><h2 id="2-Spring-Bean-的循环依赖问题"><a href="#2-Spring-Bean-的循环依赖问题" class="headerlink" title="2. Spring Bean 的循环依赖问题"></a>2. Spring Bean 的循环依赖问题</h2><p>被 Spring 容器管理的对象叫做 Bean，为什么 Bean 会存在循环依赖问题呢？</p><p>想要了解 Bean 的循环依赖问题，首先需要了解 Bean 是如何创建的。</p><h3 id="2-1-Bean-的创建步骤"><a href="#2-1-Bean-的创建步骤" class="headerlink" title="2.1 Bean 的创建步骤"></a>2.1 Bean 的创建步骤</h3><p>为了能更好的展示出现循环依赖问题的环节，所以这里的 Bean 创建步骤做了简化：</p><p>1、在创建 Bean 之前，Spring 会通过扫描获取 BeanDefinition。</p><p>2、BeanDefinition就绪后会读取 BeanDefinition 中所对应的 class 来加载类。</p><p>3、实例化阶段：根据构造函数来完成实例化 （<strong>未属性注入以及初始化的对象</strong> 这里简称为 <strong>原始对象</strong>）</p><p>4、属性注入阶段：对 Bean 的属性进行依赖注入 （这里就是<strong>发生循环依赖问题的环节</strong>）</p><p>5、如果 Bean 的某个方法有AOP操作，则需要根据原始对象生成<strong>代理对象</strong>。</p><p>6、最后把代理对象放入单例池（一级缓存<code>singletonObjects</code>）中。</p><p><strong>两点说明：</strong></p><p>上面的 Bean 创建步骤是对于 <strong>单例（singleton）</strong> 作用域的 Bean。</p><p>Spring 的 AOP 代理就是作为 <code>BeanPostProcessor</code> 实现的，而 <code>BeanPostProcessor</code> 是发生在属性注入阶段后的，所以 <strong>AOP</strong> 是在 <strong>属性注入</strong> 后执行的。</p><h3 id="2-2-为什么-Spring-Bean-会产生循环依赖问题？"><a href="#2-2-为什么-Spring-Bean-会产生循环依赖问题？" class="headerlink" title="2.2 为什么 Spring Bean 会产生循环依赖问题？"></a>2.2 为什么 Spring Bean 会产生循环依赖问题？</h3><p>通过上面的 Bean 创建步骤可知：实例化 Bean 后会进行 属性注入（依赖注入）</p><p>如上面的 <code>AService</code> 和 <code>BService</code> 的依赖关系，当 <code>AService</code> 创建时，会先对 <code>AService</code> 进行实例化生成一个原始对象，然后在进行属性注入时发现了需要 <code>BService</code> 对应的 Bean，此时就会去为 <code>BService</code> 进行创建，在 <code>BService</code> 实例化后生成一个原始对象后进行属性注入，此时会发现也需要 <code>AService</code> 对应的 Bean。</p><p><img src="https://img-blog.csdnimg.cn/7983014a8e83491ead2759641939cb80.png#pic_center" alt="在这里插入图片描述"></p><p>这样就会造成 <code>AService</code> 和 <code>BService</code> 的 Bean 都无法创建，就会产生 <strong>循环依赖</strong> 问题。</p><h3 id="2-3-三大循环依赖问题场景"><a href="#2-3-三大循环依赖问题场景" class="headerlink" title="2.3 三大循环依赖问题场景"></a>2.3 三大循环依赖问题场景</h3><p>Spring 并不能解决所有 Bean 的循环依赖问题，接下来通过例子来看看哪些场景下的循环依赖问题是不能被解决的。循环依赖是指在应用程序中存在相互引用的对象，导致无法正确地初始化这些对象。以下是三个常见的循环依赖问题场景：</p><ol><li>构造函数循环依赖： 当两个或多个类在它们的构造函数中相互依赖时，可能会引发构造函数循环依赖问题。例如，类A依赖于类B的实例，而同时类B也依赖于类A的实例。这种情况下，如果使用传统的依赖注入方式，很可能会导致无限循环，无法正确完成实例化。</li><li>属性循环依赖： 当两个或多个类之间存在相互依赖的属性关系时，可能会引发属性循环依赖问题。例如，类A有一个属性引用类型为类B的实例，而类B又有一个属性引用类型为类A的实例。如果没有正确处理循环依赖，可能会导致无法正确初始化属性。</li><li>静态成员变量循环依赖： 当两个或多个类之间存在相互依赖的静态成员变量时，可能会引发静态成员变量循环依赖问题。例如，类A的静态成员变量引用类型为类B的实例，而类B的静态成员变量又引用类型为类A的实例。这种情况下，无法解决循环依赖，可能导致应用程序加载和初始化时出现问题。</li></ol><p>以上是三个常见的循环依赖问题场景。在实际开发中，为了避免循环依赖问题，可以采取一些解决方案，例如使用延迟初始化、Setter注入替代构造函数注入、引入第三方容器管理依赖关系等。具体的解决方法可以根据具体的情况和框架选择。</p><p>对应的解决方法：</p><ol><li>构造函数循环依赖：<ul><li>通过构造函数注入改为使用Setter注入：将类的依赖关系改为通过Setter方法来注入，从而打破循环依赖。</li><li>使用延迟初始化：延迟初始化一个或多个循环依赖的对象，可以通过懒加载或者使用代理对象实现。</li></ul></li><li>属性循环依赖：<ul><li>使用懒加载（<strong>@Lazy</strong>）：将循环依赖的属性设置为延迟加载，只有在需要的时候才进行初始化。</li><li>使用中间对象：引入一个中间对象，它的责任是处理循环依赖的属性，并且在合适的时候进行初始化。</li></ul></li><li>静态成员变量循环依赖：<ul><li>使用静态工厂方法：将实例的创建和初始化放在静态工厂方法中，由工厂方法控制依赖关系的初始化顺序。</li><li>使用第三方容器：使用像Spring这样的依赖注入容器，容器可以解决循环依赖问题并正确地管理对象的生命周期。</li></ul></li></ol><h2 id="3-Spring-如何解决循环依赖问题？"><a href="#3-Spring-如何解决循环依赖问题？" class="headerlink" title="3. Spring 如何解决循环依赖问题？"></a>3. Spring 如何解决循环依赖问题？</h2><p>通过上文的内容能了解到  <strong>Spring 为什么会产生循环依赖问题</strong> 以及 <strong>Spring 能解决什么场景下的循环依赖问题</strong>。</p><p>上文中也有提到过 Spring 是靠 <strong>三级缓存</strong> 来解决循环依赖问题的，接下来了解一下 <strong>什么是三级缓存</strong> 以及 <strong>解决循环依赖问题的具体流程</strong>。</p><h3 id="3-1-三级缓存是什么？"><a href="#3-1-三级缓存是什么？" class="headerlink" title="3.1 三级缓存是什么？"></a>3.1 三级缓存是什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>三级缓存分为：</p><ul><li>一级缓存（<code>singletonObjects</code>）：缓存的是<strong>已经实例化、属性注入、初始化后</strong>的 Bean 对象。</li><li>二级缓存（<code>earlySingletonObjects</code>）：缓存的是<strong>实例化后，但未属性注入、初始化</strong>的 Bean对象（用于提前暴露 Bean）。</li><li>三级缓存（<code>singletonFactories</code>）：缓存的是一个 <code>ObjectFactory</code>，主要作用是生成原始对象进行 AOP 操作后的<strong>代理对象</strong>（这一级缓存主要用于解决 AOP 问题，后续文章中讲解）。</li></ul><h3 id="3-2-为什么缓存可以解决循环依赖问题？"><a href="#3-2-为什么缓存可以解决循环依赖问题？" class="headerlink" title="3.2 为什么缓存可以解决循环依赖问题？"></a>3.2 为什么缓存可以解决循环依赖问题？</h3><p><strong>（注意这里只是为了说明缓存可以解决循环依赖问题，但是 Spring 实际上并不是这样做的）</strong></p><p>上文中可以看到 <code>AService</code> 和 <code>BService</code> 的循环依赖问题是因为 <code>AService的创建</code> 需要 <code>BService的注入</code>，<code>BService的注入</code> 需要 <code>BService的创建</code>，<code>BService的创建</code> 需要 <code>AService的注入</code>，<code>AService的注入</code> 需要 <code>AService的创建</code>，从而形成的环形调用。</p><p>想要打破这一环形，只需要增加一个 <strong>缓存</strong> 来存放 <strong>原始对象</strong> 即可。</p><p>在创建 <code>AService</code> 时，实例化后将 <strong>原始对象</strong> 存放到缓存中（提早暴露），然后依赖注入时发现需要 <code>BService</code>，便会去创建 <code>BService</code>，实例化后同样将 <strong>原始对象</strong> 存放到缓存中，然后依赖注入时发现需要 <code>AService</code> 便会从缓存中取出并注入，这样 <code>BService</code> 就完成了创建，随后 <code>AService</code> 也就能完成属性注入，最后也完成创建。这样就打破了环形调用，避免循环依赖问题。</p><p><img src="https://img-blog.csdnimg.cn/36952edcc9bb491ab3f27d116ebd0162.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-3-为什么还需要第三级缓存？"><a href="#3-3-为什么还需要第三级缓存？" class="headerlink" title="3.3 为什么还需要第三级缓存？"></a>3.3 为什么还需要第三级缓存？</h3><p>通过上面的分析可以发现只需要一个存放 <strong>原始对象</strong> 的缓存就可以解决循环依赖问题，也就是说只要二级缓存（<code>earlySingletonObjects</code>）就够了，那么为什么 Spring 还设置了三级缓存（<code>singletonFactories</code>）呢？</p><p>其实 <strong>第三级缓存（<code>singletonFactories</code>）</strong> 是为了处理 Spring 的 AOP的。</p><p>如上面的例子如果 <code>AService</code> 中方法没有使用 AOP 操作，会发现 <code>BService</code> 注入的 <strong>原始对象</strong> 与最后 <code>AService</code> 完成创建后的最终对象是<strong>同一个对象</strong>。</p><p>如果 <code>AService</code> 方法中有 AOP 操作，Bean 的创建会如下图：</p><p><img src="https://img-blog.csdnimg.cn/7e40764da2c042c3a0dc074becf31a33.png#pic_center" alt="在这里插入图片描述"></p><p>所以如果 <code>AService</code> 方法中有 AOP 操作时，当 <code>AService</code> 的原始对象赋值（注入）给 <code>BService</code>，<code>AService</code> 会进行 AOP 操作产生一个 <strong>代理对象</strong>，这个代理对象最后会被放入单例池（一级缓存）中，也就是说此时 <code>BService</code> 中注入的对象是原始对象，而 <code>AService</code> 最终创建的完成后是代理对象，这样就会<strong>导致 <code>BService</code> 依赖的 <code>AService</code> 和 最终的 <code>AService</code> 不是同一个对象</strong>。</p><p>出现这个问题主要是上文提到过的 AOP 是通过 <code>BeanPostProcessor</code> 实现的，而 <code>BeanPostProcessor</code> 是在 <strong>属性注入阶段后</strong> 才执行的，所以会导致<strong>注入的对象有可能和最终的对象不一致</strong>。</p><hr><h3 id="3-4-Spring-是如何通过第三级缓存来避免-AOP-问题的？"><a href="#3-4-Spring-是如何通过第三级缓存来避免-AOP-问题的？" class="headerlink" title="3.4 Spring 是如何通过第三级缓存来避免 AOP 问题的？"></a>3.4 Spring 是如何通过第三级缓存来避免 AOP 问题的？</h3><p>三级缓存中存放的是 <code>ObjectFactory</code> 对象，那 <code>ObjectFactory</code> 是什么呢？</p><p><strong><code>ObjectFactory</code> 是什么？</strong></p><p>深入源码会发现 Spring 在 <code>doCreateBean()</code> 方法中的 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 加入缓存。</p><p><img src="https://img-blog.csdnimg.cn/2ec8b645ed1e4e438b002c0d64f58b32.png#pic_center" alt="在这里插入图片描述"></p><p>深入 <code>addSingletonFactory</code> 方法：可以看到方法中的第二个参数就是 <code>ObjectFactory</code> 类型，并且将其添加进 <strong>三级缓存（<code>singletonFactories</code>）</strong> 中。</p><p><img src="https://img-blog.csdnimg.cn/e6a26511dcb540cf852ff0cc76228799.png#pic_center" alt="在这里插入图片描述"></p><p>这里放一下 <code>ObjectFactory</code> 类：</p><p><img src="https://img-blog.csdnimg.cn/c8c5d9b21cf942a9b5e24eca6bcf9855.png#pic_center" alt="在这里插入图片描述"></p><p>也就是说 Spring 在加入缓存时，会将 <strong>实例化后生成的原始对象</strong> 通过 <strong>lambda 表达式调用 <code>getObject()</code> 方法，<code>getObject()</code> 方法里调用 <code>getEarlyBeanReference()</code> 方法</strong> 来封装成 <code>ObjectFactory</code> 对象。</p><p><strong><code>getEarlyBeanReference()</code> 方法的作用</strong></p><p>进入 <code>getEarlyBeanReference()</code> 中，会发现调用了 <code>SmartInstantiationAwareBeanPostProcessor</code> 的 <code>getEarlyBeanReference()</code> 方法。</p><p><img src="https://img-blog.csdnimg.cn/8fefe0ef648f4261bb1a93b7fce740c6.png#pic_center" alt="在这里插入图片描述"></p><p>找到 <code>SmartInstantiationAwareBeanPostProcessor</code> 的实现类 <code>AbstractAutoProxyCreator</code> 实现的 <code>getEarlyBeanReference()</code> 方法就可以看到其作用了。</p><p><img src="https://img-blog.csdnimg.cn/c8e411fa884d499492a3c2aed14af34f.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>earlyProxyReferences</code> 存储的是 <code>(beanName, bean)</code> 键值对，这里的 bean 指的是原始对象（刚实例化后的对象）。</li><li><code>wrapIfNecessary()</code> 方法用于执行 AOP 操作，生成一个<strong>代理对象</strong>（也就是说<strong>如果有 AOP 操作最后返回的是代理对象，否则返回的还是原始对象</strong>）。</li></ul><blockquote><p><strong>Spring 真正意义上地创建 Bean 的流程</strong></p></blockquote><p>先放具体流程图：</p><p><img src="https://img-blog.csdnimg.cn/97e65a93c0c949e5bde3623288d99e08.png#pic_center" alt="在这里插入图片描述"></p><p>要点说明：</p><ol><li>并不是马上就执行 <code>ObjectFactory</code> 的 <code>getEarlyBeanReference()</code> 方法（有循环依赖时才执行）。<ul><li>实例化后的 Bean 会生成原始对象，然后经过 lambda 表达式封装为 <code>ObjectFactory</code> 对象，并且通过 <code>addSingletonFactory()</code> 方法将其放入 三级缓存（<code>singletonFactories</code>）中。</li><li>但是这里执不执行 lambda 表达式中的 <code>getEarlyBeanReference()</code> 方法是看程序有没有调用 <code>singletonFactories.get(beanName)</code>，只有调用了该方法（其实也就是看<strong>是否存在循环依赖</strong>需要提前获得该 Bean），才会触发执行 <code>getEarlyBeanReference()</code> 方法。</li><li>而 <code>getEarlyBeanReference()</code> 方法会根据 Bean 中是否有 AOP 操作来决定返回的是 <strong>原始对象</strong> 还是 <strong>代理对象</strong>，并且会将其上移到二级缓存中（也就是提前暴露出来让别的 Bean 使用）。</li></ul></li><li>如果 Bean 中有 AOP 操作，而 AOP 操作又是在属性注入之后执行的，那么之前的 <code>getEarlyBeanReference()</code> 方法中执行的 AOP 操作<strong>会不会重复</strong>？<ul><li><strong>答案是不会</strong>，还记得 <code>getEarlyBeanReference()</code> 方法中的 <strong><code>earlyProxyReferences</code></strong> 吗，这个就是用来记录当前 Bean 是否已经执行 AOP 操作。</li><li>当属性注入后需要执行 AOP 操作时，会先判断当前的 Bean 是否在 <code>earlyProxyReferences</code> 中，如果在则说明已经提前执行了 AOP 了，不用再执行了，否则就执行当前 AOP 操作。</li></ul></li><li>二级缓存中的对象什么时候会上移到一级缓存？<ul><li>二级缓存是为了提前暴露 Bean 来解决循环依赖问题，此时的 Bean 可能还没有进行属性注入，只有等完成了属性注入、初始化后的 Bean 才会上移到一级缓存（单例池）中。</li></ul></li><li>为什么可以解决 AOP 的问题？<ul><li>三级缓存通过利用 <code>ObjectFactory</code> 和 <code>getEarlyBeanReference()</code> 做到了提前执行 AOP 操作从而生成代理对象。</li><li>这样在上移到二级缓存时，可以做到如果 Bean 中有 AOP 操作，那么提前暴露的对象会是 AOP 操作后返回的代理对象；如果没有 AOP 操作，那么提前暴露的对象会是原始对象。</li><li>这样就能做到出现循环依赖问题时，注入依赖的对象和最终生成的对象是同一个对象。（相当于 AOP 提前在属性注入前完成，这样就不会导致后面生成的代理对象与属性注入时的对象的不一致）</li></ul></li></ol><p>所以 Spring 利用 <strong>三级缓存</strong> 巧妙地将出现 <strong>循环依赖</strong> 时的 <strong>AOP 操作</strong> 提前到了 <strong>属性注入</strong> 之前，避免了对象不一致问题。</p><h2 id="4-梳理-Spring-解决-Bean-的循环依赖的整个流程"><a href="#4-梳理-Spring-解决-Bean-的循环依赖的整个流程" class="headerlink" title="4. 梳理 Spring 解决 Bean 的循环依赖的整个流程"></a>4. 梳理 Spring 解决 Bean 的循环依赖的整个流程</h2><p>还是以 <code>AService</code> 和 <code>BService</code> 的循环依赖为例，完整地看看 Spring 是如何解决 Bean 的循环依赖问题。</p><blockquote><p><strong>源码分析整个流程</strong></p></blockquote><p>由于前面的内容过于繁琐，这里就以文字概括，只关注几个主要的方法：</p><p>以 <code>AbstractApplicationContext</code> 的 <code>refresh()</code> 方法出发，进入 <code>finishBeanFactoryInitialization()</code> 方法再进入 <code>preInstantiateSingletons()</code> 方法再进入 <code>getBean()</code> 方法再进入 <code>doGetBean()</code> 方法。</p><p>看看 <code>doGetBean()</code> 方法：</p><p><img src="https://img-blog.csdnimg.cn/d7365a617df74c49891f373ed63acf2f.png#pic_center" alt="在这里插入图片描述"></p><p>其中的第一个 <code>getSingleton(beanName)</code> 是判断 <strong>三级缓存</strong> 中是否有创建好的 Bean 对象，看看源码：</p><p><img src="https://img-blog.csdnimg.cn/47c926d30aa64b5d87c386eac3cc8508.png#pic_center" alt="在这里插入图片描述"></p><p>可以看到这里分别去每一级的缓存中取数据，依次从第一级开始取数据，如果取得到则直接返回，取不到则往下一级查找。</p><p>可以看到在<strong>第三级缓存</strong>中调用了 <code>singletonFactories.get(beanName)</code> 按照上文所说的会触发执行有 AOP 操作返回代理对象，没有返回原始对象，并且在这里会判断取出的数据是否存在，存在则上移到二级缓存中并删除三级缓存的数据。</p><p>如果都没有的话就会执行第二个 <code>getSingleton()</code> 也就是去执行 <code>createBean()</code> 创建一个 Bean 对象出来。</p><p>会执行 <code>createBean()</code> 方法中的 <code>doCreateBean()</code> 方法，看看源码：</p><p><img src="https://img-blog.csdnimg.cn/254eea85cca34b39ab6c847d8cf0ee9d.png#pic_center" alt="在这里插入图片描述"></p><p>到这里应该就一目了然了。</p><blockquote><p><strong>梳理整个流程</strong></p></blockquote><ol><li>首先会获取 <code>AService</code> 对应的 Bean 对象。</li><li>先是调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 判断是否有该 Bean 的实例，有就直接返回了。（显然这里没有）</li><li>然后调用 <code>doGetBean()</code> 中的第二个 <code>getSingleton()</code> 方法来执行 <code>doCreateBean()</code> 方法。</li><li>先进行实例化操作（也就是利用构造函数实例化），此时实例化后生成的是原始对象。</li><li>将原始对象通过 lambda表达式 进行封装成 <code>ObjectFactory</code> 对象，通过 <code>addSingletonFactory</code> 加入三级缓存中。</li><li>然后再进行属性注入，此时发现需要注入 <code>BService</code> 的 Bean，会通过 <code>doGetBean()</code> 去获取 <code>BService</code> 对应的 Bean。</li><li>同样调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 判断是否有该 Bean 的实例，显然这里也是不会有 <code>BService</code> 的 Bean 的。</li><li>然后只能调用 <code>doGetBean()</code> 中的第二个 <code>getSingleton()</code> 方法来执行 <code>doCreateBean()</code> 方法来创建一个 <code>BService</code> 的 Bean。</li><li>同样地先进行实例化操作，生成原始对象后封装成 <code>ObjectFactory</code> 对象放入三级缓存中。</li><li>然后进行属性注入，此时发现需要注入 <code>AService</code> 的 Bean，此时调用调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 查找是否有 <code>AService</code> 的 Bean。此时会触发三级缓存，也就是调用 <code>singletonFactories.get(beanName)</code>。</li><li>因为三级缓存中有 <code>AService</code> 的原始对象封装的 <code>ObjectFactory</code> 对象，所以可以获取到的代理对象或原始对象，并且上移到二级缓存中，提前暴露给 <code>BService</code> 调用。</li><li>所以 <code>BService</code> 可以完成属性注入，然后进行初始化后，将 Bean 放入一级缓存，这样 <code>AService</code> 也可以完成创建。</li></ol><p>以上就是 Spring 解决 Bean 的循环依赖问题的整个流程了。</p><h2 id="5-疑问"><a href="#5-疑问" class="headerlink" title="5.疑问"></a>5.疑问</h2><h3 id="为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理"><a href="#为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理" class="headerlink" title="为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理"></a>为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理</h3><p>解答：</p><p>这个问题太经典了，这里我说一下我的看法：首先呢，如果使用二级缓存的话，那么我可以理解为相当于提前判断Bean是否需要AOP，需要的话直接生成代理对象放入二级缓存，等Bean创建完成后再升到一级缓存中。大概是这个思路吧，但是为什么Spring不这么设计呢，我认为有两点原因：① 由于Spring对AOP的设计思想是AOP的创建时机是在初始化后为Bean生成代理对象的，如果采用上述的设计，那么不管Bean是否存在循环依赖，都会提早生成代理对象，这样其实已经违背了Bean的设计理念。② 使用ObjectFactory对象每次触发调用lambda表达式中的 <code>getEarlyBeanReference()</code>生成的代理对象其实都是新创建的，也就是说如果存在两个以上的Bean循环依赖，例如 A 依赖 B 和 C，而 B 也依赖 A，C 也依赖A，并且A需要AOP，那么此时在创建 B 时触发 A 的ObjectFactory对象生成的代理对象和创建 C 时触发 A 的ObjectFactory对象生成的代理对象是不一样的，因为两次触发生成的都是新对象。这也就是为什么需要在中间设置一个二级缓存存放第一次调用创建的代理对象，这样还需要属性注入 A 的Bean就可以直接在二级缓存中拿，而不需要再次触发ObjectFactory对象。</p><p>作者：单程车票<br>链接：<a href="https://juejin.cn/post/7218080360403615804" target="_blank" rel="noopener">https://juejin.cn/post/7218080360403615804</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是循环依赖？&quot;&gt;&lt;a href=&quot;#1-什么是循环依赖？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是循环依赖？&quot;&gt;&lt;/a&gt;1. 什么是循环依赖？&lt;/h2&gt;&lt;p&gt;通俗来讲，循环依赖指的是&lt;strong&gt;一个实例或多个实例存在相互依赖的关系&lt;/strong&gt;（类之间循环嵌套引用）。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; BService bService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; AService aService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上述例子中 &lt;code&gt;AService&lt;/code&gt; 依赖了 &lt;code&gt;BService&lt;/code&gt;，&lt;code&gt;BService&lt;/code&gt; 也依赖了 &lt;code&gt;AService&lt;/code&gt;，这就是两个对象之间的相互依赖。当然循环依赖还包括 &lt;strong&gt;自身依赖、多个实例之间相互依赖&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://quanluo.github.io/tags/Spring/"/>
    
      <category term="循环依赖" scheme="http://quanluo.github.io/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>学Java的这些HashMap的知识点必须得懂(JDK1.8)</title>
    <link href="http://quanluo.github.io/2023/06/30/%E5%AD%A6Java%E7%9A%84%E8%BF%99%E4%BA%9BHashMap%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%85%E9%A1%BB%E5%BE%97%E6%87%82(JDK1.8)/"/>
    <id>http://quanluo.github.io/2023/06/30/%E5%AD%A6Java%E7%9A%84%E8%BF%99%E4%BA%9BHashMap%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%85%E9%A1%BB%E5%BE%97%E6%87%82(JDK1.8)/</id>
    <published>2023-06-30T07:09:54.000Z</published>
    <updated>2023-06-30T07:50:50.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><ol><li><p><strong>扩容条件判断：当 HashMap 中的元素数量超过了负载因子与当前容量的乘积时，就会触发扩容操作。具体判断条件可以参考 <code>threshold</code> 的计算方式。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br></pre></td></tr></table></figure><ul><li><p>在 HashMap 中，<code>threshold</code> 是用来判断是否需要进行扩容的阈值。<code>threshold</code> 的计算方式是将当前容量 (<code>capacity</code>) 乘以负载因子 (<code>loadFactor</code>)，然后将结果转换为整数。</p><p>负载因子是一个表示 HashMap 元素填充程度的参数，默认情况下是 0.75。当 HashMap 中的元素数量超过了 <code>threshold</code>，就会触发扩容操作，以保持 HashMap 的性能。</p><p><code>threshold</code> 的计算公式是 <code>threshold = (int)(capacity * loadFactor)</code>，其中 <code>capacity</code> 表示当前 HashMap 的容量，<code>loadFactor</code> 表示负载因子。</p><p>具体来说，<code>capacity * loadFactor</code> 的结果是一个浮点数，通过强制类型转换 <code>(int)</code> 将其转换为整数。强制类型转换会将浮点数的小数部分截断，只取整数部分。这样就得到了一个整数类型的 <code>threshold</code>。</p><p>计算出的 <code>threshold</code> 值实际上代表了 HashMap 在什么时候需要进行扩容。当 HashMap 中的元素数量达到了 <code>threshold</code>，即超过了负载因子所允许的填充程度时，就会触发扩容操作。</p><p>通过合理设置负载因子，可以在空间与时间的平衡中进行权衡。较小的负载因子可以减少空间消耗，但可能导致哈希冲突增加；较大的负载因子可以减少哈希冲突，但会增加空间消耗。根据具体的应用场景，可以调整负载因子以达到最佳性能。</p><p>总结起来，<code>threshold = (int)(capacity * loadFactor)</code> 是根据当前容量和负载因子计算得出的触发 HashMap 扩容的阈值，当元素数量超过该阈值时，HashMap 将进行扩容操作。</p><a id="more"></a></li></ul></li><li><p><strong>创建新数组：在扩容时，将会创建一个新的数组，其大小是原数组的两倍。新数组的容量是原数组容量的两倍，并且容量必须是 2 的幂次方。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = <span class="keyword">new</span> Node[newCap];</span><br></pre></td></tr></table></figure><ul><li><p>在 HashMap 中，<code>newTab</code> 是一个新的 Node 数组，用于存储扩容后的元素。<code>newCap</code> 是扩容后的容量，代表了新数组的长度。</p><p><code>Node&lt;K,V&gt;[] newTab = new Node[newCap]</code> 是创建一个新的 Node 数组对象。其中 <code>&lt;K, V&gt;</code> 表示泛型类型参数，分别代表键和值的类型。</p><p>通过 <code>new Node[newCap]</code> 创建出的新数组，每个元素都是一个 Node 类型的对象。Node 类型通常表示哈希桶中的一个节点，用于存储实际的键值对。</p><p>在 HashMap 的扩容过程中，需要创建一个容量更大的新数组，并将原数组中的元素重新分配到新数组的对应位置上。这是因为扩容后 HashMap 需要有更多的桶来分散键值对，以减少哈希冲突的概率。</p><p>在创建新数组时，使用 <code>new Node[newCap]</code> 声明并初始化一个新的 Node 数组。注意，<code>newCap</code> 是指定的新容量大小，是原容量的两倍或其他扩容方式计算得出的结果。</p><p>通过创建新的 Node 数组，HashMap 就可以在扩容后使用更大的内部数组来存储元素，以适应更多的键值对。接下来，就可以将原数组中的元素重新插入到新数组的相应位置上，并更新 HashMap 内部的数据结构，完成扩容操作。</p></li></ul></li><li><p><strong>数据迁移：接下来，需要将原数组中的数据逐个迁移到新数组中。这一过程称为重新哈希(Rehash)。对于每个非空的桶，会遍历链表或红黑树中的节点，并根据新数组的容量重新计算其在新数组中的位置。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; e : oldTab) &#123;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算新的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> newIndex = indexFor(e.hash, newCapacity);</span><br><span class="line">        <span class="comment">// 将节点添加到新数组中</span></span><br><span class="line">        <span class="comment">// 省略部分代码...</span></span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>更新引用：完成数据迁移后，需要更新 HashMap 对象内部的一些引用。主要包括数组的引用和阈值的更新。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table = newTab;</span><br><span class="line">threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br></pre></td></tr></table></figure><ul><li><p><code>table = newTab;</code> 和 <code>threshold = (int)(newCapacity * loadFactor);</code> 是在 HashMap 扩容过程中更新数据结构的两个关键步骤。</p><p>首先，<code>table = newTab;</code> 将引用指向新的数组 <code>newTab</code>。这意味着 HashMap 的内部数组 <code>table</code> 现在引用了扩容后的新数组，从而使 HashMap 在接下来的操作中使用新数组来存储元素。</p><p>接着，<code>threshold = (int)(newCapacity * loadFactor);</code> 根据新的容量 <code>newCapacity</code> 和负载因子 <code>loadFactor</code> 计算得到新的阈值 <code>threshold</code>。这个阈值表示在何时需要再次进行扩容。</p><p>解释一下这个计算过程：<code>newCapacity</code> 是新数组的容量，它可能是原容量的两倍或其他扩容方式计算得出的结果。负载因子 <code>loadFactor</code> 是一个参数，表示 HashMap 元素填充程度的比例，默认为 0.75。</p><p><code>newCapacity</code> 乘以 <code>loadFactor</code> 得到一个浮点数，然后通过强制类型转换 <code>(int)</code> 将其转换为整数形式。这样得到的 <code>threshold</code> 就是新容量和负载因子相乘后取整得到的结果。</p><p>计算出的新阈值 <code>threshold</code> 可以用来判断何时再次触发扩容操作。当 HashMap 中的元素数量超过了新阈值时，就会触发下一次的扩容操作，以保持 HashMap 的性能。</p></li></ul></li><li><p><strong>并发处理：在多线程环境下，可能存在并发情况下进行的插入、删除等操作。为了保证线程安全，HashMap 在扩容过程中会采取一些措施，如使用 synchronized 关键字或者 CAS（Compare and Swap）操作来避免并发问题。</strong></p></li></ol><p><strong>总结起来，HashMap 的扩容步骤可以概括为：创建新数组、将原数组的数据迁移到新数组中、更新引用和处理并发情况。通过扩容，HashMap 可以提高容量，从而减少哈希冲突的概率，提高查询和插入操作的性能。</strong></p><h3 id="为什么HashMap扩容的容量必须是-2-的幂次方"><a href="#为什么HashMap扩容的容量必须是-2-的幂次方" class="headerlink" title="为什么HashMap扩容的容量必须是 2 的幂次方"></a>为什么HashMap扩容的容量必须是 2 的幂次方</h3><p>HashMap 扩容的容量必须是 2 的幂次方，这是因为 HashMap 在计算元素在数组中存储位置时使用了位运算，通过将哈希值与 (capacity - 1) 进行与操作来得到索引值。具体而言，假设 HashMap 的容量为 n，那么对应的数组索引范围为 [0, n-1]。</p><p>原始的 HashMap 实现使用取模运算（<code>%</code>）来计算索引，例如 <code>index = hash % capacity</code>。然而，这种方式在计算机中是比较耗时的操作，而且对于不同的容量，取模的结果分布并不均匀。</p><p>为了提高计算速度和优化索引的分布，HashMap 使用位运算来计算索引，将取模操作转换为与运算（<code>&amp;</code>）。具体地，假设容量是 2 的幂次方（即 n = 2^k），那么 <code>(n - 1)</code> 的二进制形式的所有位都是 1。这样，在进行与操作时，结果的最低 k 位就是哈希值的有效位，通过这些有效位可以获取到元素在数组中的索引。</p><p>例如，当容量为 16 （即 2^4）时，<code>(n - 1)</code> 的二进制形式为 1111，对任意哈希值进行与操作后，得到的结果只会影响哈希值的最低 4 位，即 <code>hash &amp; (capacity - 1)</code>。这样，通过位运算而不是取模运算来计算索引，可以提高计算效率，并且保持了较好的分布性。</p><p>因此，在设计 HashMap 扩容机制时，为了保持元素在数组中的位置计算准确和高效，容量必须是 2 的幂次方。这样可以充分利用位运算来计算索引，提高 HashMap 的性能和效率。</p><h3 id="为何HashMap中的扩容是-lt-lt-1"><a href="#为何HashMap中的扩容是-lt-lt-1" class="headerlink" title="为何HashMap中的扩容是&lt;&lt;1"></a>为何HashMap中的扩容是&lt;&lt;1</h3><p>在 HashMap 中，扩容操作使用的是位运算符 <code>&lt;&lt;</code> 来实现容量的翻倍。<code>&lt;&lt;</code> 是位左移操作符，它将二进制数向左移动指定的位数，并在右侧填充零。</p><p>HashMap 扩容时，会将当前容量乘以 2，即进行容量的翻倍。这是因为 HashMap 内部使用一个数组来存储元素，扩容时需要重新创建一个更大的数组，并将原数组中的元素重新分配到新数组的对应位置上。</p><p>通过将当前容量左移一位，相当于将当前容量乘以 2。这种操作比起使用乘法运算符 <code>*</code> 来说更加高效，因为位运算通常比算术运算更快。</p><p>举个例子，假设当前容量为 n，那么 <code>n &lt;&lt; 1</code> 的结果就是将 n 的二进制表示向左移动一位，并在右侧填充零。这样就得到了新的容量，即原容量的两倍。</p><p>使用位运算的方式进行扩容，可以通过简单的位移操作来达到容量翻倍的效果，而不需要进行乘法运算，从而提高了性能和效率。</p><p>因此，HashMap 中使用 <code>&lt;&lt;</code> 运算符来进行扩容，是一种高效的方式，可以快速地将当前容量扩大一倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制1001左移一位</span></span><br><span class="line"> <span class="number">10010</span> = <span class="number">01001</span> &lt;&lt; <span class="number">1</span> </span><br><span class="line"><span class="comment">// 对应的的十进制数值为</span></span><br><span class="line"> <span class="number">01001</span> = <span class="number">9</span></span><br><span class="line"> <span class="number">10010</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="HashMap的存储结构转换机制（链表-gt-红黑树）"><a href="#HashMap的存储结构转换机制（链表-gt-红黑树）" class="headerlink" title="HashMap的存储结构转换机制（链表-&gt;红黑树）"></a>HashMap的存储结构转换机制（链表-&gt;红黑树）</h2><p>在 JDK 8 及之后的版本中，HashMap 对于哈希冲突的处理引入了红黑树来替代链表，以提高在桶中查找的效率。下面是链表转换为红黑树的机制：</p><ol><li>当链表中的节点数量超过阈值（默认为 8）时，会进行链表转换为红黑树的操作。</li><li>在进行转换前，HashMap 会先判断当前桶中的元素是否已经符合红黑树的转换条件，即该桶的长度是否大于等于 8（默认值），如果不满足，则不进行转换，仍然维持链表结构。</li><li>如果满足转换条件，在进行链表转换为红黑树之前，会先判断当前 HashMap 的容量是否达到了一个阈值（默认为 64），如果没有达到，则进行扩容，目的是为了提供红黑树所需的更多桶，防止红黑树因为容量不足而发生退化。</li><li>执行链表转换为红黑树的操作，使用红黑树的插入算法将链表中的节点逐个转移到红黑树中，这个过程是一种链表节点的插入操作。</li><li>在转换完成后，原本的链表就会被替换成一棵红黑树，这样就能够通过红黑树的高效查找算法快速定位到对应的元素。</li></ol><p>需要注意的是，在进行红黑树的转换操作后，如果发现红黑树中的节点数量少于某个阈值（默认为 6），此时会将红黑树恢复成链表结构，以节省内存空间并降低维护成本。</p><p>总结起来，HashMap 的存储结构转换机制是通过在链表长度过长时，将链表转换为红黑树来提高查找效率，并在条件满足时进行桶容量的扩容。同时，为了节省内存空间和维护成本，红黑树节点数量过少时会恢复成链表结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看源码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;     <span class="comment">//binCount遍历次数， 当binCount=0时，链表上有一个节点，故可以推出当当binCount=7即当链表上有8个节点时会进行红黑树的转换</span></span><br><span class="line">  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//这行代码表示，会先将新的set值插入到链表中在进行红黑树的转换，而不是先转红黑树在讲新的set值插入到红黑树中，所以说明当链表上有9个节点时才转换成的红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)  <span class="comment">//TREEIFY_THRESHOLD常量值为8，这个判断为当遍历次数为7时就会将链表结构转为红黑树</span></span><br><span class="line">      treeifyBin(tab, hash);   <span class="comment">//链表转为红黑树的具体实现代码</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续补充中。。。"><a href="#后续补充中。。。" class="headerlink" title="后续补充中。。。"></a>后续补充中。。。</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap的扩容机制&quot;&gt;&lt;a href=&quot;#HashMap的扩容机制&quot; class=&quot;headerlink&quot; title=&quot;HashMap的扩容机制&quot;&gt;&lt;/a&gt;HashMap的扩容机制&lt;/h2&gt;&lt;h3 id=&quot;扩容步骤&quot;&gt;&lt;a href=&quot;#扩容步骤&quot; class=&quot;headerlink&quot; title=&quot;扩容步骤&quot;&gt;&lt;/a&gt;扩容步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;扩容条件判断：当 HashMap 中的元素数量超过了负载因子与当前容量的乘积时，就会触发扩容操作。具体判断条件可以参考 &lt;code&gt;threshold&lt;/code&gt; 的计算方式。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)(capacity * loadFactor);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 HashMap 中，&lt;code&gt;threshold&lt;/code&gt; 是用来判断是否需要进行扩容的阈值。&lt;code&gt;threshold&lt;/code&gt; 的计算方式是将当前容量 (&lt;code&gt;capacity&lt;/code&gt;) 乘以负载因子 (&lt;code&gt;loadFactor&lt;/code&gt;)，然后将结果转换为整数。&lt;/p&gt;
&lt;p&gt;负载因子是一个表示 HashMap 元素填充程度的参数，默认情况下是 0.75。当 HashMap 中的元素数量超过了 &lt;code&gt;threshold&lt;/code&gt;，就会触发扩容操作，以保持 HashMap 的性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;threshold&lt;/code&gt; 的计算公式是 &lt;code&gt;threshold = (int)(capacity * loadFactor)&lt;/code&gt;，其中 &lt;code&gt;capacity&lt;/code&gt; 表示当前 HashMap 的容量，&lt;code&gt;loadFactor&lt;/code&gt; 表示负载因子。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;capacity * loadFactor&lt;/code&gt; 的结果是一个浮点数，通过强制类型转换 &lt;code&gt;(int)&lt;/code&gt; 将其转换为整数。强制类型转换会将浮点数的小数部分截断，只取整数部分。这样就得到了一个整数类型的 &lt;code&gt;threshold&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;计算出的 &lt;code&gt;threshold&lt;/code&gt; 值实际上代表了 HashMap 在什么时候需要进行扩容。当 HashMap 中的元素数量达到了 &lt;code&gt;threshold&lt;/code&gt;，即超过了负载因子所允许的填充程度时，就会触发扩容操作。&lt;/p&gt;
&lt;p&gt;通过合理设置负载因子，可以在空间与时间的平衡中进行权衡。较小的负载因子可以减少空间消耗，但可能导致哈希冲突增加；较大的负载因子可以减少哈希冲突，但会增加空间消耗。根据具体的应用场景，可以调整负载因子以达到最佳性能。&lt;/p&gt;
&lt;p&gt;总结起来，&lt;code&gt;threshold = (int)(capacity * loadFactor)&lt;/code&gt; 是根据当前容量和负载因子计算得出的触发 HashMap 扩容的阈值，当元素数量超过该阈值时，HashMap 将进行扩容操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="HashMap" scheme="http://quanluo.github.io/tags/HashMap/"/>
    
      <category term="JDK1.8" scheme="http://quanluo.github.io/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>spring中Bean创建完后打印语句的两种方法（Bean的生命周期）</title>
    <link href="http://quanluo.github.io/2023/06/29/spring%E4%B8%ADBean%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%90%8E%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/06/29/spring%E4%B8%ADBean%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%90%8E%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89/</id>
    <published>2023-06-29T08:44:57.000Z</published>
    <updated>2023-07-05T11:08:16.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Bean的生命周期包括四个阶段：</p><ul><li><p>实例化阶段（Instantiation）：容器通过调用构造函数或者工厂方法来创建Bean的实例。</p></li><li><p>属性赋值阶段（Populate properties）：容器将相应的属性值设置给Bean的实例，可以通过setter方法、直接字段注入或者其他自定义的方式完成属性赋值。</p></li><li><p>初始化阶段（Initialization）：在Bean的属性赋值完成后，容器会调用相关的初始化方法（如果有的话），如实现了InitializingBean接口的afterPropertiesSet()方法，或者通过@Bean注解的initMethod属性指定的方法。开发者可以在初始化方法中进行一些额外的操作，例如数据校验、初始化资源等。</p><a id="more"></a></li><li><p>使用阶段（In use）【补充】：经过初始化阶段后，Bean进入可用状态，可以被容器及其他对象使用。</p></li><li><p>销毁阶段（Destruction）：当Bean不再被使用时，容器可以对其进行销毁操作。这包括调用实现了DisposableBean接口的destroy()方法，或者通过@Bean注解的destroyMethod属性指定的方法。开发者可以在销毁方法中释放资源、关闭连接等。</p></li></ul><h2 id="两种方式在Bean创建完后打印语句（Bean的初始化阶段）"><a href="#两种方式在Bean创建完后打印语句（Bean的初始化阶段）" class="headerlink" title="两种方式在Bean创建完后打印语句（Bean的初始化阶段）"></a>两种方式在Bean创建完后打印语句（Bean的初始化阶段）</h2><h3 id="实现InitializingBean接口："><a href="#实现InitializingBean接口：" class="headerlink" title="实现InitializingBean接口："></a>实现InitializingBean接口：</h3><ul><li><p>创建一个类，实现InitializingBean接口。</p></li><li><p>在该类中实现afterPropertiesSet()方法，在该方法中编写创建Bean后要执行的操作，例如打印语句。</p></li><li><p>当Bean被创建后，容器会自动调用afterPropertiesSet()方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean已创建。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-Bean注解和initMethod属性："><a href="#使用-Bean注解和initMethod属性：" class="headerlink" title="使用@Bean注解和initMethod属性："></a>使用@Bean注解和initMethod属性：</h3><ul><li><p>在Bean对应的配置类中，使用@Bean注解定义Bean的创建方法。</p></li><li><p>在@Bean注解中，使用initMethod属性指定在Bean创建后要调用的初始化方法。</p></li><li><p>在初始化方法中，编写需要执行的操作，例如打印语句。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean已创建。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>无论使用哪种方式，当Bean被创建后，打印语句将会在<strong>初始化阶段</strong>执行。</p><p>具体使用哪种方式都可以，当然根据具体的场景选择适合的方式最好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bean的生命周期&quot;&gt;&lt;a href=&quot;#Bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期&quot;&gt;&lt;/a&gt;Bean的生命周期&lt;/h2&gt;&lt;p&gt;Bean的生命周期包括四个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实例化阶段（Instantiation）：容器通过调用构造函数或者工厂方法来创建Bean的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;属性赋值阶段（Populate properties）：容器将相应的属性值设置给Bean的实例，可以通过setter方法、直接字段注入或者其他自定义的方式完成属性赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化阶段（Initialization）：在Bean的属性赋值完成后，容器会调用相关的初始化方法（如果有的话），如实现了InitializingBean接口的afterPropertiesSet()方法，或者通过@Bean注解的initMethod属性指定的方法。开发者可以在初始化方法中进行一些额外的操作，例如数据校验、初始化资源等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="spring" scheme="http://quanluo.github.io/tags/spring/"/>
    
      <category term="Bean的生命周期" scheme="http://quanluo.github.io/tags/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>解决feign调用时开发环境与正式环境需要增减URL的烦恼</title>
    <link href="http://quanluo.github.io/2023/06/27/%E8%A7%A3%E5%86%B3feign%E8%B0%83%E7%94%A8%E6%97%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E5%A2%9E%E5%87%8FURL%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    <id>http://quanluo.github.io/2023/06/27/%E8%A7%A3%E5%86%B3feign%E8%B0%83%E7%94%A8%E6%97%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E5%A2%9E%E5%87%8FURL%E7%9A%84%E7%83%A6%E6%81%BC/</id>
    <published>2023-06-27T07:52:13.000Z</published>
    <updated>2023-06-27T08:06:00.870Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/f092b72ce6314ea98277aaf28bbb50b4.jpeg#pic_center" alt=""></p><h2 id="项目场景：feign在开发模式的小技巧"><a href="#项目场景：feign在开发模式的小技巧" class="headerlink" title="项目场景：feign在开发模式的小技巧"></a>项目场景：feign在开发模式的小技巧</h2><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>@feignClient指定url才能命中指定的节点,但是正式发布的时候又得删了,很麻烦.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"base"</span>,url = <span class="string">"http://127.0.0.1:9000"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ul><li>把url弄成动态的,并且开发模式才有值,正式环境默认值</li></ul><p>新建一个公共的DevProcessor,把所有需要调用到的微服务ip端口信息弄进去,如果有公共工程的,那就维护好这一份就可以了.<br>实现<strong>BeanPostProcessor</strong>是为了在SpringBoot启动前进行设置<br>利用 <strong>@ConditionalOnProperty</strong> 设置为只在dev模式加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.profiles.active"</span>,havingValue = <span class="string">"dev"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置微服务调试模式下的的ip端口信息</span></span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.base"</span>, <span class="string">"http://127.0.0.1:9000"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.data-compilation"</span>, <span class="string">"http://127.0.0.1:9011"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.data-spider"</span>, <span class="string">"http://127.0.0.1:9106"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.hydro-forecast-short"</span>, <span class="string">"http://127.0.0.1:9004"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.hydrodynamic-waterquality-1d"</span>, <span class="string">"http://127.0.0.1:9006"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.monitor"</span>, <span class="string">"http://127.0.0.1:9103"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.quality-manage"</span>, <span class="string">"http://127.0.0.1:9017"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.reservoir-operation"</span>, <span class="string">"http://127.0.0.1:9015"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.river-lake-health"</span>, <span class="string">"http://127.0.0.1:9016"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.system"</span>, <span class="string">"http://127.0.0.1:9002"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.water-resource-allocation"</span>, <span class="string">"http://127.0.0.1:9009"</span>);</span><br><span class="line">        <span class="comment">// 不注册到nacos上,@FeignClient调用指定了url就不会再从nacos上拉取服务信息走负载均衡了</span></span><br><span class="line">        System.setProperty(<span class="string">"spring.cloud.nacos.discovery.register-enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要用到@FeignClient的地方就可以这么写了,注意属性变量引用最后有一个 : 这个不能少,因为正式环境是不会加载之前的DevProcessor类的. : 的作用是默认值为空字符串和原@FeignClient的url的默认值一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"base"</span>,url = <span class="string">"$&#123;feign.debug.url.system:&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了,以后开发模式就成指定url访问了,正式环境不受影响</p><p>————————————————<br>版权声明：本文为CSDN博主「DonkeyBulala」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_36850300/article/details/125000814" target="_blank" rel="noopener">https://blog.csdn.net/qq_36850300/article/details/125000814</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/f092b72ce6314ea98277aaf28bbb50b4.jpeg#pic_center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目场景：feign在开发模式的小技巧&quot;&gt;&lt;a href=&quot;#项目场景：feign在开发模式的小技巧&quot; class=&quot;headerlink&quot; title=&quot;项目场景：feign在开发模式的小技巧&quot;&gt;&lt;/a&gt;项目场景：feign在开发模式的小技巧&lt;/h2&gt;&lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;@feignClient指定url才能命中指定的节点,但是正式发布的时候又得删了,很麻烦.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FeignClient&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;base&quot;&lt;/span&gt;,url = &lt;span class=&quot;string&quot;&gt;&quot;http://127.0.0.1:9000&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//.....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="Feign" scheme="http://quanluo.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>DO、DTO、BO、VO、POJO等各种O浅学（总结）</title>
    <link href="http://quanluo.github.io/2022/04/12/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%AD%89%E5%90%84%E7%A7%8DO%E6%B5%85%E5%AD%A6%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>http://quanluo.github.io/2022/04/12/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%AD%89%E5%90%84%E7%A7%8DO%E6%B5%85%E5%AD%A6%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/</id>
    <published>2022-04-12T07:08:03.000Z</published>
    <updated>2022-04-12T07:28:03.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/c8dc950ea9064495b2f9a18e4b75adce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p><h2 id="有哪些-O"><a href="#有哪些-O" class="headerlink" title="有哪些 O"></a>有哪些 O</h2><ul><li><p>DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</p></li><li><p>PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象</p></li><li><p>DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</p> <a id="more"></a></li><li><p>BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。</p></li><li><p>AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</p></li><li><p>VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</p></li><li><p>POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。</p></li><li><p>DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体<br>　<img src="https://img-blog.csdnimg.cn/3b7d7f6507594e709a9d8c451c54f07b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>　　阿里Java开发手册分层领域模型：<br>　　<img src="https://img-blog.csdnimg.cn/75f382b920d64cc59fd8282abcfaf7b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h2 id="关键的-O-：DO、DTO、VO、BO"><a href="#关键的-O-：DO、DTO、VO、BO" class="headerlink" title="关键的 O ：DO、DTO、VO、BO"></a>关键的 O ：DO、DTO、VO、BO</h2><ul><li><p>VO (View Object)，用于表示一个与前端进行交互的视图对象，它的作用是把某个指定页面(或组件)的所有数据封装起来。实际上，这里的 VO 只包含前端需要展示的数据，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。</p></li><li><p>DTO(Data Transfer Object)，用于表示一个数据传输对象，DTO 通常用于展示层(Controller)和服务层(Service)之间的数据传输对象。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。</p></li><li><p>DO(Data Object) ，持久化对象，它跟持久层(Dao)的数据结构形成一一对应的映射关系。如果持久层是关系型数据库，那么数据库表中的每个字段就对应PO的一个属性，常是entity实体类。</p></li><li><p>BO（Business Object）：业务对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><h2 id="整个数据流程传递"><a href="#整个数据流程传递" class="headerlink" title="整个数据流程传递"></a>整个数据流程传递</h2><p>一般的数据传递是，前端传递VO给接口(Controller)，接口将VO转为DTO传递给service，service将DTO分解为DO，调用领域服务进行调度，然后逆向转为VO或者其他的返回结果，传递给前台。</p></li></ul><h2 id="区别用处"><a href="#区别用处" class="headerlink" title="区别用处"></a>区别用处</h2><h3 id="VO与DTO的区别"><a href="#VO与DTO的区别" class="headerlink" title="VO与DTO的区别"></a>VO与DTO的区别</h3><p>　　大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举。但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。</p><p>　　用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。</p><p>　　理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。</p><h3 id="VO与DTO的应用"><a href="#VO与DTO的应用" class="headerlink" title="VO与DTO的应用"></a>VO与DTO的应用</h3><p>　　上面只是用了一个简单的例子来说明VO与DTO在概念上的区别，本节将会告诉你如何在应用中做出正确的选择。</p><p>　　在以下才场景中，我们可以考虑把VO与DTO二合为一（注意：是实现层面）：</p><p>当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，你很容易理解，DTO对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如JavaScript）或其他机制（JSTL、EL、CSS）。<br>即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让VO退隐。<br>　　以下场景需要优先考虑VO、DTO并存：</p><p>上述场景的反面场景<br>因为某种技术原因，比如某个框架（如Flex）提供自动把POJO转换为UI中某些Field时，可以考虑在实现层面定义出VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个VO所多做的事情带来的开发和维护效率的下降之间的比对。<br>如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个DTO来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的DTO来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。</p><h3 id="DTO与DO的区别"><a href="#DTO与DO的区别" class="headerlink" title="DTO与DO的区别"></a>DTO与DO的区别</h3><p>　　首先是概念上的区别，DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User（对于DTO和DO的命名规则，请参见笔者前面的一篇博文），对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，正如第一篇系列文章所说，DO不是简单的POJO，它具有领域业务逻辑。</p><h3 id="DTO与DO的应用"><a href="#DTO与DO的应用" class="headerlink" title="DTO与DO的应用"></a>DTO与DO的应用</h3><p>　　从上一节的例子中，细心的读者可能会发现问题：既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。</p><p>　　对于DO来说，还有一点需要说明：为什么不在服务层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下：</p><p>两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。<br>DO具有一些不应该让展示层知道的数据<br>DO具有业务方法，如果直接把DO传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于AOP拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用DO的业务方法也会因为事务的问题，让事务难以控制。<br>对于某些ORM框架（如Hibernate）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。<br>从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把DO暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。<br>　　对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”，举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”。笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。</p><h3 id="DO与PO的区别"><a href="#DO与PO的区别" class="headerlink" title="DO与PO的区别"></a>DO与PO的区别</h3><p>　　DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：</p><p>DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。<br>同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个PO之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个DO——“权限”。<br>某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。例如客户Customer有其联系信息Contacts，这里是两个一对一关系的DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把Customer和Contacts两个DO数据合并到一张数据表中。反过来，如果一本图书Book，有一个属性是封面cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把cover一并加载，从而减轻磁盘IO开销，同时假设ORM框架不支持属性级别的延迟加载，那么就需要考虑把cover独立到一张数据表中去，这样就形成一个DO对应多个PO的情况。<br>PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。</p><h3 id="DO与PO的应用"><a href="#DO与PO的应用" class="headerlink" title="DO与PO的应用"></a>DO与PO的应用</h3><p>　　由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：</p><p>对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在JPA中，可以利用@Transient声明。<br>对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get/set方法私有化，甚至不提供get/set方法。但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。<br>对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持，请参考Hibnate的相关资料。</p><h2 id="领域模型命名规约："><a href="#领域模型命名规约：" class="headerlink" title="领域模型命名规约："></a>领域模型命名规约：</h2><ul><li><p>数据对象：xxxDO，xxx 即为数据表名。</p></li><li><p>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p></li><li><p>展示对象：xxxVO，xxx 一般为网页名称。</p></li><li><p>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c8dc950ea9064495b2f9a18e4b75adce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;有哪些-O&quot;&gt;&lt;a href=&quot;#有哪些-O&quot; class=&quot;headerlink&quot; title=&quot;有哪些 O&quot;&gt;&lt;/a&gt;有哪些 O&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="分层模型规范" scheme="http://quanluo.github.io/tags/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>（力扣）5. 最长回文子串 C++（中心扩散法）解题击败100%用户</title>
    <link href="http://quanluo.github.io/2021/09/17/%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%895-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-C-%EF%BC%88%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95%EF%BC%89%E8%A7%A3%E9%A2%98%E5%87%BB%E8%B4%A5100-%E7%94%A8%E6%88%B7/"/>
    <id>http://quanluo.github.io/2021/09/17/%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%895-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-C-%EF%BC%88%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95%EF%BC%89%E8%A7%A3%E9%A2%98%E5%87%BB%E8%B4%A5100-%E7%94%A8%E6%88%B7/</id>
    <published>2021-09-17T11:08:49.000Z</published>
    <updated>2021-09-17T11:11:07.116Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/3c0c1e12abc9404f9542b7a25ac77f11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><a id="more"></a><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"babad"</span></span><br><span class="line">输出：<span class="string">"bab"</span></span><br><span class="line">解释：<span class="string">"aba"</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cbbd"</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：<span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>我们是以每一个字符为中心，往两边扩散，来求最长的回文子串。</p><p>我们来思考这样一个问题，如果是单个字符，我们可以认为他是回文子串，如果是多个字符，并且他们都是相同的，那么他们也是回文串。所以对于上面的问题，我们以当前字符为中心往两边扩散的时候，先要判断和他挨着的有没有相同的字符，如果有，则跳过继续判断下一个，<br>根据这个思路，我们来写下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取字符串s的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = s.size(); </span><br><span class="line">        <span class="comment">// 设置回文子串起始位置和字串长度的初始值</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; )&#123;</span><br><span class="line">            <span class="comment">// 判断剩余字串长度小于当前回文字串的长度，则直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(length - i &lt; maxlen / <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="comment">// 过滤掉重复的字符</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; length - <span class="number">1</span> &amp;&amp; s[right + <span class="number">1</span>] == s[right])&#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下次循环是直接从重复的下一个位置开始判断</span></span><br><span class="line">            i = right + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 往两边开始扩散，求回文字串长度</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; length <span class="number">-1</span> &amp;&amp; left &gt; <span class="number">0</span> &amp;&amp; s[left - <span class="number">1</span>] == s[right + <span class="number">1</span>])&#123;</span><br><span class="line">                --left;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求出最长回文字串长度和起始位置</span></span><br><span class="line">            <span class="keyword">if</span>(right - left + <span class="number">1</span> &gt; maxlen)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                maxlen = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长回文字串</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/3c0c1e12abc9404f9542b7a25ac77f11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://quanluo.github.io/tags/C/"/>
    
      <category term="算法" scheme="http://quanluo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣" scheme="http://quanluo.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac安装Adobe软件的时候，总是提示安装包（软件）“可能损坏了”的问题</title>
    <link href="http://quanluo.github.io/2021/09/09/%E8%A7%A3%E5%86%B3Mac%E5%AE%89%E8%A3%85Adobe%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%BB%E6%98%AF%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E2%80%9C%E5%8F%AF%E8%83%BD%E6%8D%9F%E5%9D%8F%E4%BA%86%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://quanluo.github.io/2021/09/09/%E8%A7%A3%E5%86%B3Mac%E5%AE%89%E8%A3%85Adobe%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%BB%E6%98%AF%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E2%80%9C%E5%8F%AF%E8%83%BD%E6%8D%9F%E5%9D%8F%E4%BA%86%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-09T03:00:15.000Z</published>
    <updated>2021-09-09T03:02:17.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题："><a href="#Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：" class="headerlink" title="Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题："></a>Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：</h3><p><img src="https://img-blog.csdnimg.cn/9d9a48d9d237460385a9aca3de2df473.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><a id="more"></a><p>一直提示<strong>Error The installation cannot continue as the installer file may be damaged. Download the installer file again.</strong></p><p>这是怎么回事呢？<br>首先先看一下中文翻译是什么：<br>错误：</p><p><strong>安装不能继续了，因为安装包（软件）可能损坏了。请重新下载安装包。</strong></p><p>看意思是安装包损坏了，需要重新下载安装，但是，如果你去这么做了，那么你会发现还是会出现这个错误。<br>因此，报着个错误，并不一定真的是安装包损坏了，你<strong>并不需要重新下载安装包的。</strong><br><strong>那他的解决办法是什么呢？</strong><br>请看下面：<br>其实这个问题，我们在安装adobe软件的时候都会遇到。这里呢，我们就以PS为例吧。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="1-首先，我们打开安装包："><a href="#1-首先，我们打开安装包：" class="headerlink" title="1.首先，我们打开安装包："></a>1.首先，我们打开安装包：</h4><p><img src="https://img-blog.csdnimg.cn/8c5cb608be9c453fba9f4d4b717027b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="2-然后，我们找到install-app这个文件，右键-显示包内容"><a href="#2-然后，我们找到install-app这个文件，右键-显示包内容" class="headerlink" title="2.然后，我们找到install.app这个文件，右键-显示包内容"></a>2.然后，我们找到install.app这个文件，右键-显示包内容</h4><p><img src="https://img-blog.csdnimg.cn/d9cec462a69c4928863ca7789e1a0219.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="3-点击Contants，进入文件夹里"><a href="#3-点击Contants，进入文件夹里" class="headerlink" title="3.点击Contants，进入文件夹里"></a>3.点击Contants，进入文件夹里<img src="https://img-blog.csdnimg.cn/0b9455d75feb455f8df9e5f9b4c8fbfd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></h4><h4 id="4-点击MacOS文件，进入文件夹里"><a href="#4-点击MacOS文件，进入文件夹里" class="headerlink" title="4. 点击MacOS文件，进入文件夹里"></a>4. 点击MacOS文件，进入文件夹里</h4><p><img src="https://img-blog.csdnimg.cn/20552d74e9c24e87a8ce56bde9aba192.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="5-最后，点击Install，好了，现在可以正常安装了。"><a href="#5-最后，点击Install，好了，现在可以正常安装了。" class="headerlink" title="5.最后，点击Install，好了，现在可以正常安装了。"></a>5.最后，点击Install，好了，现在可以正常安装了。</h4><p><img src="https://img-blog.csdnimg.cn/2d2b258b515b4132ac46df19dc3efe1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="以上，解决问题。"><a href="#以上，解决问题。" class="headerlink" title="以上，解决问题。"></a>以上，解决问题。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&quot;&gt;&lt;a href=&quot;#Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&quot; class=&quot;headerlink&quot; title=&quot;Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&quot;&gt;&lt;/a&gt;Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/9d9a48d9d237460385a9aca3de2df473.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="Adobe" scheme="http://quanluo.github.io/tags/Adobe/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+yilia+Github实现相册功能（超详细）</title>
    <link href="http://quanluo.github.io/2021/09/09/Hexo-yilia-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"/>
    <id>http://quanluo.github.io/2021/09/09/Hexo-yilia-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/</id>
    <published>2021-09-08T16:28:25.000Z</published>
    <updated>2021-09-08T16:37:07.338Z</updated>
    
    <content type="html"><![CDATA[<ul><li>效果图：<br><img src="https://img-blog.csdnimg.cn/25b825b4e1884dffbe5ce9aba71e8485.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>最终效果请看这里：<a href="https://quanluo.github.io/">quanluo.github.io</a></li></ul><h3 id="一、目的："><a href="#一、目的：" class="headerlink" title="一、目的："></a>一、目的：</h3><ul><li>为博客添加相册功能</li><li>通过GitHub来实现相册功能</li></ul><a id="more"></a> <h3 id="二、方案"><a href="#二、方案" class="headerlink" title="二、方案"></a>二、方案</h3><ol><li>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理</li><li>将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出</li><li>修改代码（大佬写好的）</li><li>使用py脚本压缩图片生成略缩图<h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h3><h4 id="1-博客页面添加相册"><a href="#1-博客页面添加相册" class="headerlink" title="1.博客页面添加相册"></a>1.博客页面添加相册</h4></li></ol><ul><li>通过cmd/终端进入你的博客blog的source目录下，通过 ==hexo new page “photos”== 命令创建<strong>photos</strong>文件夹，代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd blog</span><br><span class="line">&gt; cd source</span><br><span class="line">&gt; hexo new page <span class="string">"photos"</span></span><br></pre></td></tr></table></figure><h4 id="2-GitHub操作"><a href="#2-GitHub操作" class="headerlink" title="2.GitHub操作"></a>2.GitHub操作</h4></li><li>建立一个用于存储相册的仓库，我这里建立了名为<strong>Blog-Picture</strong>的仓库<br><img src="https://img-blog.csdnimg.cn/d87454ddfa334fe9991eafce2f0748e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>在创建完远端仓库后，将本地与github上远端仓库关联，这样我们以后才能够将图片推送到远端。<br>远端仓库与本地仓库关联的方法:<br>打开博客文件夹，在此根目录下，使用git ,即 git Bush Here,然后输入:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone git@github.com:quanluo/Blog-Picture.git</span><br></pre></td></tr></table></figure></li><li>其中<strong>clone</strong>的仓库换成自己的仓库地址。这样便能使本地与远端关联起立。此刻，会产生一个<code>Blog-Picture</code>的文件夹，在此文件夹下分别创建<code>min_photos</code>、<code>photos</code>文件夹。<br><img src="https://img-blog.csdnimg.cn/a523127e113c4d39a56744b371e835d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="3-修改代码"><a href="#3-修改代码" class="headerlink" title="3.修改代码"></a>3.修改代码</h4></li><li>在GitHub上下载代码：<a href="https://github.com/lawlite19/Blog-Back-Up/tree/master/blog_photos_copy" target="_blank" rel="noopener">源代码</a><br><img src="https://img-blog.csdnimg.cn/7a69e4a79ade46aaa38866327d199d33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>删除其中的<code>data.json</code>文件。因为，后面的<code>.json</code>文件是我们自己博客在上传图片时生成的.</li><li>修改index.ejs。这一步很重要，我自己查百度和相关博文时，都没有提到这一步。将其中的href修改成自己的博客地址。当初我就没有修改，最终，显示出来的永远都是原作者的相册.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &lt;div class="instagram itemscope"&gt;</span><br><span class="line">    &lt;a href="https://quanluo.github.io/" target="_blank" class="open-ins"&gt;图片正在加载中…&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>修改ins.js文件里的render()函数，按照上面的注释提醒，进行修改。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 修改这里render()函数：修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径)</span><br><span class="line">    // https://raw.githubusercontent.com/quanluo/Blog-Picture/master/min_photos/</span><br><span class="line">    //https://raw.githubusercontent.com/quanluo/Blog-Picture/master/photos/</span><br><span class="line">    var render = function render(res) &#123;</span><br><span class="line">      var ulTmpl = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">for</span> (var j = <span class="number">0</span>, len2 = res.list.length; j &lt; len2; j++) &#123;</span><br><span class="line">        var data = res.list[j].arr;</span><br><span class="line">        var liTmpl = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>, len = data.link.length; i &lt; len; i++) &#123;</span><br><span class="line">          var minSrc = <span class="string">'https://raw.githubusercontent.com/quanluo/Blog-Picture/master/min_photos/'</span> + data.link[i];</span><br><span class="line">          var src = <span class="string">'https://raw.githubusercontent.com/quanluo/Blog-Picture/master/photos/'</span> + data.link[i];</span><br><span class="line">          var type = data.type[i];</span><br><span class="line">          var target = src + (type === 'video' ? '.mp4' : '.jpg');</span><br><span class="line">          src += <span class="string">''</span>;</span><br></pre></td></tr></table></figure><h6 id="注意-第一个容易出错的地方-："><a href="#注意-第一个容易出错的地方-：" class="headerlink" title="注意(第一个容易出错的地方)："></a><font color=red>注意(第一个容易出错的地方)：</font></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var minSrc = <span class="string">'https://raw.githubusercontent.com/lawlite19/blog-back-up/master/min_photos/'</span> + data.link[i]; </span><br><span class="line">var src = <span class="string">'https://raw.githubusercontent.com/lawlite19/blog-back-up/master/photos/'</span> + data.link[i];</span><br></pre></td></tr></table></figure><p>这个链接很多人输入错了，不是直接的图片url，是需要点“下载”才能看到的url。<br><img src="https://img-blog.csdnimg.cn/f179315748604e0da0f137396f4a4caf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/657298f08cec420ea49713a538f090de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="4-添加脚本"><a href="#4-添加脚本" class="headerlink" title="4. 添加脚本"></a>4. 添加脚本</h4><ul><li>这里添加的python脚本主要是用于处理图片。脚本下载-  <a href="https://github.com/ChemLez/blog-Picture" target="_blank" rel="noopener">下载地址</a>.</li><li><ul><li>1.将其中的.py文件拷贝至本地仓库<strong>Blog-Picture</strong>文件夹中.</li></ul></li><li><ul><li>2.根据脚本文件，图片的命名规则为：xxxx-xx-xx_name.jpg/png.<br><font color=red>注意：你要保存的和上传的图片放的地址在<strong>Blog-Picture</strong>文件夹下<strong>photos</strong>文件夹里</font><br><img src="https://img-blog.csdnimg.cn/090a9237d91b45219078b5ca20c3f394.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/c9a7d98cae4647a5ab11ba68bc68cffe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> – 3.将图片<a href="https://raw.githubusercontent.com/quanluo/quanluo.github.io/master/assets/img/empty.png" target="_blank" rel="noopener">empty.png</a>下载放入博客目录下的assets/img文件夹中.</p><h5 id="注意-第二个错误地方-重点-：如果没有这一步可能缩略图显示不出来"><a href="#注意-第二个错误地方-重点-：如果没有这一步可能缩略图显示不出来" class="headerlink" title="注意(第二个错误地方-重点)：如果没有这一步可能缩略图显示不出来"></a><font color=red>注意(第二个错误地方-重点)：如果没有这一步可能缩略图显示不出来</font></h5><p>首先，去下载“empty.png” ,直接右键另存，保存为“empty.png”。名字也要一样，别问为什么，实现了，自己再去看源码。<br>在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。我的结果如下：<br>    <img src="https://img-blog.csdnimg.cn/1a0d219e44394b1c9ee01e72cd0274dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>– 4.打开tool.py文件,修改def handle_photo():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"../lawlite19.github.io/source/photos/data.json"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(final_dict, fp)</span><br></pre></td></tr></table></figure><p>将其中的的地址，换成你将要生成data.json的位置，就是在第一步中，我们删除的.json文件夹的目录地址。每次，进行tool.py脚本时，都会产生data.json文件，用于存储我们图片的信息。</p><h4 id="5-运行脚本"><a href="#5-运行脚本" class="headerlink" title="5.运行脚本"></a>5.运行脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&gt; cd Blog-Picture <span class="comment">#用于进入Blog-Picture文件夹</span></span><br><span class="line">&gt; python tool.py <span class="comment">#python脚本文件的运行</span></span><br><span class="line">&gt; </span><br><span class="line"><span class="comment"># 第二句的运行这里可能会报错 `no module named PIL`</span></span><br><span class="line"><span class="comment">#如果报错然输入下面代码：</span></span><br><span class="line">pip install pillow</span><br><span class="line"><span class="comment">#可能出现权限不足的情况，按照下方出现的英文，加上权限进行下载。即：一路按照下方的英文,加权限进行下载.</span></span><br></pre></td></tr></table></figure><h5 id="注意：每次上传照片都需要运行python脚本"><a href="#注意：每次上传照片都需要运行python脚本" class="headerlink" title="注意：每次上传照片都需要运行python脚本"></a><font color=red>注意：每次上传照片都需要运行python脚本</font></h5><p>需要安装python环境，在命令行运行py tool.py命令。</p><h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h4><ul><li>在blog根目录下，输入代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hexo s</span><br></pre></td></tr></table></figure><ul><li>进行预览查看。<br><img src="https://img-blog.csdnimg.cn/168fb7640901418387e03651a40004d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>测试成功，进行blog远端部署：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hexo clean <span class="comment">#清除页面缓存</span></span><br><span class="line">&gt; hexo g -d <span class="comment"># 进行远端部署</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="OK！！！完美！！！大功告成！！！"><a href="#OK！！！完美！！！大功告成！！！" class="headerlink" title="OK！！！完美！！！大功告成！！！"></a>OK！！！完美！！！大功告成！！！</h3>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;效果图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/25b825b4e1884dffbe5ce9aba71e8485.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/li&gt;
&lt;li&gt;最终效果请看这里：&lt;a href=&quot;https://quanluo.github.io/&quot;&gt;quanluo.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;一、目的：&quot;&gt;&lt;a href=&quot;#一、目的：&quot; class=&quot;headerlink&quot; title=&quot;一、目的：&quot;&gt;&lt;/a&gt;一、目的：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为博客添加相册功能&lt;/li&gt;
&lt;li&gt;通过GitHub来实现相册功能&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://quanluo.github.io/tags/hexo/"/>
    
      <category term="yilia" scheme="http://quanluo.github.io/tags/yilia/"/>
    
      <category term="相册" scheme="http://quanluo.github.io/tags/%E7%9B%B8%E5%86%8C/"/>
    
      <category term="github" scheme="http://quanluo.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>ModuleNotFoundError: No module named ‘sklearn.cross_validation‘解决办法</title>
    <link href="http://quanluo.github.io/2021/09/07/ModuleNotFoundError-No-module-named-%E2%80%98sklearn-cross-validation%E2%80%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://quanluo.github.io/2021/09/07/ModuleNotFoundError-No-module-named-%E2%80%98sklearn-cross-validation%E2%80%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-09-07T04:15:52.000Z</published>
    <updated>2021-09-08T05:13:05.375Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/c79eab1ebf3b47b1882ab5b3f18fb6b1.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>在Python机器学习中，会用到使用<font color=red> <strong>scikit-learn</strong> </font>中的<font color=red><strong>train_test_split</strong></font>函数，把数据集切分为训练集和测试集。</p><a id="more"></a> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><p>用后发现会报错==ModuleNotFoundError==<br><img src="https://img-blog.csdnimg.cn/151d1d7378894840bd50590e48bfa38b.png" alt="在这里插入图片描述"></p><h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p> <strong>这个cross_validatio这个包早就不在使用了，划分到了model_selection这个包中。</strong></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>使用下方导入模块代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c79eab1ebf3b47b1882ab5b3f18fb6b1.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Python机器学习中，会用到使用&lt;font color=red&gt; &lt;strong&gt;scikit-learn&lt;/strong&gt; &lt;/font&gt;中的&lt;font color=red&gt;&lt;strong&gt;train_test_split&lt;/strong&gt;&lt;/font&gt;函数，把数据集切分为训练集和测试集。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://quanluo.github.io/tags/Python/"/>
    
      <category term="sklearn" scheme="http://quanluo.github.io/tags/sklearn/"/>
    
      <category term="机器学习" scheme="http://quanluo.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MacOS下安装R语言和RStudio教程（超完整）</title>
    <link href="http://quanluo.github.io/2021/08/30/MacOS%E4%B8%8B%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8CRStudio%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E5%AE%8C%E6%95%B4%EF%BC%89/"/>
    <id>http://quanluo.github.io/2021/08/30/MacOS%E4%B8%8B%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8CRStudio%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E5%AE%8C%E6%95%B4%EF%BC%89/</id>
    <published>2021-08-30T03:44:15.000Z</published>
    <updated>2021-08-30T03:55:59.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前提"><a href="#一、前提" class="headerlink" title="一、前提"></a>一、前提</h1><p>安装顺序（不能颠倒）：<br>1、R语言<br>2、RStudio<br>注：R是RStudio的基础，必须先安装R，在安装RStudio。<br><img src="https://img-blog.csdnimg.cn/f6a19ca8c1244f4e9d1ea31d5027443b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><h1 id="二、R语言安装"><a href="#二、R语言安装" class="headerlink" title="二、R语言安装"></a>二、R语言安装</h1><p>1.官网安装包下载地址：<a href="https://cran.r-project.org/" target="_blank" rel="noopener">https://cran.r-project.org/</a>.<br>2.点击MacOS对应选项，下方红框标出的地方<br><img src="https://img-blog.csdnimg.cn/184e5e7ea2e042c6913d4bbadfba31d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.在下载界面，点击base，下方红框标出的地方<br><img src="https://img-blog.csdnimg.cn/8a0adb83c1744309bbd5e15414f787c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>4.自行选择下载R语言版本，我下载的是（R-4.0.4.pkg版本的）<br><img src="https://img-blog.csdnimg.cn/ab288d691d594474a3a1fa80c4b47c0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>5.下载完成，在“Finder-&gt;下载”中点击pkg文件，一直按下一步就可安装完成。</p><h1 id="三、RStudio安装"><a href="#三、RStudio安装" class="headerlink" title="三、RStudio安装"></a>三、RStudio安装</h1><p>1.官网安装包下载地址：<a href="https://www.rstudio.com/products/rstudio/download/#download" target="_blank" rel="noopener">https://www.rstudio.com/products/rstudio/download/#download</a><br>2.点击下方红色标出地方，直接下载<br><img src="https://img-blog.csdnimg.cn/d7d3b4c2256147f4a641fd96c6003857.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3. 下载完成，在“Finder-&gt;下载”中点击dmg文件，将app拖入mac的application中即可。</p><h1 id="到此，安装全部完成。"><a href="#到此，安装全部完成。" class="headerlink" title="到此，安装全部完成。"></a>到此，安装全部完成。</h1><h1 id="四、可能会遇到的问题："><a href="#四、可能会遇到的问题：" class="headerlink" title="四、可能会遇到的问题："></a>四、可能会遇到的问题：</h1><h2 id="关于macOS：在Mac上安装R-警告消息：使用“-C”设置LC-CTYPE失败"><a href="#关于macOS：在Mac上安装R-警告消息：使用“-C”设置LC-CTYPE失败" class="headerlink" title="关于macOS：在Mac上安装R-警告消息：使用“ C”设置LC_CTYPE失败"></a>关于macOS：在Mac上安装R-警告消息：使用“ C”设置LC_CTYPE失败</h2><blockquote><p>Installing R on Mac - Warning messages: Setting LC_CTYPE failed, using “C”</p></blockquote><h3 id="错误是："><a href="#错误是：" class="headerlink" title="错误是："></a>错误是：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">During startup - Warning messages:</span><br><span class="line">1: Setting LC_CTYPE failed, using&quot;C&quot;</span><br><span class="line">2: Setting LC_COLLATE failed, using&quot;C&quot;</span><br><span class="line">3: Setting LC_TIME failed, using&quot;C&quot;</span><br><span class="line">4: Setting LC_MESSAGES failed, using&quot;C&quot;</span><br><span class="line">5: Setting LC_PAPER failed, using&quot;C&quot;</span><br><span class="line">[R.app GUI 1.50 (6126) x86_64-apple-darwin9.8.0]</span><br><span class="line"></span><br><span class="line">WARNING: You&#39;re using a non-UTF8 locale, therefore only ASCII characters will work.</span><br><span class="line">Please read R for Mac OS X FAQ (see Help) section 9 and adjust your system preferences accordingly.</span><br><span class="line">[History restored from &#x2F;Users&#x2F;nemo&#x2F;.Rapp.history]</span><br></pre></td></tr></table></figure><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ul><li>开放终端</li><li>写入或粘贴：defaults write org.R-project.R force.LANG en_US.UTF-8</li><li>关闭终端(包括任何RStudio窗口)</li><li>开始R</li></ul><h1 id="五、在RStudio中创建新项目"><a href="#五、在RStudio中创建新项目" class="headerlink" title="五、在RStudio中创建新项目"></a>五、在RStudio中创建新项目</h1><p>1.创建新project。具体方法如下图所示，依次点击 File-&gt;New Project =&gt; New Directory-&gt;New Project-&gt;输入Derectory name（注意要用英文，别用中文）<br><img src="https://img-blog.csdnimg.cn/8e37f9bedb7145009422922d93d362a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/8b8dd43882844a2b8e66c1c61cc5bbd0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/244d2cf481014cb98e54763fe145e4de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/087a5ec9eef44f029e5412b19694edc3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.创建好，就会出现如下界面<br><img src="https://img-blog.csdnimg.cn/8464b7605c364747bf6564860a1856b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="六、测试R"><a href="#六、测试R" class="headerlink" title="六、测试R"></a>六、测试R</h1><p>1.在《R语言实战》中有一个新手测试代码，我们可以测试下我们安装的R语言环境</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; age &lt;- c(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>)</span><br><span class="line">&gt; weight &lt;- c(<span class="number">4.4</span>, <span class="number">5.3</span>, <span class="number">7.2</span>, <span class="number">5.2</span>, <span class="number">8.5</span>, <span class="number">7.3</span>, <span class="number">6.0</span>, <span class="number">10.4</span>, <span class="number">10.2</span>, <span class="number">6.1</span>)</span><br><span class="line">&gt; mean(weight)</span><br><span class="line">&gt; sd(weight)</span><br><span class="line">&gt; cor(age, weight)</span><br><span class="line">&gt; plot(age, weight)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e9e2eb9d673e4c879fd3f3b454402d2d.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>2.测试结果：<br><img src="https://img-blog.csdnimg.cn/298c01ce858b464fa4f6544f51a65914.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前提&quot;&gt;&lt;a href=&quot;#一、前提&quot; class=&quot;headerlink&quot; title=&quot;一、前提&quot;&gt;&lt;/a&gt;一、前提&lt;/h1&gt;&lt;p&gt;安装顺序（不能颠倒）：&lt;br&gt;1、R语言&lt;br&gt;2、RStudio&lt;br&gt;注：R是RStudio的基础，必须先安装R，在安装RStudio。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/f6a19ca8c1244f4e9d1ea31d5027443b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="R语言" scheme="http://quanluo.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="RStudio" scheme="http://quanluo.github.io/tags/RStudio/"/>
    
  </entry>
  
  <entry>
    <title>我的个人博客live2d插件模型模块汇总（仅本人可使用，无需看）</title>
    <link href="http://quanluo.github.io/2021/08/25/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2live2d%E6%8F%92%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9D%97%E6%B1%87%E6%80%BB%EF%BC%88%E4%BB%85%E6%9C%AC%E4%BA%BA%E5%8F%AF%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%97%A0%E9%9C%80%E7%9C%8B%EF%BC%89/"/>
    <id>http://quanluo.github.io/2021/08/25/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2live2d%E6%8F%92%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9D%97%E6%B1%87%E6%80%BB%EF%BC%88%E4%BB%85%E6%9C%AC%E4%BA%BA%E5%8F%AF%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%97%A0%E9%9C%80%E7%9C%8B%EF%BC%89/</id>
    <published>2021-08-25T14:42:22.000Z</published>
    <updated>2021-08-25T14:43:46.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。"><a href="#这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。" class="headerlink" title="这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。"></a>这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。</h3><h3 id="所以看到这的可以退出这篇文章了！！！"><a href="#所以看到这的可以退出这篇文章了！！！" class="headerlink" title="所以看到这的可以退出这篇文章了！！！"></a>所以看到这的可以退出这篇文章了！！！</h3><blockquote><p>shizuku</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c29020544f7f4cd08023f69fc834bcd2.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><a id="more"></a><blockquote><p>nipsilon</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8483bf76d01a4fd3bdc3d2e5043cce03.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>nito</p></blockquote><p><img src="https://img-blog.csdnimg.cn/daf2b153d42442f5b875cedfb3979b3b.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>nico</p></blockquote><p><img src="https://img-blog.csdnimg.cn/9c23817f960f478d953938c5e8e07f0c.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>ni-j</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1b50575a90ee423d8e1357089d76ce3e.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>haru</p></blockquote><p><img src="https://img-blog.csdnimg.cn/5aa52c5b2a1347c9b67777aa7749049f.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>haruto</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3e437aec659247078867860c443627e1.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>tsumiki</p></blockquote><p><img src="https://img-blog.csdnimg.cn/32186439fd544f55b50d8060067a3b4d.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>z16</p></blockquote><p><img src="https://img-blog.csdnimg.cn/db6c72d556e049bb9dca9623f2bae64e.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>tororo</p></blockquote><p><img src="https://img-blog.csdnimg.cn/baec5fada2f14ac281c0d88f14210309.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>koharu</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6c084a0b36974d81b5b11853e4631960.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>hijiki</p></blockquote><p><img src="https://img-blog.csdnimg.cn/08d4712b26404f329dfcdd7c880aae63.gif#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&quot;&gt;&lt;a href=&quot;#这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&quot; class=&quot;headerlink&quot; title=&quot;这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&quot;&gt;&lt;/a&gt;这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&lt;/h3&gt;&lt;h3 id=&quot;所以看到这的可以退出这篇文章了！！！&quot;&gt;&lt;a href=&quot;#所以看到这的可以退出这篇文章了！！！&quot; class=&quot;headerlink&quot; title=&quot;所以看到这的可以退出这篇文章了！！！&quot;&gt;&lt;/a&gt;所以看到这的可以退出这篇文章了！！！&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;shizuku&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c29020544f7f4cd08023f69fc834bcd2.gif#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;   ————————&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;*****&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;————————&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://quanluo.github.io/tags/hexo/"/>
    
      <category term="live2d" scheme="http://quanluo.github.io/tags/live2d/"/>
    
  </entry>
  
  <entry>
    <title>mac下 Github添加SSH keys</title>
    <link href="http://quanluo.github.io/2021/08/16/mac%E4%B8%8B-Github%E6%B7%BB%E5%8A%A0SSH-keys/"/>
    <id>http://quanluo.github.io/2021/08/16/mac%E4%B8%8B-Github%E6%B7%BB%E5%8A%A0SSH-keys/</id>
    <published>2021-08-16T14:17:18.000Z</published>
    <updated>2021-08-19T10:36:55.598Z</updated>
    
    <content type="html"><![CDATA[<p>注：封面背景在文章最后面。</p><h2 id="一、首先测试下是否有原先有添加过公钥"><a href="#一、首先测试下是否有原先有添加过公钥" class="headerlink" title="一、首先测试下是否有原先有添加过公钥"></a>一、首先测试下是否有原先有添加过公钥</h2><p>我们用下面的代码在终端去测试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5071fdab2b8b40b59d2da538dcefca61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上，如果显示，==Permission denied(publickey)==  这就表示缺少公钥。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/7a1f4c19940b4d20b37c35908fa8b752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上，如果显示 ==You’ve successfully authenticated== 这就表明公钥添加成功了。</p><h2 id="二、进入正题，没有SSH-keys-公钥，请看下方详细mac下-Github添加SSH-keys步骤"><a href="#二、进入正题，没有SSH-keys-公钥，请看下方详细mac下-Github添加SSH-keys步骤" class="headerlink" title="二、进入正题，没有SSH keys 公钥，请看下方详细mac下 Github添加SSH keys步骤:"></a>二、进入正题，没有SSH keys 公钥，请看下方详细<code>mac下 Github添加SSH keys</code>步骤:</h2><h3 id="1-在本地创建SSH-keys"><a href="#1-在本地创建SSH-keys" class="headerlink" title="1.在本地创建SSH keys"></a>1.在本地创建SSH keys</h3><p>打开终端，输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxx@xx.com"</span></span><br><span class="line"><span class="comment">#  “”里面替换成你的GitHub账户登陆邮箱</span></span><br></pre></td></tr></table></figure><p>接着出面下面文字提示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Oct <span class="number">31</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">24</span> on ttys004</span><br><span class="line">bogon:~ YYKit$ ssh-keygen -t rsa -C <span class="string">"xxx@xxx.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/xx/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>不用管它，直接回车，中间会让输入两次密码，什么都不输入，继续回车，会出现如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Oct <span class="number">31</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">24</span> on ttys004</span><br><span class="line">bogon:~ YYKit$ ssh-keygen -t rsa -C <span class="string">"xxxx@xxx.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/xx/.ssh/id_rsa): </span><br><span class="line">/Users/xx/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/xx/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/xx/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint <span class="keyword">is</span>:</span><br><span class="line">SHA256:rp+<span class="number">6</span>MLo27uTIONMqlO6/E9d9CvJzvVt5QI9I6Z2vy14 <span class="number">468466882</span>@qq.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|            .    |</span></span><br><span class="line"><span class="string">|           o .   |</span></span><br><span class="line"><span class="string">|          o + +  |</span></span><br><span class="line"><span class="string">|  .   . S  o = . |</span></span><br><span class="line"><span class="string">| o . o + . .  +  |</span></span><br><span class="line"><span class="string">|o.. = o o +  o E |</span></span><br><span class="line"><span class="string">|*=+o o + + .o +  |</span></span><br><span class="line"><span class="string">|*XB=o ++=  o+=.  |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">bogon:~ YYKit$</span></span><br></pre></td></tr></table></figure><h3 id="2-复制创建好的SSH-keys到GitHub上"><a href="#2-复制创建好的SSH-keys到GitHub上" class="headerlink" title="2.复制创建好的SSH keys到GitHub上"></a>2.复制创建好的SSH keys到GitHub上</h3><p>这时候，==SSH keys==就创建完了，然后我们需要前往文件夹复制/Users/xxx/.ssh/id_rsa.pub地址下文件==id_rsa.pub==里面的==key==了，</p><p><code>打开id_rsa.pub,复制&quot;xxx@xx.com&quot;之前的部分。</code></p><p>复制完，这时候，来到Github，在你的个人账户中，<br>按照顺序依次点击<br>“Settings –&gt; SSH and GPG keys –&gt; SSH keys –&gt; New SSH Key”,<br>Title可以写自己喜欢的标记，<br>在Key下面粘贴之前复制的内容,然后点击Add SSH Key，<br>这就就添加成功了。<br><img src="https://img-blog.csdnimg.cn/6d44bb4b703040cda898ecc0427d8512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-最后测试是否添加成功SSH-keys"><a href="#3-最后测试是否添加成功SSH-keys" class="headerlink" title="3.最后测试是否添加成功SSH keys"></a>3.最后测试是否添加成功SSH keys</h3><p>我们再次测试下公钥有没有添加成功：<br>在终端中，输入代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a1f4c19940b4d20b37c35908fa8b752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上，如果显示 ==You’ve successfully authenticated== 这就表明公钥添加成功了。</p><h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1><p><img src="https://img-blog.csdnimg.cn/2d626140025744e4849ec1a16271572c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：封面背景在文章最后面。&lt;/p&gt;
&lt;h2 id=&quot;一、首先测试下是否有原先有添加过公钥&quot;&gt;&lt;a href=&quot;#一、首先测试下是否有原先有添加过公钥&quot; class=&quot;headerlink&quot; title=&quot;一、首先测试下是否有原先有添加过公钥&quot;&gt;&lt;/a&gt;一、首先测试下是否有原先有添加过公钥&lt;/h2&gt;&lt;p&gt;我们用下面的代码在终端去测试下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -T git@github.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/5071fdab2b8b40b59d2da538dcefca61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;如上，如果显示，==Permission denied(publickey)==  这就表示缺少公钥。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="github" scheme="http://quanluo.github.io/tags/github/"/>
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="sshkeys" scheme="http://quanluo.github.io/tags/sshkeys/"/>
    
  </entry>
  
  <entry>
    <title>mac下启动jupyter notebook</title>
    <link href="http://quanluo.github.io/2021/03/03/mac%E4%B8%8B%E5%90%AF%E5%8A%A8jupyter-notebook/"/>
    <id>http://quanluo.github.io/2021/03/03/mac%E4%B8%8B%E5%90%AF%E5%8A%A8jupyter-notebook/</id>
    <published>2021-03-03T03:12:08.000Z</published>
    <updated>2021-09-07T05:50:28.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210303110634532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h3 id="首先打开终端"><a href="#首先打开终端" class="headerlink" title="首先打开终端"></a>首先打开终端</h3><p><img src="https://img-blog.csdnimg.cn/20210303110209276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t%60_70" alt="在这里插入图片描述"></p><h3 id="然后输入start-jupyter-notebook命令"><a href="#然后输入start-jupyter-notebook命令" class="headerlink" title="然后输入start jupyter notebook命令"></a>然后输入start jupyter notebook命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m IPython notebook</span><br><span class="line"></span><br><span class="line"><span class="comment">### 如果是python3的环境就用下面的命令</span></span><br><span class="line">python3 -m IPython notebook</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210303110501413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="最后浏览器就会自动打开-jupyter-notebook"><a href="#最后浏览器就会自动打开-jupyter-notebook" class="headerlink" title="最后浏览器就会自动打开 jupyter notebook"></a>最后浏览器就会自动打开 jupyter notebook</h3><p><img src="https://img-blog.csdnimg.cn/20210303110634532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210303110634532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://quanluo.github.io/tags/Python/"/>
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="jupyter notebook" scheme="http://quanluo.github.io/tags/jupyter-notebook/"/>
    
  </entry>
  
</feed>
