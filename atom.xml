<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quanluo&#39;s blog</title>
  
  <subtitle>Not only can I write code well, but I can also swim well</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quanluo.github.io/"/>
  <updated>2023-07-01T07:52:34.345Z</updated>
  <id>http://quanluo.github.io/</id>
  
  <author>
    <name>Quanluo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 Spring 如何解决 Bean 的循环依赖问题(转载)</title>
    <link href="http://quanluo.github.io/2023/07/01/%E6%B5%85%E8%B0%88-Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://quanluo.github.io/2023/07/01/%E6%B5%85%E8%B0%88-Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98-%E8%BD%AC%E8%BD%BD/</id>
    <published>2023-07-01T07:03:10.000Z</published>
    <updated>2023-07-01T07:52:34.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h2><p>通俗来讲，循环依赖指的是<strong>一个实例或多个实例存在相互依赖的关系</strong>（类之间循环嵌套引用）。</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中 <code>AService</code> 依赖了 <code>BService</code>，<code>BService</code> 也依赖了 <code>AService</code>，这就是两个对象之间的相互依赖。当然循环依赖还包括 <strong>自身依赖、多个实例之间相互依赖</strong>。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/82fcae531d9a47b09a72c05c85c67aa1.png#pic_center" alt="在这里插入图片描述"></p><p>正常运行上面的代码调用 <code>AService</code> 对象并不会出现问题，也就是说普通对象就算出现循环依赖也不会存在问题，因为对象之间存在依赖关系是很常见的，那么为什么被 Spring 容器管理后的对象会出现循环依赖问题呢？</p><h2 id="2-Spring-Bean-的循环依赖问题"><a href="#2-Spring-Bean-的循环依赖问题" class="headerlink" title="2. Spring Bean 的循环依赖问题"></a>2. Spring Bean 的循环依赖问题</h2><p>被 Spring 容器管理的对象叫做 Bean，为什么 Bean 会存在循环依赖问题呢？</p><p>想要了解 Bean 的循环依赖问题，首先需要了解 Bean 是如何创建的。</p><h3 id="2-1-Bean-的创建步骤"><a href="#2-1-Bean-的创建步骤" class="headerlink" title="2.1 Bean 的创建步骤"></a>2.1 Bean 的创建步骤</h3><p>为了能更好的展示出现循环依赖问题的环节，所以这里的 Bean 创建步骤做了简化：</p><p>1、在创建 Bean 之前，Spring 会通过扫描获取 BeanDefinition。</p><p>2、BeanDefinition就绪后会读取 BeanDefinition 中所对应的 class 来加载类。</p><p>3、实例化阶段：根据构造函数来完成实例化 （<strong>未属性注入以及初始化的对象</strong> 这里简称为 <strong>原始对象</strong>）</p><p>4、属性注入阶段：对 Bean 的属性进行依赖注入 （这里就是<strong>发生循环依赖问题的环节</strong>）</p><p>5、如果 Bean 的某个方法有AOP操作，则需要根据原始对象生成<strong>代理对象</strong>。</p><p>6、最后把代理对象放入单例池（一级缓存<code>singletonObjects</code>）中。</p><p><strong>两点说明：</strong></p><p>上面的 Bean 创建步骤是对于 <strong>单例（singleton）</strong> 作用域的 Bean。</p><p>Spring 的 AOP 代理就是作为 <code>BeanPostProcessor</code> 实现的，而 <code>BeanPostProcessor</code> 是发生在属性注入阶段后的，所以 <strong>AOP</strong> 是在 <strong>属性注入</strong> 后执行的。</p><h3 id="2-2-为什么-Spring-Bean-会产生循环依赖问题？"><a href="#2-2-为什么-Spring-Bean-会产生循环依赖问题？" class="headerlink" title="2.2 为什么 Spring Bean 会产生循环依赖问题？"></a>2.2 为什么 Spring Bean 会产生循环依赖问题？</h3><p>通过上面的 Bean 创建步骤可知：实例化 Bean 后会进行 属性注入（依赖注入）</p><p>如上面的 <code>AService</code> 和 <code>BService</code> 的依赖关系，当 <code>AService</code> 创建时，会先对 <code>AService</code> 进行实例化生成一个原始对象，然后在进行属性注入时发现了需要 <code>BService</code> 对应的 Bean，此时就会去为 <code>BService</code> 进行创建，在 <code>BService</code> 实例化后生成一个原始对象后进行属性注入，此时会发现也需要 <code>AService</code> 对应的 Bean。</p><p><img src="https://img-blog.csdnimg.cn/7983014a8e83491ead2759641939cb80.png#pic_center" alt="在这里插入图片描述"></p><p>这样就会造成 <code>AService</code> 和 <code>BService</code> 的 Bean 都无法创建，就会产生 <strong>循环依赖</strong> 问题。</p><h3 id="2-3-三大循环依赖问题场景"><a href="#2-3-三大循环依赖问题场景" class="headerlink" title="2.3 三大循环依赖问题场景"></a>2.3 三大循环依赖问题场景</h3><p>Spring 并不能解决所有 Bean 的循环依赖问题，接下来通过例子来看看哪些场景下的循环依赖问题是不能被解决的。循环依赖是指在应用程序中存在相互引用的对象，导致无法正确地初始化这些对象。以下是三个常见的循环依赖问题场景：</p><ol><li>构造函数循环依赖： 当两个或多个类在它们的构造函数中相互依赖时，可能会引发构造函数循环依赖问题。例如，类A依赖于类B的实例，而同时类B也依赖于类A的实例。这种情况下，如果使用传统的依赖注入方式，很可能会导致无限循环，无法正确完成实例化。</li><li>属性循环依赖： 当两个或多个类之间存在相互依赖的属性关系时，可能会引发属性循环依赖问题。例如，类A有一个属性引用类型为类B的实例，而类B又有一个属性引用类型为类A的实例。如果没有正确处理循环依赖，可能会导致无法正确初始化属性。</li><li>静态成员变量循环依赖： 当两个或多个类之间存在相互依赖的静态成员变量时，可能会引发静态成员变量循环依赖问题。例如，类A的静态成员变量引用类型为类B的实例，而类B的静态成员变量又引用类型为类A的实例。这种情况下，无法解决循环依赖，可能导致应用程序加载和初始化时出现问题。</li></ol><p>以上是三个常见的循环依赖问题场景。在实际开发中，为了避免循环依赖问题，可以采取一些解决方案，例如使用延迟初始化、Setter注入替代构造函数注入、引入第三方容器管理依赖关系等。具体的解决方法可以根据具体的情况和框架选择。</p><p>对应的解决方法：</p><ol><li>构造函数循环依赖：<ul><li>通过构造函数注入改为使用Setter注入：将类的依赖关系改为通过Setter方法来注入，从而打破循环依赖。</li><li>使用延迟初始化：延迟初始化一个或多个循环依赖的对象，可以通过懒加载或者使用代理对象实现。</li></ul></li><li>属性循环依赖：<ul><li>使用懒加载（<strong>@Lazy</strong>）：将循环依赖的属性设置为延迟加载，只有在需要的时候才进行初始化。</li><li>使用中间对象：引入一个中间对象，它的责任是处理循环依赖的属性，并且在合适的时候进行初始化。</li></ul></li><li>静态成员变量循环依赖：<ul><li>使用静态工厂方法：将实例的创建和初始化放在静态工厂方法中，由工厂方法控制依赖关系的初始化顺序。</li><li>使用第三方容器：使用像Spring这样的依赖注入容器，容器可以解决循环依赖问题并正确地管理对象的生命周期。</li></ul></li></ol><h2 id="3-Spring-如何解决循环依赖问题？"><a href="#3-Spring-如何解决循环依赖问题？" class="headerlink" title="3. Spring 如何解决循环依赖问题？"></a>3. Spring 如何解决循环依赖问题？</h2><p>通过上文的内容能了解到  <strong>Spring 为什么会产生循环依赖问题</strong> 以及 <strong>Spring 能解决什么场景下的循环依赖问题</strong>。</p><p>上文中也有提到过 Spring 是靠 <strong>三级缓存</strong> 来解决循环依赖问题的，接下来了解一下 <strong>什么是三级缓存</strong> 以及 <strong>解决循环依赖问题的具体流程</strong>。</p><h3 id="3-1-三级缓存是什么？"><a href="#3-1-三级缓存是什么？" class="headerlink" title="3.1 三级缓存是什么？"></a>3.1 三级缓存是什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>三级缓存分为：</p><ul><li>一级缓存（<code>singletonObjects</code>）：缓存的是<strong>已经实例化、属性注入、初始化后</strong>的 Bean 对象。</li><li>二级缓存（<code>earlySingletonObjects</code>）：缓存的是<strong>实例化后，但未属性注入、初始化</strong>的 Bean对象（用于提前暴露 Bean）。</li><li>三级缓存（<code>singletonFactories</code>）：缓存的是一个 <code>ObjectFactory</code>，主要作用是生成原始对象进行 AOP 操作后的<strong>代理对象</strong>（这一级缓存主要用于解决 AOP 问题，后续文章中讲解）。</li></ul><h3 id="3-2-为什么缓存可以解决循环依赖问题？"><a href="#3-2-为什么缓存可以解决循环依赖问题？" class="headerlink" title="3.2 为什么缓存可以解决循环依赖问题？"></a>3.2 为什么缓存可以解决循环依赖问题？</h3><p><strong>（注意这里只是为了说明缓存可以解决循环依赖问题，但是 Spring 实际上并不是这样做的）</strong></p><p>上文中可以看到 <code>AService</code> 和 <code>BService</code> 的循环依赖问题是因为 <code>AService的创建</code> 需要 <code>BService的注入</code>，<code>BService的注入</code> 需要 <code>BService的创建</code>，<code>BService的创建</code> 需要 <code>AService的注入</code>，<code>AService的注入</code> 需要 <code>AService的创建</code>，从而形成的环形调用。</p><p>想要打破这一环形，只需要增加一个 <strong>缓存</strong> 来存放 <strong>原始对象</strong> 即可。</p><p>在创建 <code>AService</code> 时，实例化后将 <strong>原始对象</strong> 存放到缓存中（提早暴露），然后依赖注入时发现需要 <code>BService</code>，便会去创建 <code>BService</code>，实例化后同样将 <strong>原始对象</strong> 存放到缓存中，然后依赖注入时发现需要 <code>AService</code> 便会从缓存中取出并注入，这样 <code>BService</code> 就完成了创建，随后 <code>AService</code> 也就能完成属性注入，最后也完成创建。这样就打破了环形调用，避免循环依赖问题。</p><p><img src="https://img-blog.csdnimg.cn/36952edcc9bb491ab3f27d116ebd0162.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-3-为什么还需要第三级缓存？"><a href="#3-3-为什么还需要第三级缓存？" class="headerlink" title="3.3 为什么还需要第三级缓存？"></a>3.3 为什么还需要第三级缓存？</h3><p>通过上面的分析可以发现只需要一个存放 <strong>原始对象</strong> 的缓存就可以解决循环依赖问题，也就是说只要二级缓存（<code>earlySingletonObjects</code>）就够了，那么为什么 Spring 还设置了三级缓存（<code>singletonFactories</code>）呢？</p><p>其实 <strong>第三级缓存（<code>singletonFactories</code>）</strong> 是为了处理 Spring 的 AOP的。</p><p>如上面的例子如果 <code>AService</code> 中方法没有使用 AOP 操作，会发现 <code>BService</code> 注入的 <strong>原始对象</strong> 与最后 <code>AService</code> 完成创建后的最终对象是<strong>同一个对象</strong>。</p><p>如果 <code>AService</code> 方法中有 AOP 操作，Bean 的创建会如下图：</p><p><img src="https://img-blog.csdnimg.cn/7e40764da2c042c3a0dc074becf31a33.png#pic_center" alt="在这里插入图片描述"></p><p>所以如果 <code>AService</code> 方法中有 AOP 操作时，当 <code>AService</code> 的原始对象赋值（注入）给 <code>BService</code>，<code>AService</code> 会进行 AOP 操作产生一个 <strong>代理对象</strong>，这个代理对象最后会被放入单例池（一级缓存）中，也就是说此时 <code>BService</code> 中注入的对象是原始对象，而 <code>AService</code> 最终创建的完成后是代理对象，这样就会<strong>导致 <code>BService</code> 依赖的 <code>AService</code> 和 最终的 <code>AService</code> 不是同一个对象</strong>。</p><p>出现这个问题主要是上文提到过的 AOP 是通过 <code>BeanPostProcessor</code> 实现的，而 <code>BeanPostProcessor</code> 是在 <strong>属性注入阶段后</strong> 才执行的，所以会导致<strong>注入的对象有可能和最终的对象不一致</strong>。</p><hr><h3 id="3-4-Spring-是如何通过第三级缓存来避免-AOP-问题的？"><a href="#3-4-Spring-是如何通过第三级缓存来避免-AOP-问题的？" class="headerlink" title="3.4 Spring 是如何通过第三级缓存来避免 AOP 问题的？"></a>3.4 Spring 是如何通过第三级缓存来避免 AOP 问题的？</h3><p>三级缓存中存放的是 <code>ObjectFactory</code> 对象，那 <code>ObjectFactory</code> 是什么呢？</p><p><strong><code>ObjectFactory</code> 是什么？</strong></p><p>深入源码会发现 Spring 在 <code>doCreateBean()</code> 方法中的 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 加入缓存。</p><p><img src="https://img-blog.csdnimg.cn/2ec8b645ed1e4e438b002c0d64f58b32.png#pic_center" alt="在这里插入图片描述"></p><p>深入 <code>addSingletonFactory</code> 方法：可以看到方法中的第二个参数就是 <code>ObjectFactory</code> 类型，并且将其添加进 <strong>三级缓存（<code>singletonFactories</code>）</strong> 中。</p><p><img src="https://img-blog.csdnimg.cn/e6a26511dcb540cf852ff0cc76228799.png#pic_center" alt="在这里插入图片描述"></p><p>这里放一下 <code>ObjectFactory</code> 类：</p><p><img src="https://img-blog.csdnimg.cn/c8c5d9b21cf942a9b5e24eca6bcf9855.png#pic_center" alt="在这里插入图片描述"></p><p>也就是说 Spring 在加入缓存时，会将 <strong>实例化后生成的原始对象</strong> 通过 <strong>lambda 表达式调用 <code>getObject()</code> 方法，<code>getObject()</code> 方法里调用 <code>getEarlyBeanReference()</code> 方法</strong> 来封装成 <code>ObjectFactory</code> 对象。</p><p><strong><code>getEarlyBeanReference()</code> 方法的作用</strong></p><p>进入 <code>getEarlyBeanReference()</code> 中，会发现调用了 <code>SmartInstantiationAwareBeanPostProcessor</code> 的 <code>getEarlyBeanReference()</code> 方法。</p><p><img src="https://img-blog.csdnimg.cn/8fefe0ef648f4261bb1a93b7fce740c6.png#pic_center" alt="在这里插入图片描述"></p><p>找到 <code>SmartInstantiationAwareBeanPostProcessor</code> 的实现类 <code>AbstractAutoProxyCreator</code> 实现的 <code>getEarlyBeanReference()</code> 方法就可以看到其作用了。</p><p><img src="https://img-blog.csdnimg.cn/c8e411fa884d499492a3c2aed14af34f.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>earlyProxyReferences</code> 存储的是 <code>(beanName, bean)</code> 键值对，这里的 bean 指的是原始对象（刚实例化后的对象）。</li><li><code>wrapIfNecessary()</code> 方法用于执行 AOP 操作，生成一个<strong>代理对象</strong>（也就是说<strong>如果有 AOP 操作最后返回的是代理对象，否则返回的还是原始对象</strong>）。</li></ul><blockquote><p><strong>Spring 真正意义上地创建 Bean 的流程</strong></p></blockquote><p>先放具体流程图：</p><p><img src="https://img-blog.csdnimg.cn/97e65a93c0c949e5bde3623288d99e08.png#pic_center" alt="在这里插入图片描述"></p><p>要点说明：</p><ol><li>并不是马上就执行 <code>ObjectFactory</code> 的 <code>getEarlyBeanReference()</code> 方法（有循环依赖时才执行）。<ul><li>实例化后的 Bean 会生成原始对象，然后经过 lambda 表达式封装为 <code>ObjectFactory</code> 对象，并且通过 <code>addSingletonFactory()</code> 方法将其放入 三级缓存（<code>singletonFactories</code>）中。</li><li>但是这里执不执行 lambda 表达式中的 <code>getEarlyBeanReference()</code> 方法是看程序有没有调用 <code>singletonFactories.get(beanName)</code>，只有调用了该方法（其实也就是看<strong>是否存在循环依赖</strong>需要提前获得该 Bean），才会触发执行 <code>getEarlyBeanReference()</code> 方法。</li><li>而 <code>getEarlyBeanReference()</code> 方法会根据 Bean 中是否有 AOP 操作来决定返回的是 <strong>原始对象</strong> 还是 <strong>代理对象</strong>，并且会将其上移到二级缓存中（也就是提前暴露出来让别的 Bean 使用）。</li></ul></li><li>如果 Bean 中有 AOP 操作，而 AOP 操作又是在属性注入之后执行的，那么之前的 <code>getEarlyBeanReference()</code> 方法中执行的 AOP 操作<strong>会不会重复</strong>？<ul><li><strong>答案是不会</strong>，还记得 <code>getEarlyBeanReference()</code> 方法中的 <strong><code>earlyProxyReferences</code></strong> 吗，这个就是用来记录当前 Bean 是否已经执行 AOP 操作。</li><li>当属性注入后需要执行 AOP 操作时，会先判断当前的 Bean 是否在 <code>earlyProxyReferences</code> 中，如果在则说明已经提前执行了 AOP 了，不用再执行了，否则就执行当前 AOP 操作。</li></ul></li><li>二级缓存中的对象什么时候会上移到一级缓存？<ul><li>二级缓存是为了提前暴露 Bean 来解决循环依赖问题，此时的 Bean 可能还没有进行属性注入，只有等完成了属性注入、初始化后的 Bean 才会上移到一级缓存（单例池）中。</li></ul></li><li>为什么可以解决 AOP 的问题？<ul><li>三级缓存通过利用 <code>ObjectFactory</code> 和 <code>getEarlyBeanReference()</code> 做到了提前执行 AOP 操作从而生成代理对象。</li><li>这样在上移到二级缓存时，可以做到如果 Bean 中有 AOP 操作，那么提前暴露的对象会是 AOP 操作后返回的代理对象；如果没有 AOP 操作，那么提前暴露的对象会是原始对象。</li><li>这样就能做到出现循环依赖问题时，注入依赖的对象和最终生成的对象是同一个对象。（相当于 AOP 提前在属性注入前完成，这样就不会导致后面生成的代理对象与属性注入时的对象的不一致）</li></ul></li></ol><p>所以 Spring 利用 <strong>三级缓存</strong> 巧妙地将出现 <strong>循环依赖</strong> 时的 <strong>AOP 操作</strong> 提前到了 <strong>属性注入</strong> 之前，避免了对象不一致问题。</p><h2 id="4-梳理-Spring-解决-Bean-的循环依赖的整个流程"><a href="#4-梳理-Spring-解决-Bean-的循环依赖的整个流程" class="headerlink" title="4. 梳理 Spring 解决 Bean 的循环依赖的整个流程"></a>4. 梳理 Spring 解决 Bean 的循环依赖的整个流程</h2><p>还是以 <code>AService</code> 和 <code>BService</code> 的循环依赖为例，完整地看看 Spring 是如何解决 Bean 的循环依赖问题。</p><blockquote><p><strong>源码分析整个流程</strong></p></blockquote><p>由于前面的内容过于繁琐，这里就以文字概括，只关注几个主要的方法：</p><p>以 <code>AbstractApplicationContext</code> 的 <code>refresh()</code> 方法出发，进入 <code>finishBeanFactoryInitialization()</code> 方法再进入 <code>preInstantiateSingletons()</code> 方法再进入 <code>getBean()</code> 方法再进入 <code>doGetBean()</code> 方法。</p><p>看看 <code>doGetBean()</code> 方法：</p><p><img src="https://img-blog.csdnimg.cn/d7365a617df74c49891f373ed63acf2f.png#pic_center" alt="在这里插入图片描述"></p><p>其中的第一个 <code>getSingleton(beanName)</code> 是判断 <strong>三级缓存</strong> 中是否有创建好的 Bean 对象，看看源码：</p><p><img src="https://img-blog.csdnimg.cn/47c926d30aa64b5d87c386eac3cc8508.png#pic_center" alt="在这里插入图片描述"></p><p>可以看到这里分别去每一级的缓存中取数据，依次从第一级开始取数据，如果取得到则直接返回，取不到则往下一级查找。</p><p>可以看到在<strong>第三级缓存</strong>中调用了 <code>singletonFactories.get(beanName)</code> 按照上文所说的会触发执行有 AOP 操作返回代理对象，没有返回原始对象，并且在这里会判断取出的数据是否存在，存在则上移到二级缓存中并删除三级缓存的数据。</p><p>如果都没有的话就会执行第二个 <code>getSingleton()</code> 也就是去执行 <code>createBean()</code> 创建一个 Bean 对象出来。</p><p>会执行 <code>createBean()</code> 方法中的 <code>doCreateBean()</code> 方法，看看源码：</p><p><img src="https://img-blog.csdnimg.cn/254eea85cca34b39ab6c847d8cf0ee9d.png#pic_center" alt="在这里插入图片描述"></p><p>到这里应该就一目了然了。</p><blockquote><p><strong>梳理整个流程</strong></p></blockquote><ol><li>首先会获取 <code>AService</code> 对应的 Bean 对象。</li><li>先是调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 判断是否有该 Bean 的实例，有就直接返回了。（显然这里没有）</li><li>然后调用 <code>doGetBean()</code> 中的第二个 <code>getSingleton()</code> 方法来执行 <code>doCreateBean()</code> 方法。</li><li>先进行实例化操作（也就是利用构造函数实例化），此时实例化后生成的是原始对象。</li><li>将原始对象通过 lambda表达式 进行封装成 <code>ObjectFactory</code> 对象，通过 <code>addSingletonFactory</code> 加入三级缓存中。</li><li>然后再进行属性注入，此时发现需要注入 <code>BService</code> 的 Bean，会通过 <code>doGetBean()</code> 去获取 <code>BService</code> 对应的 Bean。</li><li>同样调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 判断是否有该 Bean 的实例，显然这里也是不会有 <code>BService</code> 的 Bean 的。</li><li>然后只能调用 <code>doGetBean()</code> 中的第二个 <code>getSingleton()</code> 方法来执行 <code>doCreateBean()</code> 方法来创建一个 <code>BService</code> 的 Bean。</li><li>同样地先进行实例化操作，生成原始对象后封装成 <code>ObjectFactory</code> 对象放入三级缓存中。</li><li>然后进行属性注入，此时发现需要注入 <code>AService</code> 的 Bean，此时调用调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 查找是否有 <code>AService</code> 的 Bean。此时会触发三级缓存，也就是调用 <code>singletonFactories.get(beanName)</code>。</li><li>因为三级缓存中有 <code>AService</code> 的原始对象封装的 <code>ObjectFactory</code> 对象，所以可以获取到的代理对象或原始对象，并且上移到二级缓存中，提前暴露给 <code>BService</code> 调用。</li><li>所以 <code>BService</code> 可以完成属性注入，然后进行初始化后，将 Bean 放入一级缓存，这样 <code>AService</code> 也可以完成创建。</li></ol><p>以上就是 Spring 解决 Bean 的循环依赖问题的整个流程了。</p><h2 id="5-疑问"><a href="#5-疑问" class="headerlink" title="5.疑问"></a>5.疑问</h2><h3 id="为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理"><a href="#为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理" class="headerlink" title="为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理"></a>为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理</h3><p>解答：</p><p>这个问题太经典了，这里我说一下我的看法：首先呢，如果使用二级缓存的话，那么我可以理解为相当于提前判断Bean是否需要AOP，需要的话直接生成代理对象放入二级缓存，等Bean创建完成后再升到一级缓存中。大概是这个思路吧，但是为什么Spring不这么设计呢，我认为有两点原因：① 由于Spring对AOP的设计思想是AOP的创建时机是在初始化后为Bean生成代理对象的，如果采用上述的设计，那么不管Bean是否存在循环依赖，都会提早生成代理对象，这样其实已经违背了Bean的设计理念。② 使用ObjectFactory对象每次触发调用lambda表达式中的 <code>getEarlyBeanReference()</code>生成的代理对象其实都是新创建的，也就是说如果存在两个以上的Bean循环依赖，例如 A 依赖 B 和 C，而 B 也依赖 A，C 也依赖A，并且A需要AOP，那么此时在创建 B 时触发 A 的ObjectFactory对象生成的代理对象和创建 C 时触发 A 的ObjectFactory对象生成的代理对象是不一样的，因为两次触发生成的都是新对象。这也就是为什么需要在中间设置一个二级缓存存放第一次调用创建的代理对象，这样还需要属性注入 A 的Bean就可以直接在二级缓存中拿，而不需要再次触发ObjectFactory对象。</p><p>作者：单程车票<br>链接：<a href="https://juejin.cn/post/7218080360403615804" target="_blank" rel="noopener">https://juejin.cn/post/7218080360403615804</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是循环依赖？&quot;&gt;&lt;a href=&quot;#1-什么是循环依赖？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是循环依赖？&quot;&gt;&lt;/a&gt;1. 什么是循环依赖？&lt;/h2&gt;&lt;p&gt;通俗来讲，循环依赖指的是&lt;strong&gt;一个实例或多个实例存在相互依赖的关系&lt;/strong&gt;（类之间循环嵌套引用）。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; BService bService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; AService aService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上述例子中 &lt;code&gt;AService&lt;/code&gt; 依赖了 &lt;code&gt;BService&lt;/code&gt;，&lt;code&gt;BService&lt;/code&gt; 也依赖了 &lt;code&gt;AService&lt;/code&gt;，这就是两个对象之间的相互依赖。当然循环依赖还包括 &lt;strong&gt;自身依赖、多个实例之间相互依赖&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://quanluo.github.io/tags/Spring/"/>
    
      <category term="循环依赖" scheme="http://quanluo.github.io/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>学Java的这些HashMap的知识点必须得懂(JDK1.8)</title>
    <link href="http://quanluo.github.io/2023/06/30/%E5%AD%A6Java%E7%9A%84%E8%BF%99%E4%BA%9BHashMap%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%85%E9%A1%BB%E5%BE%97%E6%87%82(JDK1.8)/"/>
    <id>http://quanluo.github.io/2023/06/30/%E5%AD%A6Java%E7%9A%84%E8%BF%99%E4%BA%9BHashMap%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%85%E9%A1%BB%E5%BE%97%E6%87%82(JDK1.8)/</id>
    <published>2023-06-30T07:09:54.000Z</published>
    <updated>2023-06-30T07:50:50.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><ol><li><p><strong>扩容条件判断：当 HashMap 中的元素数量超过了负载因子与当前容量的乘积时，就会触发扩容操作。具体判断条件可以参考 <code>threshold</code> 的计算方式。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br></pre></td></tr></table></figure><ul><li><p>在 HashMap 中，<code>threshold</code> 是用来判断是否需要进行扩容的阈值。<code>threshold</code> 的计算方式是将当前容量 (<code>capacity</code>) 乘以负载因子 (<code>loadFactor</code>)，然后将结果转换为整数。</p><p>负载因子是一个表示 HashMap 元素填充程度的参数，默认情况下是 0.75。当 HashMap 中的元素数量超过了 <code>threshold</code>，就会触发扩容操作，以保持 HashMap 的性能。</p><p><code>threshold</code> 的计算公式是 <code>threshold = (int)(capacity * loadFactor)</code>，其中 <code>capacity</code> 表示当前 HashMap 的容量，<code>loadFactor</code> 表示负载因子。</p><p>具体来说，<code>capacity * loadFactor</code> 的结果是一个浮点数，通过强制类型转换 <code>(int)</code> 将其转换为整数。强制类型转换会将浮点数的小数部分截断，只取整数部分。这样就得到了一个整数类型的 <code>threshold</code>。</p><p>计算出的 <code>threshold</code> 值实际上代表了 HashMap 在什么时候需要进行扩容。当 HashMap 中的元素数量达到了 <code>threshold</code>，即超过了负载因子所允许的填充程度时，就会触发扩容操作。</p><p>通过合理设置负载因子，可以在空间与时间的平衡中进行权衡。较小的负载因子可以减少空间消耗，但可能导致哈希冲突增加；较大的负载因子可以减少哈希冲突，但会增加空间消耗。根据具体的应用场景，可以调整负载因子以达到最佳性能。</p><p>总结起来，<code>threshold = (int)(capacity * loadFactor)</code> 是根据当前容量和负载因子计算得出的触发 HashMap 扩容的阈值，当元素数量超过该阈值时，HashMap 将进行扩容操作。</p><a id="more"></a></li></ul></li><li><p><strong>创建新数组：在扩容时，将会创建一个新的数组，其大小是原数组的两倍。新数组的容量是原数组容量的两倍，并且容量必须是 2 的幂次方。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = <span class="keyword">new</span> Node[newCap];</span><br></pre></td></tr></table></figure><ul><li><p>在 HashMap 中，<code>newTab</code> 是一个新的 Node 数组，用于存储扩容后的元素。<code>newCap</code> 是扩容后的容量，代表了新数组的长度。</p><p><code>Node&lt;K,V&gt;[] newTab = new Node[newCap]</code> 是创建一个新的 Node 数组对象。其中 <code>&lt;K, V&gt;</code> 表示泛型类型参数，分别代表键和值的类型。</p><p>通过 <code>new Node[newCap]</code> 创建出的新数组，每个元素都是一个 Node 类型的对象。Node 类型通常表示哈希桶中的一个节点，用于存储实际的键值对。</p><p>在 HashMap 的扩容过程中，需要创建一个容量更大的新数组，并将原数组中的元素重新分配到新数组的对应位置上。这是因为扩容后 HashMap 需要有更多的桶来分散键值对，以减少哈希冲突的概率。</p><p>在创建新数组时，使用 <code>new Node[newCap]</code> 声明并初始化一个新的 Node 数组。注意，<code>newCap</code> 是指定的新容量大小，是原容量的两倍或其他扩容方式计算得出的结果。</p><p>通过创建新的 Node 数组，HashMap 就可以在扩容后使用更大的内部数组来存储元素，以适应更多的键值对。接下来，就可以将原数组中的元素重新插入到新数组的相应位置上，并更新 HashMap 内部的数据结构，完成扩容操作。</p></li></ul></li><li><p><strong>数据迁移：接下来，需要将原数组中的数据逐个迁移到新数组中。这一过程称为重新哈希(Rehash)。对于每个非空的桶，会遍历链表或红黑树中的节点，并根据新数组的容量重新计算其在新数组中的位置。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; e : oldTab) &#123;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算新的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> newIndex = indexFor(e.hash, newCapacity);</span><br><span class="line">        <span class="comment">// 将节点添加到新数组中</span></span><br><span class="line">        <span class="comment">// 省略部分代码...</span></span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>更新引用：完成数据迁移后，需要更新 HashMap 对象内部的一些引用。主要包括数组的引用和阈值的更新。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table = newTab;</span><br><span class="line">threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br></pre></td></tr></table></figure><ul><li><p><code>table = newTab;</code> 和 <code>threshold = (int)(newCapacity * loadFactor);</code> 是在 HashMap 扩容过程中更新数据结构的两个关键步骤。</p><p>首先，<code>table = newTab;</code> 将引用指向新的数组 <code>newTab</code>。这意味着 HashMap 的内部数组 <code>table</code> 现在引用了扩容后的新数组，从而使 HashMap 在接下来的操作中使用新数组来存储元素。</p><p>接着，<code>threshold = (int)(newCapacity * loadFactor);</code> 根据新的容量 <code>newCapacity</code> 和负载因子 <code>loadFactor</code> 计算得到新的阈值 <code>threshold</code>。这个阈值表示在何时需要再次进行扩容。</p><p>解释一下这个计算过程：<code>newCapacity</code> 是新数组的容量，它可能是原容量的两倍或其他扩容方式计算得出的结果。负载因子 <code>loadFactor</code> 是一个参数，表示 HashMap 元素填充程度的比例，默认为 0.75。</p><p><code>newCapacity</code> 乘以 <code>loadFactor</code> 得到一个浮点数，然后通过强制类型转换 <code>(int)</code> 将其转换为整数形式。这样得到的 <code>threshold</code> 就是新容量和负载因子相乘后取整得到的结果。</p><p>计算出的新阈值 <code>threshold</code> 可以用来判断何时再次触发扩容操作。当 HashMap 中的元素数量超过了新阈值时，就会触发下一次的扩容操作，以保持 HashMap 的性能。</p></li></ul></li><li><p><strong>并发处理：在多线程环境下，可能存在并发情况下进行的插入、删除等操作。为了保证线程安全，HashMap 在扩容过程中会采取一些措施，如使用 synchronized 关键字或者 CAS（Compare and Swap）操作来避免并发问题。</strong></p></li></ol><p><strong>总结起来，HashMap 的扩容步骤可以概括为：创建新数组、将原数组的数据迁移到新数组中、更新引用和处理并发情况。通过扩容，HashMap 可以提高容量，从而减少哈希冲突的概率，提高查询和插入操作的性能。</strong></p><h3 id="为什么HashMap扩容的容量必须是-2-的幂次方"><a href="#为什么HashMap扩容的容量必须是-2-的幂次方" class="headerlink" title="为什么HashMap扩容的容量必须是 2 的幂次方"></a>为什么HashMap扩容的容量必须是 2 的幂次方</h3><p>HashMap 扩容的容量必须是 2 的幂次方，这是因为 HashMap 在计算元素在数组中存储位置时使用了位运算，通过将哈希值与 (capacity - 1) 进行与操作来得到索引值。具体而言，假设 HashMap 的容量为 n，那么对应的数组索引范围为 [0, n-1]。</p><p>原始的 HashMap 实现使用取模运算（<code>%</code>）来计算索引，例如 <code>index = hash % capacity</code>。然而，这种方式在计算机中是比较耗时的操作，而且对于不同的容量，取模的结果分布并不均匀。</p><p>为了提高计算速度和优化索引的分布，HashMap 使用位运算来计算索引，将取模操作转换为与运算（<code>&amp;</code>）。具体地，假设容量是 2 的幂次方（即 n = 2^k），那么 <code>(n - 1)</code> 的二进制形式的所有位都是 1。这样，在进行与操作时，结果的最低 k 位就是哈希值的有效位，通过这些有效位可以获取到元素在数组中的索引。</p><p>例如，当容量为 16 （即 2^4）时，<code>(n - 1)</code> 的二进制形式为 1111，对任意哈希值进行与操作后，得到的结果只会影响哈希值的最低 4 位，即 <code>hash &amp; (capacity - 1)</code>。这样，通过位运算而不是取模运算来计算索引，可以提高计算效率，并且保持了较好的分布性。</p><p>因此，在设计 HashMap 扩容机制时，为了保持元素在数组中的位置计算准确和高效，容量必须是 2 的幂次方。这样可以充分利用位运算来计算索引，提高 HashMap 的性能和效率。</p><h3 id="为何HashMap中的扩容是-lt-lt-1"><a href="#为何HashMap中的扩容是-lt-lt-1" class="headerlink" title="为何HashMap中的扩容是&lt;&lt;1"></a>为何HashMap中的扩容是&lt;&lt;1</h3><p>在 HashMap 中，扩容操作使用的是位运算符 <code>&lt;&lt;</code> 来实现容量的翻倍。<code>&lt;&lt;</code> 是位左移操作符，它将二进制数向左移动指定的位数，并在右侧填充零。</p><p>HashMap 扩容时，会将当前容量乘以 2，即进行容量的翻倍。这是因为 HashMap 内部使用一个数组来存储元素，扩容时需要重新创建一个更大的数组，并将原数组中的元素重新分配到新数组的对应位置上。</p><p>通过将当前容量左移一位，相当于将当前容量乘以 2。这种操作比起使用乘法运算符 <code>*</code> 来说更加高效，因为位运算通常比算术运算更快。</p><p>举个例子，假设当前容量为 n，那么 <code>n &lt;&lt; 1</code> 的结果就是将 n 的二进制表示向左移动一位，并在右侧填充零。这样就得到了新的容量，即原容量的两倍。</p><p>使用位运算的方式进行扩容，可以通过简单的位移操作来达到容量翻倍的效果，而不需要进行乘法运算，从而提高了性能和效率。</p><p>因此，HashMap 中使用 <code>&lt;&lt;</code> 运算符来进行扩容，是一种高效的方式，可以快速地将当前容量扩大一倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制1001左移一位</span></span><br><span class="line"> <span class="number">10010</span> = <span class="number">01001</span> &lt;&lt; <span class="number">1</span> </span><br><span class="line"><span class="comment">// 对应的的十进制数值为</span></span><br><span class="line"> <span class="number">01001</span> = <span class="number">9</span></span><br><span class="line"> <span class="number">10010</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="HashMap的存储结构转换机制（链表-gt-红黑树）"><a href="#HashMap的存储结构转换机制（链表-gt-红黑树）" class="headerlink" title="HashMap的存储结构转换机制（链表-&gt;红黑树）"></a>HashMap的存储结构转换机制（链表-&gt;红黑树）</h2><p>在 JDK 8 及之后的版本中，HashMap 对于哈希冲突的处理引入了红黑树来替代链表，以提高在桶中查找的效率。下面是链表转换为红黑树的机制：</p><ol><li>当链表中的节点数量超过阈值（默认为 8）时，会进行链表转换为红黑树的操作。</li><li>在进行转换前，HashMap 会先判断当前桶中的元素是否已经符合红黑树的转换条件，即该桶的长度是否大于等于 8（默认值），如果不满足，则不进行转换，仍然维持链表结构。</li><li>如果满足转换条件，在进行链表转换为红黑树之前，会先判断当前 HashMap 的容量是否达到了一个阈值（默认为 64），如果没有达到，则进行扩容，目的是为了提供红黑树所需的更多桶，防止红黑树因为容量不足而发生退化。</li><li>执行链表转换为红黑树的操作，使用红黑树的插入算法将链表中的节点逐个转移到红黑树中，这个过程是一种链表节点的插入操作。</li><li>在转换完成后，原本的链表就会被替换成一棵红黑树，这样就能够通过红黑树的高效查找算法快速定位到对应的元素。</li></ol><p>需要注意的是，在进行红黑树的转换操作后，如果发现红黑树中的节点数量少于某个阈值（默认为 6），此时会将红黑树恢复成链表结构，以节省内存空间并降低维护成本。</p><p>总结起来，HashMap 的存储结构转换机制是通过在链表长度过长时，将链表转换为红黑树来提高查找效率，并在条件满足时进行桶容量的扩容。同时，为了节省内存空间和维护成本，红黑树节点数量过少时会恢复成链表结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看源码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;     <span class="comment">//binCount遍历次数， 当binCount=0时，链表上有一个节点，故可以推出当当binCount=7即当链表上有8个节点时会进行红黑树的转换</span></span><br><span class="line">  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//这行代码表示，会先将新的set值插入到链表中在进行红黑树的转换，而不是先转红黑树在讲新的set值插入到红黑树中，所以说明当链表上有9个节点时才转换成的红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)  <span class="comment">//TREEIFY_THRESHOLD常量值为8，这个判断为当遍历次数为7时就会将链表结构转为红黑树</span></span><br><span class="line">      treeifyBin(tab, hash);   <span class="comment">//链表转为红黑树的具体实现代码</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  p = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续补充中。。。"><a href="#后续补充中。。。" class="headerlink" title="后续补充中。。。"></a>后续补充中。。。</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap的扩容机制&quot;&gt;&lt;a href=&quot;#HashMap的扩容机制&quot; class=&quot;headerlink&quot; title=&quot;HashMap的扩容机制&quot;&gt;&lt;/a&gt;HashMap的扩容机制&lt;/h2&gt;&lt;h3 id=&quot;扩容步骤&quot;&gt;&lt;a href=&quot;#扩容步骤&quot; class=&quot;headerlink&quot; title=&quot;扩容步骤&quot;&gt;&lt;/a&gt;扩容步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;扩容条件判断：当 HashMap 中的元素数量超过了负载因子与当前容量的乘积时，就会触发扩容操作。具体判断条件可以参考 &lt;code&gt;threshold&lt;/code&gt; 的计算方式。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)(capacity * loadFactor);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 HashMap 中，&lt;code&gt;threshold&lt;/code&gt; 是用来判断是否需要进行扩容的阈值。&lt;code&gt;threshold&lt;/code&gt; 的计算方式是将当前容量 (&lt;code&gt;capacity&lt;/code&gt;) 乘以负载因子 (&lt;code&gt;loadFactor&lt;/code&gt;)，然后将结果转换为整数。&lt;/p&gt;
&lt;p&gt;负载因子是一个表示 HashMap 元素填充程度的参数，默认情况下是 0.75。当 HashMap 中的元素数量超过了 &lt;code&gt;threshold&lt;/code&gt;，就会触发扩容操作，以保持 HashMap 的性能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;threshold&lt;/code&gt; 的计算公式是 &lt;code&gt;threshold = (int)(capacity * loadFactor)&lt;/code&gt;，其中 &lt;code&gt;capacity&lt;/code&gt; 表示当前 HashMap 的容量，&lt;code&gt;loadFactor&lt;/code&gt; 表示负载因子。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;capacity * loadFactor&lt;/code&gt; 的结果是一个浮点数，通过强制类型转换 &lt;code&gt;(int)&lt;/code&gt; 将其转换为整数。强制类型转换会将浮点数的小数部分截断，只取整数部分。这样就得到了一个整数类型的 &lt;code&gt;threshold&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;计算出的 &lt;code&gt;threshold&lt;/code&gt; 值实际上代表了 HashMap 在什么时候需要进行扩容。当 HashMap 中的元素数量达到了 &lt;code&gt;threshold&lt;/code&gt;，即超过了负载因子所允许的填充程度时，就会触发扩容操作。&lt;/p&gt;
&lt;p&gt;通过合理设置负载因子，可以在空间与时间的平衡中进行权衡。较小的负载因子可以减少空间消耗，但可能导致哈希冲突增加；较大的负载因子可以减少哈希冲突，但会增加空间消耗。根据具体的应用场景，可以调整负载因子以达到最佳性能。&lt;/p&gt;
&lt;p&gt;总结起来，&lt;code&gt;threshold = (int)(capacity * loadFactor)&lt;/code&gt; 是根据当前容量和负载因子计算得出的触发 HashMap 扩容的阈值，当元素数量超过该阈值时，HashMap 将进行扩容操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="HashMap" scheme="http://quanluo.github.io/tags/HashMap/"/>
    
      <category term="JDK1.8" scheme="http://quanluo.github.io/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>spring中Bean创建完后打印语句的两种方法（Bean的生命周期）</title>
    <link href="http://quanluo.github.io/2023/06/29/spring%E4%B8%ADBean%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%90%8E%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89/"/>
    <id>http://quanluo.github.io/2023/06/29/spring%E4%B8%ADBean%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%90%8E%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89/</id>
    <published>2023-06-29T08:44:57.000Z</published>
    <updated>2023-07-01T08:51:49.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Bean的生命周期包括四个阶段：</p><ul><li><p>实例化阶段（Instantiation）：容器通过调用构造函数或者工厂方法来创建Bean的实例。</p></li><li><p>属性赋值阶段（Populate properties）：容器将相应的属性值设置给Bean的实例，可以通过setter方法、直接字段注入或者其他自定义的方式完成属性赋值。</p></li><li><p>初始化阶段（Initialization）：在Bean的属性赋值完成后，容器会调用相关的初始化方法（如果有的话），如实现了InitializingBean接口的afterPropertiesSet()方法，或者通过@Bean注解的initMethod属性指定的方法。开发者可以在初始化方法中进行一些额外的操作，例如数据校验、初始化资源等。</p><a id="more"></a></li><li><p>使用阶段（In use）【补充】：经过初始化阶段后，Bean进入可用状态，可以被容器及其他对象使用。</p></li><li><p>销毁阶段（Destruction）：当Bean不再被使用时，容器可以对其进行销毁操作。这包括调用实现了DisposableBean接口的destroy()方法，或者通过@Bean注解的destroyMethod属性指定的方法。开发者可以在销毁方法中释放资源、关闭连接等。</p></li></ul><h2 id="两种方式在Bean创建完后打印语句（Bean的初始化阶段）"><a href="#两种方式在Bean创建完后打印语句（Bean的初始化阶段）" class="headerlink" title="两种方式在Bean创建完后打印语句（Bean的初始化阶段）"></a>两种方式在Bean创建完后打印语句（Bean的初始化阶段）</h2><h3 id="实现InitializingBean接口："><a href="#实现InitializingBean接口：" class="headerlink" title="实现InitializingBean接口："></a>实现InitializingBean接口：</h3><ul><li><p>创建一个类，实现InitializingBean接口。</p></li><li><p>在该类中实现afterPropertiesSet()方法，在该方法中编写创建Bean后要执行的操作，例如打印语句。</p></li><li><p>当Bean被创建后，容器会自动调用afterPropertiesSet()方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean已创建。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-Bean注解和initMethod属性："><a href="#使用-Bean注解和initMethod属性：" class="headerlink" title="使用@Bean注解和initMethod属性："></a>使用@Bean注解和initMethod属性：</h3><ul><li><p>在Bean对应的配置类中，使用@Bean注解定义Bean的创建方法。</p></li><li><p>在@Bean注解中，使用initMethod属性指定在Bean创建后要调用的初始化方法。</p></li><li><p>在初始化方法中，编写需要执行的操作，例如打印语句。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean已创建。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>无论使用哪种方式，当Bean被创建后，打印语句将会在<strong>初始化阶段</strong>执行。</p><p>具体使用哪种方式都可以，当然根据具体的场景选择适合的方式最好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bean的生命周期&quot;&gt;&lt;a href=&quot;#Bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期&quot;&gt;&lt;/a&gt;Bean的生命周期&lt;/h2&gt;&lt;p&gt;Bean的生命周期包括四个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实例化阶段（Instantiation）：容器通过调用构造函数或者工厂方法来创建Bean的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;属性赋值阶段（Populate properties）：容器将相应的属性值设置给Bean的实例，可以通过setter方法、直接字段注入或者其他自定义的方式完成属性赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化阶段（Initialization）：在Bean的属性赋值完成后，容器会调用相关的初始化方法（如果有的话），如实现了InitializingBean接口的afterPropertiesSet()方法，或者通过@Bean注解的initMethod属性指定的方法。开发者可以在初始化方法中进行一些额外的操作，例如数据校验、初始化资源等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://quanluo.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://quanluo.github.io/tags/spring/"/>
    
      <category term="Bean的生命周期" scheme="http://quanluo.github.io/tags/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>解决feign调用时开发环境与正式环境需要增减URL的烦恼</title>
    <link href="http://quanluo.github.io/2023/06/27/%E8%A7%A3%E5%86%B3feign%E8%B0%83%E7%94%A8%E6%97%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E5%A2%9E%E5%87%8FURL%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    <id>http://quanluo.github.io/2023/06/27/%E8%A7%A3%E5%86%B3feign%E8%B0%83%E7%94%A8%E6%97%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E5%A2%9E%E5%87%8FURL%E7%9A%84%E7%83%A6%E6%81%BC/</id>
    <published>2023-06-27T07:52:13.000Z</published>
    <updated>2023-06-27T08:06:00.870Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/f092b72ce6314ea98277aaf28bbb50b4.jpeg#pic_center" alt=""></p><h2 id="项目场景：feign在开发模式的小技巧"><a href="#项目场景：feign在开发模式的小技巧" class="headerlink" title="项目场景：feign在开发模式的小技巧"></a>项目场景：feign在开发模式的小技巧</h2><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>@feignClient指定url才能命中指定的节点,但是正式发布的时候又得删了,很麻烦.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"base"</span>,url = <span class="string">"http://127.0.0.1:9000"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ul><li>把url弄成动态的,并且开发模式才有值,正式环境默认值</li></ul><p>新建一个公共的DevProcessor,把所有需要调用到的微服务ip端口信息弄进去,如果有公共工程的,那就维护好这一份就可以了.<br>实现<strong>BeanPostProcessor</strong>是为了在SpringBoot启动前进行设置<br>利用 <strong>@ConditionalOnProperty</strong> 设置为只在dev模式加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.profiles.active"</span>,havingValue = <span class="string">"dev"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置微服务调试模式下的的ip端口信息</span></span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.base"</span>, <span class="string">"http://127.0.0.1:9000"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.data-compilation"</span>, <span class="string">"http://127.0.0.1:9011"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.data-spider"</span>, <span class="string">"http://127.0.0.1:9106"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.hydro-forecast-short"</span>, <span class="string">"http://127.0.0.1:9004"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.hydrodynamic-waterquality-1d"</span>, <span class="string">"http://127.0.0.1:9006"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.monitor"</span>, <span class="string">"http://127.0.0.1:9103"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.quality-manage"</span>, <span class="string">"http://127.0.0.1:9017"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.reservoir-operation"</span>, <span class="string">"http://127.0.0.1:9015"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.river-lake-health"</span>, <span class="string">"http://127.0.0.1:9016"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.system"</span>, <span class="string">"http://127.0.0.1:9002"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"feign.debug.url.water-resource-allocation"</span>, <span class="string">"http://127.0.0.1:9009"</span>);</span><br><span class="line">        <span class="comment">// 不注册到nacos上,@FeignClient调用指定了url就不会再从nacos上拉取服务信息走负载均衡了</span></span><br><span class="line">        System.setProperty(<span class="string">"spring.cloud.nacos.discovery.register-enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要用到@FeignClient的地方就可以这么写了,注意属性变量引用最后有一个 : 这个不能少,因为正式环境是不会加载之前的DevProcessor类的. : 的作用是默认值为空字符串和原@FeignClient的url的默认值一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name=<span class="string">"base"</span>,url = <span class="string">"$&#123;feign.debug.url.system:&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了,以后开发模式就成指定url访问了,正式环境不受影响</p><p>————————————————<br>版权声明：本文为CSDN博主「DonkeyBulala」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_36850300/article/details/125000814" target="_blank" rel="noopener">https://blog.csdn.net/qq_36850300/article/details/125000814</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/f092b72ce6314ea98277aaf28bbb50b4.jpeg#pic_center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目场景：feign在开发模式的小技巧&quot;&gt;&lt;a href=&quot;#项目场景：feign在开发模式的小技巧&quot; class=&quot;headerlink&quot; title=&quot;项目场景：feign在开发模式的小技巧&quot;&gt;&lt;/a&gt;项目场景：feign在开发模式的小技巧&lt;/h2&gt;&lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;@feignClient指定url才能命中指定的节点,但是正式发布的时候又得删了,很麻烦.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FeignClient&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;base&quot;&lt;/span&gt;,url = &lt;span class=&quot;string&quot;&gt;&quot;http://127.0.0.1:9000&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//.....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="Feign" scheme="http://quanluo.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>DO、DTO、BO、VO、POJO等各种O浅学（总结）</title>
    <link href="http://quanluo.github.io/2022/04/12/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%AD%89%E5%90%84%E7%A7%8DO%E6%B5%85%E5%AD%A6%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <id>http://quanluo.github.io/2022/04/12/DO%E3%80%81DTO%E3%80%81BO%E3%80%81VO%E3%80%81POJO%E7%AD%89%E5%90%84%E7%A7%8DO%E6%B5%85%E5%AD%A6%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/</id>
    <published>2022-04-12T07:08:03.000Z</published>
    <updated>2022-04-12T07:28:03.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/c8dc950ea9064495b2f9a18e4b75adce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt=""></p><h2 id="有哪些-O"><a href="#有哪些-O" class="headerlink" title="有哪些 O"></a>有哪些 O</h2><ul><li><p>DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</p></li><li><p>PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象</p></li><li><p>DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</p> <a id="more"></a></li><li><p>BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。</p></li><li><p>AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</p></li><li><p>VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</p></li><li><p>POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。</p></li><li><p>DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体<br>　<img src="https://img-blog.csdnimg.cn/3b7d7f6507594e709a9d8c451c54f07b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>　　阿里Java开发手册分层领域模型：<br>　　<img src="https://img-blog.csdnimg.cn/75f382b920d64cc59fd8282abcfaf7b3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h2 id="关键的-O-：DO、DTO、VO、BO"><a href="#关键的-O-：DO、DTO、VO、BO" class="headerlink" title="关键的 O ：DO、DTO、VO、BO"></a>关键的 O ：DO、DTO、VO、BO</h2><ul><li><p>VO (View Object)，用于表示一个与前端进行交互的视图对象，它的作用是把某个指定页面(或组件)的所有数据封装起来。实际上，这里的 VO 只包含前端需要展示的数据，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。</p></li><li><p>DTO(Data Transfer Object)，用于表示一个数据传输对象，DTO 通常用于展示层(Controller)和服务层(Service)之间的数据传输对象。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。</p></li><li><p>DO(Data Object) ，持久化对象，它跟持久层(Dao)的数据结构形成一一对应的映射关系。如果持久层是关系型数据库，那么数据库表中的每个字段就对应PO的一个属性，常是entity实体类。</p></li><li><p>BO（Business Object）：业务对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><h2 id="整个数据流程传递"><a href="#整个数据流程传递" class="headerlink" title="整个数据流程传递"></a>整个数据流程传递</h2><p>一般的数据传递是，前端传递VO给接口(Controller)，接口将VO转为DTO传递给service，service将DTO分解为DO，调用领域服务进行调度，然后逆向转为VO或者其他的返回结果，传递给前台。</p></li></ul><h2 id="区别用处"><a href="#区别用处" class="headerlink" title="区别用处"></a>区别用处</h2><h3 id="VO与DTO的区别"><a href="#VO与DTO的区别" class="headerlink" title="VO与DTO的区别"></a>VO与DTO的区别</h3><p>　　大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举。但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。</p><p>　　用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。</p><p>　　理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。</p><h3 id="VO与DTO的应用"><a href="#VO与DTO的应用" class="headerlink" title="VO与DTO的应用"></a>VO与DTO的应用</h3><p>　　上面只是用了一个简单的例子来说明VO与DTO在概念上的区别，本节将会告诉你如何在应用中做出正确的选择。</p><p>　　在以下才场景中，我们可以考虑把VO与DTO二合为一（注意：是实现层面）：</p><p>当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，你很容易理解，DTO对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如JavaScript）或其他机制（JSTL、EL、CSS）。<br>即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让VO退隐。<br>　　以下场景需要优先考虑VO、DTO并存：</p><p>上述场景的反面场景<br>因为某种技术原因，比如某个框架（如Flex）提供自动把POJO转换为UI中某些Field时，可以考虑在实现层面定义出VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个VO所多做的事情带来的开发和维护效率的下降之间的比对。<br>如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个DTO来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的DTO来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。</p><h3 id="DTO与DO的区别"><a href="#DTO与DO的区别" class="headerlink" title="DTO与DO的区别"></a>DTO与DO的区别</h3><p>　　首先是概念上的区别，DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User（对于DTO和DO的命名规则，请参见笔者前面的一篇博文），对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，正如第一篇系列文章所说，DO不是简单的POJO，它具有领域业务逻辑。</p><h3 id="DTO与DO的应用"><a href="#DTO与DO的应用" class="headerlink" title="DTO与DO的应用"></a>DTO与DO的应用</h3><p>　　从上一节的例子中，细心的读者可能会发现问题：既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。</p><p>　　对于DO来说，还有一点需要说明：为什么不在服务层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下：</p><p>两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。<br>DO具有一些不应该让展示层知道的数据<br>DO具有业务方法，如果直接把DO传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于AOP拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用DO的业务方法也会因为事务的问题，让事务难以控制。<br>对于某些ORM框架（如Hibernate）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。<br>从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把DO暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。<br>　　对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”，举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”。笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。</p><h3 id="DO与PO的区别"><a href="#DO与PO的区别" class="headerlink" title="DO与PO的区别"></a>DO与PO的区别</h3><p>　　DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：</p><p>DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。<br>同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个PO之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个DO——“权限”。<br>某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。例如客户Customer有其联系信息Contacts，这里是两个一对一关系的DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把Customer和Contacts两个DO数据合并到一张数据表中。反过来，如果一本图书Book，有一个属性是封面cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把cover一并加载，从而减轻磁盘IO开销，同时假设ORM框架不支持属性级别的延迟加载，那么就需要考虑把cover独立到一张数据表中去，这样就形成一个DO对应多个PO的情况。<br>PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。</p><h3 id="DO与PO的应用"><a href="#DO与PO的应用" class="headerlink" title="DO与PO的应用"></a>DO与PO的应用</h3><p>　　由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：</p><p>对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在JPA中，可以利用@Transient声明。<br>对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get/set方法私有化，甚至不提供get/set方法。但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。<br>对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持，请参考Hibnate的相关资料。</p><h2 id="领域模型命名规约："><a href="#领域模型命名规约：" class="headerlink" title="领域模型命名规约："></a>领域模型命名规约：</h2><ul><li><p>数据对象：xxxDO，xxx 即为数据表名。</p></li><li><p>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p></li><li><p>展示对象：xxxVO，xxx 一般为网页名称。</p></li><li><p>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c8dc950ea9064495b2f9a18e4b75adce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;有哪些-O&quot;&gt;&lt;a href=&quot;#有哪些-O&quot; class=&quot;headerlink&quot; title=&quot;有哪些 O&quot;&gt;&lt;/a&gt;有哪些 O&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://quanluo.github.io/tags/Java/"/>
    
      <category term="分层模型规范" scheme="http://quanluo.github.io/tags/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>（力扣）5. 最长回文子串 C++（中心扩散法）解题击败100%用户</title>
    <link href="http://quanluo.github.io/2021/09/17/%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%895-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-C-%EF%BC%88%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95%EF%BC%89%E8%A7%A3%E9%A2%98%E5%87%BB%E8%B4%A5100-%E7%94%A8%E6%88%B7/"/>
    <id>http://quanluo.github.io/2021/09/17/%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%895-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-C-%EF%BC%88%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95%EF%BC%89%E8%A7%A3%E9%A2%98%E5%87%BB%E8%B4%A5100-%E7%94%A8%E6%88%B7/</id>
    <published>2021-09-17T11:08:49.000Z</published>
    <updated>2021-09-17T11:11:07.116Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/3c0c1e12abc9404f9542b7a25ac77f11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><a id="more"></a><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"babad"</span></span><br><span class="line">输出：<span class="string">"bab"</span></span><br><span class="line">解释：<span class="string">"aba"</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cbbd"</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"a"</span></span><br><span class="line">输出：<span class="string">"a"</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母（大写和/或小写）组成</p><h1 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h1><h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>我们是以每一个字符为中心，往两边扩散，来求最长的回文子串。</p><p>我们来思考这样一个问题，如果是单个字符，我们可以认为他是回文子串，如果是多个字符，并且他们都是相同的，那么他们也是回文串。所以对于上面的问题，我们以当前字符为中心往两边扩散的时候，先要判断和他挨着的有没有相同的字符，如果有，则跳过继续判断下一个，<br>根据这个思路，我们来写下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取字符串s的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = s.size(); </span><br><span class="line">        <span class="comment">// 设置回文子串起始位置和字串长度的初始值</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; )&#123;</span><br><span class="line">            <span class="comment">// 判断剩余字串长度小于当前回文字串的长度，则直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(length - i &lt; maxlen / <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="comment">// 过滤掉重复的字符</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; length - <span class="number">1</span> &amp;&amp; s[right + <span class="number">1</span>] == s[right])&#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下次循环是直接从重复的下一个位置开始判断</span></span><br><span class="line">            i = right + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 往两边开始扩散，求回文字串长度</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; length <span class="number">-1</span> &amp;&amp; left &gt; <span class="number">0</span> &amp;&amp; s[left - <span class="number">1</span>] == s[right + <span class="number">1</span>])&#123;</span><br><span class="line">                --left;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求出最长回文字串长度和起始位置</span></span><br><span class="line">            <span class="keyword">if</span>(right - left + <span class="number">1</span> &gt; maxlen)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                maxlen = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最长回文字串</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/3c0c1e12abc9404f9542b7a25ac77f11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://quanluo.github.io/tags/C/"/>
    
      <category term="算法" scheme="http://quanluo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣" scheme="http://quanluo.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac安装Adobe软件的时候，总是提示安装包（软件）“可能损坏了”的问题</title>
    <link href="http://quanluo.github.io/2021/09/09/%E8%A7%A3%E5%86%B3Mac%E5%AE%89%E8%A3%85Adobe%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%BB%E6%98%AF%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E2%80%9C%E5%8F%AF%E8%83%BD%E6%8D%9F%E5%9D%8F%E4%BA%86%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://quanluo.github.io/2021/09/09/%E8%A7%A3%E5%86%B3Mac%E5%AE%89%E8%A3%85Adobe%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%BB%E6%98%AF%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E2%80%9C%E5%8F%AF%E8%83%BD%E6%8D%9F%E5%9D%8F%E4%BA%86%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-09T03:00:15.000Z</published>
    <updated>2021-09-09T03:02:17.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题："><a href="#Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：" class="headerlink" title="Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题："></a>Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：</h3><p><img src="https://img-blog.csdnimg.cn/9d9a48d9d237460385a9aca3de2df473.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><a id="more"></a><p>一直提示<strong>Error The installation cannot continue as the installer file may be damaged. Download the installer file again.</strong></p><p>这是怎么回事呢？<br>首先先看一下中文翻译是什么：<br>错误：</p><p><strong>安装不能继续了，因为安装包（软件）可能损坏了。请重新下载安装包。</strong></p><p>看意思是安装包损坏了，需要重新下载安装，但是，如果你去这么做了，那么你会发现还是会出现这个错误。<br>因此，报着个错误，并不一定真的是安装包损坏了，你<strong>并不需要重新下载安装包的。</strong><br><strong>那他的解决办法是什么呢？</strong><br>请看下面：<br>其实这个问题，我们在安装adobe软件的时候都会遇到。这里呢，我们就以PS为例吧。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="1-首先，我们打开安装包："><a href="#1-首先，我们打开安装包：" class="headerlink" title="1.首先，我们打开安装包："></a>1.首先，我们打开安装包：</h4><p><img src="https://img-blog.csdnimg.cn/8c5cb608be9c453fba9f4d4b717027b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="2-然后，我们找到install-app这个文件，右键-显示包内容"><a href="#2-然后，我们找到install-app这个文件，右键-显示包内容" class="headerlink" title="2.然后，我们找到install.app这个文件，右键-显示包内容"></a>2.然后，我们找到install.app这个文件，右键-显示包内容</h4><p><img src="https://img-blog.csdnimg.cn/d9cec462a69c4928863ca7789e1a0219.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="3-点击Contants，进入文件夹里"><a href="#3-点击Contants，进入文件夹里" class="headerlink" title="3.点击Contants，进入文件夹里"></a>3.点击Contants，进入文件夹里<img src="https://img-blog.csdnimg.cn/0b9455d75feb455f8df9e5f9b4c8fbfd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></h4><h4 id="4-点击MacOS文件，进入文件夹里"><a href="#4-点击MacOS文件，进入文件夹里" class="headerlink" title="4. 点击MacOS文件，进入文件夹里"></a>4. 点击MacOS文件，进入文件夹里</h4><p><img src="https://img-blog.csdnimg.cn/20552d74e9c24e87a8ce56bde9aba192.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="5-最后，点击Install，好了，现在可以正常安装了。"><a href="#5-最后，点击Install，好了，现在可以正常安装了。" class="headerlink" title="5.最后，点击Install，好了，现在可以正常安装了。"></a>5.最后，点击Install，好了，现在可以正常安装了。</h4><p><img src="https://img-blog.csdnimg.cn/2d2b258b515b4132ac46df19dc3efe1b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="以上，解决问题。"><a href="#以上，解决问题。" class="headerlink" title="以上，解决问题。"></a>以上，解决问题。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&quot;&gt;&lt;a href=&quot;#Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&quot; class=&quot;headerlink&quot; title=&quot;Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&quot;&gt;&lt;/a&gt;Mac电脑在安装Adobe产品软件的时候，可能会遇到这样一个问题：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/9d9a48d9d237460385a9aca3de2df473.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="Adobe" scheme="http://quanluo.github.io/tags/Adobe/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+yilia+Github实现相册功能（超详细）</title>
    <link href="http://quanluo.github.io/2021/09/09/Hexo-yilia-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"/>
    <id>http://quanluo.github.io/2021/09/09/Hexo-yilia-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/</id>
    <published>2021-09-08T16:28:25.000Z</published>
    <updated>2021-09-08T16:37:07.338Z</updated>
    
    <content type="html"><![CDATA[<ul><li>效果图：<br><img src="https://img-blog.csdnimg.cn/25b825b4e1884dffbe5ce9aba71e8485.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>最终效果请看这里：<a href="https://quanluo.github.io/">quanluo.github.io</a></li></ul><h3 id="一、目的："><a href="#一、目的：" class="headerlink" title="一、目的："></a>一、目的：</h3><ul><li>为博客添加相册功能</li><li>通过GitHub来实现相册功能</li></ul><a id="more"></a> <h3 id="二、方案"><a href="#二、方案" class="headerlink" title="二、方案"></a>二、方案</h3><ol><li>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理</li><li>将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出</li><li>修改代码（大佬写好的）</li><li>使用py脚本压缩图片生成略缩图<h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h3><h4 id="1-博客页面添加相册"><a href="#1-博客页面添加相册" class="headerlink" title="1.博客页面添加相册"></a>1.博客页面添加相册</h4></li></ol><ul><li>通过cmd/终端进入你的博客blog的source目录下，通过 ==hexo new page “photos”== 命令创建<strong>photos</strong>文件夹，代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd blog</span><br><span class="line">&gt; cd source</span><br><span class="line">&gt; hexo new page <span class="string">"photos"</span></span><br></pre></td></tr></table></figure><h4 id="2-GitHub操作"><a href="#2-GitHub操作" class="headerlink" title="2.GitHub操作"></a>2.GitHub操作</h4></li><li>建立一个用于存储相册的仓库，我这里建立了名为<strong>Blog-Picture</strong>的仓库<br><img src="https://img-blog.csdnimg.cn/d87454ddfa334fe9991eafce2f0748e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>在创建完远端仓库后，将本地与github上远端仓库关联，这样我们以后才能够将图片推送到远端。<br>远端仓库与本地仓库关联的方法:<br>打开博客文件夹，在此根目录下，使用git ,即 git Bush Here,然后输入:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone git@github.com:quanluo/Blog-Picture.git</span><br></pre></td></tr></table></figure></li><li>其中<strong>clone</strong>的仓库换成自己的仓库地址。这样便能使本地与远端关联起立。此刻，会产生一个<code>Blog-Picture</code>的文件夹，在此文件夹下分别创建<code>min_photos</code>、<code>photos</code>文件夹。<br><img src="https://img-blog.csdnimg.cn/a523127e113c4d39a56744b371e835d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="3-修改代码"><a href="#3-修改代码" class="headerlink" title="3.修改代码"></a>3.修改代码</h4></li><li>在GitHub上下载代码：<a href="https://github.com/lawlite19/Blog-Back-Up/tree/master/blog_photos_copy" target="_blank" rel="noopener">源代码</a><br><img src="https://img-blog.csdnimg.cn/7a69e4a79ade46aaa38866327d199d33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>删除其中的<code>data.json</code>文件。因为，后面的<code>.json</code>文件是我们自己博客在上传图片时生成的.</li><li>修改index.ejs。这一步很重要，我自己查百度和相关博文时，都没有提到这一步。将其中的href修改成自己的博客地址。当初我就没有修改，最终，显示出来的永远都是原作者的相册.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &lt;div class="instagram itemscope"&gt;</span><br><span class="line">    &lt;a href="https://quanluo.github.io/" target="_blank" class="open-ins"&gt;图片正在加载中…&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>修改ins.js文件里的render()函数，按照上面的注释提醒，进行修改。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 修改这里render()函数：修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径)</span><br><span class="line">    // https://raw.githubusercontent.com/quanluo/Blog-Picture/master/min_photos/</span><br><span class="line">    //https://raw.githubusercontent.com/quanluo/Blog-Picture/master/photos/</span><br><span class="line">    var render = function render(res) &#123;</span><br><span class="line">      var ulTmpl = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">for</span> (var j = <span class="number">0</span>, len2 = res.list.length; j &lt; len2; j++) &#123;</span><br><span class="line">        var data = res.list[j].arr;</span><br><span class="line">        var liTmpl = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>, len = data.link.length; i &lt; len; i++) &#123;</span><br><span class="line">          var minSrc = <span class="string">'https://raw.githubusercontent.com/quanluo/Blog-Picture/master/min_photos/'</span> + data.link[i];</span><br><span class="line">          var src = <span class="string">'https://raw.githubusercontent.com/quanluo/Blog-Picture/master/photos/'</span> + data.link[i];</span><br><span class="line">          var type = data.type[i];</span><br><span class="line">          var target = src + (type === 'video' ? '.mp4' : '.jpg');</span><br><span class="line">          src += <span class="string">''</span>;</span><br></pre></td></tr></table></figure><h6 id="注意-第一个容易出错的地方-："><a href="#注意-第一个容易出错的地方-：" class="headerlink" title="注意(第一个容易出错的地方)："></a><font color=red>注意(第一个容易出错的地方)：</font></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var minSrc = <span class="string">'https://raw.githubusercontent.com/lawlite19/blog-back-up/master/min_photos/'</span> + data.link[i]; </span><br><span class="line">var src = <span class="string">'https://raw.githubusercontent.com/lawlite19/blog-back-up/master/photos/'</span> + data.link[i];</span><br></pre></td></tr></table></figure><p>这个链接很多人输入错了，不是直接的图片url，是需要点“下载”才能看到的url。<br><img src="https://img-blog.csdnimg.cn/f179315748604e0da0f137396f4a4caf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/657298f08cec420ea49713a538f090de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="4-添加脚本"><a href="#4-添加脚本" class="headerlink" title="4. 添加脚本"></a>4. 添加脚本</h4><ul><li>这里添加的python脚本主要是用于处理图片。脚本下载-  <a href="https://github.com/ChemLez/blog-Picture" target="_blank" rel="noopener">下载地址</a>.</li><li><ul><li>1.将其中的.py文件拷贝至本地仓库<strong>Blog-Picture</strong>文件夹中.</li></ul></li><li><ul><li>2.根据脚本文件，图片的命名规则为：xxxx-xx-xx_name.jpg/png.<br><font color=red>注意：你要保存的和上传的图片放的地址在<strong>Blog-Picture</strong>文件夹下<strong>photos</strong>文件夹里</font><br><img src="https://img-blog.csdnimg.cn/090a9237d91b45219078b5ca20c3f394.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/c9a7d98cae4647a5ab11ba68bc68cffe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> – 3.将图片<a href="https://raw.githubusercontent.com/quanluo/quanluo.github.io/master/assets/img/empty.png" target="_blank" rel="noopener">empty.png</a>下载放入博客目录下的assets/img文件夹中.</p><h5 id="注意-第二个错误地方-重点-：如果没有这一步可能缩略图显示不出来"><a href="#注意-第二个错误地方-重点-：如果没有这一步可能缩略图显示不出来" class="headerlink" title="注意(第二个错误地方-重点)：如果没有这一步可能缩略图显示不出来"></a><font color=red>注意(第二个错误地方-重点)：如果没有这一步可能缩略图显示不出来</font></h5><p>首先，去下载“empty.png” ,直接右键另存，保存为“empty.png”。名字也要一样，别问为什么，实现了，自己再去看源码。<br>在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。我的结果如下：<br>    <img src="https://img-blog.csdnimg.cn/1a0d219e44394b1c9ee01e72cd0274dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>– 4.打开tool.py文件,修改def handle_photo():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"../lawlite19.github.io/source/photos/data.json"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(final_dict, fp)</span><br></pre></td></tr></table></figure><p>将其中的的地址，换成你将要生成data.json的位置，就是在第一步中，我们删除的.json文件夹的目录地址。每次，进行tool.py脚本时，都会产生data.json文件，用于存储我们图片的信息。</p><h4 id="5-运行脚本"><a href="#5-运行脚本" class="headerlink" title="5.运行脚本"></a>5.运行脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&gt; cd Blog-Picture <span class="comment">#用于进入Blog-Picture文件夹</span></span><br><span class="line">&gt; python tool.py <span class="comment">#python脚本文件的运行</span></span><br><span class="line">&gt; </span><br><span class="line"><span class="comment"># 第二句的运行这里可能会报错 `no module named PIL`</span></span><br><span class="line"><span class="comment">#如果报错然输入下面代码：</span></span><br><span class="line">pip install pillow</span><br><span class="line"><span class="comment">#可能出现权限不足的情况，按照下方出现的英文，加上权限进行下载。即：一路按照下方的英文,加权限进行下载.</span></span><br></pre></td></tr></table></figure><h5 id="注意：每次上传照片都需要运行python脚本"><a href="#注意：每次上传照片都需要运行python脚本" class="headerlink" title="注意：每次上传照片都需要运行python脚本"></a><font color=red>注意：每次上传照片都需要运行python脚本</font></h5><p>需要安装python环境，在命令行运行py tool.py命令。</p><h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h4><ul><li>在blog根目录下，输入代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hexo s</span><br></pre></td></tr></table></figure><ul><li>进行预览查看。<br><img src="https://img-blog.csdnimg.cn/168fb7640901418387e03651a40004d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>测试成功，进行blog远端部署：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hexo clean <span class="comment">#清除页面缓存</span></span><br><span class="line">&gt; hexo g -d <span class="comment"># 进行远端部署</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="OK！！！完美！！！大功告成！！！"><a href="#OK！！！完美！！！大功告成！！！" class="headerlink" title="OK！！！完美！！！大功告成！！！"></a>OK！！！完美！！！大功告成！！！</h3>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;效果图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/25b825b4e1884dffbe5ce9aba71e8485.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/li&gt;
&lt;li&gt;最终效果请看这里：&lt;a href=&quot;https://quanluo.github.io/&quot;&gt;quanluo.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;一、目的：&quot;&gt;&lt;a href=&quot;#一、目的：&quot; class=&quot;headerlink&quot; title=&quot;一、目的：&quot;&gt;&lt;/a&gt;一、目的：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为博客添加相册功能&lt;/li&gt;
&lt;li&gt;通过GitHub来实现相册功能&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://quanluo.github.io/tags/hexo/"/>
    
      <category term="yilia" scheme="http://quanluo.github.io/tags/yilia/"/>
    
      <category term="相册" scheme="http://quanluo.github.io/tags/%E7%9B%B8%E5%86%8C/"/>
    
      <category term="github" scheme="http://quanluo.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>ModuleNotFoundError: No module named ‘sklearn.cross_validation‘解决办法</title>
    <link href="http://quanluo.github.io/2021/09/07/ModuleNotFoundError-No-module-named-%E2%80%98sklearn-cross-validation%E2%80%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://quanluo.github.io/2021/09/07/ModuleNotFoundError-No-module-named-%E2%80%98sklearn-cross-validation%E2%80%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-09-07T04:15:52.000Z</published>
    <updated>2021-09-08T05:13:05.375Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/c79eab1ebf3b47b1882ab5b3f18fb6b1.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>在Python机器学习中，会用到使用<font color=red> <strong>scikit-learn</strong> </font>中的<font color=red><strong>train_test_split</strong></font>函数，把数据集切分为训练集和测试集。</p><a id="more"></a> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><p>用后发现会报错==ModuleNotFoundError==<br><img src="https://img-blog.csdnimg.cn/151d1d7378894840bd50590e48bfa38b.png" alt="在这里插入图片描述"></p><h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p> <strong>这个cross_validatio这个包早就不在使用了，划分到了model_selection这个包中。</strong></p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>使用下方导入模块代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c79eab1ebf3b47b1882ab5b3f18fb6b1.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Python机器学习中，会用到使用&lt;font color=red&gt; &lt;strong&gt;scikit-learn&lt;/strong&gt; &lt;/font&gt;中的&lt;font color=red&gt;&lt;strong&gt;train_test_split&lt;/strong&gt;&lt;/font&gt;函数，把数据集切分为训练集和测试集。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://quanluo.github.io/tags/Python/"/>
    
      <category term="sklearn" scheme="http://quanluo.github.io/tags/sklearn/"/>
    
      <category term="机器学习" scheme="http://quanluo.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MacOS下安装R语言和RStudio教程（超完整）</title>
    <link href="http://quanluo.github.io/2021/08/30/MacOS%E4%B8%8B%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8CRStudio%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E5%AE%8C%E6%95%B4%EF%BC%89/"/>
    <id>http://quanluo.github.io/2021/08/30/MacOS%E4%B8%8B%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80%E5%92%8CRStudio%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E5%AE%8C%E6%95%B4%EF%BC%89/</id>
    <published>2021-08-30T03:44:15.000Z</published>
    <updated>2021-08-30T03:55:59.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前提"><a href="#一、前提" class="headerlink" title="一、前提"></a>一、前提</h1><p>安装顺序（不能颠倒）：<br>1、R语言<br>2、RStudio<br>注：R是RStudio的基础，必须先安装R，在安装RStudio。<br><img src="https://img-blog.csdnimg.cn/f6a19ca8c1244f4e9d1ea31d5027443b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><h1 id="二、R语言安装"><a href="#二、R语言安装" class="headerlink" title="二、R语言安装"></a>二、R语言安装</h1><p>1.官网安装包下载地址：<a href="https://cran.r-project.org/" target="_blank" rel="noopener">https://cran.r-project.org/</a>.<br>2.点击MacOS对应选项，下方红框标出的地方<br><img src="https://img-blog.csdnimg.cn/184e5e7ea2e042c6913d4bbadfba31d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3.在下载界面，点击base，下方红框标出的地方<br><img src="https://img-blog.csdnimg.cn/8a0adb83c1744309bbd5e15414f787c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>4.自行选择下载R语言版本，我下载的是（R-4.0.4.pkg版本的）<br><img src="https://img-blog.csdnimg.cn/ab288d691d594474a3a1fa80c4b47c0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>5.下载完成，在“Finder-&gt;下载”中点击pkg文件，一直按下一步就可安装完成。</p><h1 id="三、RStudio安装"><a href="#三、RStudio安装" class="headerlink" title="三、RStudio安装"></a>三、RStudio安装</h1><p>1.官网安装包下载地址：<a href="https://www.rstudio.com/products/rstudio/download/#download" target="_blank" rel="noopener">https://www.rstudio.com/products/rstudio/download/#download</a><br>2.点击下方红色标出地方，直接下载<br><img src="https://img-blog.csdnimg.cn/d7d3b4c2256147f4a641fd96c6003857.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>3. 下载完成，在“Finder-&gt;下载”中点击dmg文件，将app拖入mac的application中即可。</p><h1 id="到此，安装全部完成。"><a href="#到此，安装全部完成。" class="headerlink" title="到此，安装全部完成。"></a>到此，安装全部完成。</h1><h1 id="四、可能会遇到的问题："><a href="#四、可能会遇到的问题：" class="headerlink" title="四、可能会遇到的问题："></a>四、可能会遇到的问题：</h1><h2 id="关于macOS：在Mac上安装R-警告消息：使用“-C”设置LC-CTYPE失败"><a href="#关于macOS：在Mac上安装R-警告消息：使用“-C”设置LC-CTYPE失败" class="headerlink" title="关于macOS：在Mac上安装R-警告消息：使用“ C”设置LC_CTYPE失败"></a>关于macOS：在Mac上安装R-警告消息：使用“ C”设置LC_CTYPE失败</h2><blockquote><p>Installing R on Mac - Warning messages: Setting LC_CTYPE failed, using “C”</p></blockquote><h3 id="错误是："><a href="#错误是：" class="headerlink" title="错误是："></a>错误是：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">During startup - Warning messages:</span><br><span class="line">1: Setting LC_CTYPE failed, using&quot;C&quot;</span><br><span class="line">2: Setting LC_COLLATE failed, using&quot;C&quot;</span><br><span class="line">3: Setting LC_TIME failed, using&quot;C&quot;</span><br><span class="line">4: Setting LC_MESSAGES failed, using&quot;C&quot;</span><br><span class="line">5: Setting LC_PAPER failed, using&quot;C&quot;</span><br><span class="line">[R.app GUI 1.50 (6126) x86_64-apple-darwin9.8.0]</span><br><span class="line"></span><br><span class="line">WARNING: You&#39;re using a non-UTF8 locale, therefore only ASCII characters will work.</span><br><span class="line">Please read R for Mac OS X FAQ (see Help) section 9 and adjust your system preferences accordingly.</span><br><span class="line">[History restored from &#x2F;Users&#x2F;nemo&#x2F;.Rapp.history]</span><br></pre></td></tr></table></figure><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ul><li>开放终端</li><li>写入或粘贴：defaults write org.R-project.R force.LANG en_US.UTF-8</li><li>关闭终端(包括任何RStudio窗口)</li><li>开始R</li></ul><h1 id="五、在RStudio中创建新项目"><a href="#五、在RStudio中创建新项目" class="headerlink" title="五、在RStudio中创建新项目"></a>五、在RStudio中创建新项目</h1><p>1.创建新project。具体方法如下图所示，依次点击 File-&gt;New Project =&gt; New Directory-&gt;New Project-&gt;输入Derectory name（注意要用英文，别用中文）<br><img src="https://img-blog.csdnimg.cn/8e37f9bedb7145009422922d93d362a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/8b8dd43882844a2b8e66c1c61cc5bbd0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/244d2cf481014cb98e54763fe145e4de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/087a5ec9eef44f029e5412b19694edc3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.创建好，就会出现如下界面<br><img src="https://img-blog.csdnimg.cn/8464b7605c364747bf6564860a1856b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="六、测试R"><a href="#六、测试R" class="headerlink" title="六、测试R"></a>六、测试R</h1><p>1.在《R语言实战》中有一个新手测试代码，我们可以测试下我们安装的R语言环境</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; age &lt;- c(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>)</span><br><span class="line">&gt; weight &lt;- c(<span class="number">4.4</span>, <span class="number">5.3</span>, <span class="number">7.2</span>, <span class="number">5.2</span>, <span class="number">8.5</span>, <span class="number">7.3</span>, <span class="number">6.0</span>, <span class="number">10.4</span>, <span class="number">10.2</span>, <span class="number">6.1</span>)</span><br><span class="line">&gt; mean(weight)</span><br><span class="line">&gt; sd(weight)</span><br><span class="line">&gt; cor(age, weight)</span><br><span class="line">&gt; plot(age, weight)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e9e2eb9d673e4c879fd3f3b454402d2d.PNG?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>2.测试结果：<br><img src="https://img-blog.csdnimg.cn/298c01ce858b464fa4f6544f51a65914.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前提&quot;&gt;&lt;a href=&quot;#一、前提&quot; class=&quot;headerlink&quot; title=&quot;一、前提&quot;&gt;&lt;/a&gt;一、前提&lt;/h1&gt;&lt;p&gt;安装顺序（不能颠倒）：&lt;br&gt;1、R语言&lt;br&gt;2、RStudio&lt;br&gt;注：R是RStudio的基础，必须先安装R，在安装RStudio。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/f6a19ca8c1244f4e9d1ea31d5027443b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWoIOa0mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="R语言" scheme="http://quanluo.github.io/tags/R%E8%AF%AD%E8%A8%80/"/>
    
      <category term="RStudio" scheme="http://quanluo.github.io/tags/RStudio/"/>
    
  </entry>
  
  <entry>
    <title>我的个人博客live2d插件模型模块汇总（仅本人可使用，无需看）</title>
    <link href="http://quanluo.github.io/2021/08/25/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2live2d%E6%8F%92%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9D%97%E6%B1%87%E6%80%BB%EF%BC%88%E4%BB%85%E6%9C%AC%E4%BA%BA%E5%8F%AF%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%97%A0%E9%9C%80%E7%9C%8B%EF%BC%89/"/>
    <id>http://quanluo.github.io/2021/08/25/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2live2d%E6%8F%92%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9D%97%E6%B1%87%E6%80%BB%EF%BC%88%E4%BB%85%E6%9C%AC%E4%BA%BA%E5%8F%AF%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%97%A0%E9%9C%80%E7%9C%8B%EF%BC%89/</id>
    <published>2021-08-25T14:42:22.000Z</published>
    <updated>2021-08-25T14:43:46.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。"><a href="#这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。" class="headerlink" title="这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。"></a>这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。</h3><h3 id="所以看到这的可以退出这篇文章了！！！"><a href="#所以看到这的可以退出这篇文章了！！！" class="headerlink" title="所以看到这的可以退出这篇文章了！！！"></a>所以看到这的可以退出这篇文章了！！！</h3><blockquote><p>shizuku</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c29020544f7f4cd08023f69fc834bcd2.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><a id="more"></a><blockquote><p>nipsilon</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8483bf76d01a4fd3bdc3d2e5043cce03.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>nito</p></blockquote><p><img src="https://img-blog.csdnimg.cn/daf2b153d42442f5b875cedfb3979b3b.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>nico</p></blockquote><p><img src="https://img-blog.csdnimg.cn/9c23817f960f478d953938c5e8e07f0c.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>ni-j</p></blockquote><p><img src="https://img-blog.csdnimg.cn/1b50575a90ee423d8e1357089d76ce3e.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>haru</p></blockquote><p><img src="https://img-blog.csdnimg.cn/5aa52c5b2a1347c9b67777aa7749049f.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>haruto</p></blockquote><p><img src="https://img-blog.csdnimg.cn/3e437aec659247078867860c443627e1.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>tsumiki</p></blockquote><p><img src="https://img-blog.csdnimg.cn/32186439fd544f55b50d8060067a3b4d.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>z16</p></blockquote><p><img src="https://img-blog.csdnimg.cn/db6c72d556e049bb9dca9623f2bae64e.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>tororo</p></blockquote><p><img src="https://img-blog.csdnimg.cn/baec5fada2f14ac281c0d88f14210309.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>koharu</p></blockquote><p><img src="https://img-blog.csdnimg.cn/6c084a0b36974d81b5b11853e4631960.gif#pic_center" alt="在这里插入图片描述"><br>   ————————<strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong>————————</p><blockquote><p>hijiki</p></blockquote><p><img src="https://img-blog.csdnimg.cn/08d4712b26404f329dfcdd7c880aae63.gif#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&quot;&gt;&lt;a href=&quot;#这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&quot; class=&quot;headerlink&quot; title=&quot;这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&quot;&gt;&lt;/a&gt;这篇文章存粹是我用来记录我自己的个人博客live2d插件模块下载后可使用和替换的。以防我到时候会忘掉。&lt;/h3&gt;&lt;h3 id=&quot;所以看到这的可以退出这篇文章了！！！&quot;&gt;&lt;a href=&quot;#所以看到这的可以退出这篇文章了！！！&quot; class=&quot;headerlink&quot; title=&quot;所以看到这的可以退出这篇文章了！！！&quot;&gt;&lt;/a&gt;所以看到这的可以退出这篇文章了！！！&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;shizuku&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/c29020544f7f4cd08023f69fc834bcd2.gif#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;   ————————&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;*****&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;————————&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://quanluo.github.io/tags/hexo/"/>
    
      <category term="live2d" scheme="http://quanluo.github.io/tags/live2d/"/>
    
  </entry>
  
  <entry>
    <title>mac下 Github添加SSH keys</title>
    <link href="http://quanluo.github.io/2021/08/16/mac%E4%B8%8B-Github%E6%B7%BB%E5%8A%A0SSH-keys/"/>
    <id>http://quanluo.github.io/2021/08/16/mac%E4%B8%8B-Github%E6%B7%BB%E5%8A%A0SSH-keys/</id>
    <published>2021-08-16T14:17:18.000Z</published>
    <updated>2021-08-19T10:36:55.598Z</updated>
    
    <content type="html"><![CDATA[<p>注：封面背景在文章最后面。</p><h2 id="一、首先测试下是否有原先有添加过公钥"><a href="#一、首先测试下是否有原先有添加过公钥" class="headerlink" title="一、首先测试下是否有原先有添加过公钥"></a>一、首先测试下是否有原先有添加过公钥</h2><p>我们用下面的代码在终端去测试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5071fdab2b8b40b59d2da538dcefca61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上，如果显示，==Permission denied(publickey)==  这就表示缺少公钥。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/7a1f4c19940b4d20b37c35908fa8b752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上，如果显示 ==You’ve successfully authenticated== 这就表明公钥添加成功了。</p><h2 id="二、进入正题，没有SSH-keys-公钥，请看下方详细mac下-Github添加SSH-keys步骤"><a href="#二、进入正题，没有SSH-keys-公钥，请看下方详细mac下-Github添加SSH-keys步骤" class="headerlink" title="二、进入正题，没有SSH keys 公钥，请看下方详细mac下 Github添加SSH keys步骤:"></a>二、进入正题，没有SSH keys 公钥，请看下方详细<code>mac下 Github添加SSH keys</code>步骤:</h2><h3 id="1-在本地创建SSH-keys"><a href="#1-在本地创建SSH-keys" class="headerlink" title="1.在本地创建SSH keys"></a>1.在本地创建SSH keys</h3><p>打开终端，输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"xxx@xx.com"</span></span><br><span class="line"><span class="comment">#  “”里面替换成你的GitHub账户登陆邮箱</span></span><br></pre></td></tr></table></figure><p>接着出面下面文字提示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Oct <span class="number">31</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">24</span> on ttys004</span><br><span class="line">bogon:~ YYKit$ ssh-keygen -t rsa -C <span class="string">"xxx@xxx.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/xx/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>不用管它，直接回车，中间会让输入两次密码，什么都不输入，继续回车，会出现如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Oct <span class="number">31</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">24</span> on ttys004</span><br><span class="line">bogon:~ YYKit$ ssh-keygen -t rsa -C <span class="string">"xxxx@xxx.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which to save the key (/Users/xx/.ssh/id_rsa): </span><br><span class="line">/Users/xx/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/xx/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/xx/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint <span class="keyword">is</span>:</span><br><span class="line">SHA256:rp+<span class="number">6</span>MLo27uTIONMqlO6/E9d9CvJzvVt5QI9I6Z2vy14 <span class="number">468466882</span>@qq.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|            .    |</span></span><br><span class="line"><span class="string">|           o .   |</span></span><br><span class="line"><span class="string">|          o + +  |</span></span><br><span class="line"><span class="string">|  .   . S  o = . |</span></span><br><span class="line"><span class="string">| o . o + . .  +  |</span></span><br><span class="line"><span class="string">|o.. = o o +  o E |</span></span><br><span class="line"><span class="string">|*=+o o + + .o +  |</span></span><br><span class="line"><span class="string">|*XB=o ++=  o+=.  |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">bogon:~ YYKit$</span></span><br></pre></td></tr></table></figure><h3 id="2-复制创建好的SSH-keys到GitHub上"><a href="#2-复制创建好的SSH-keys到GitHub上" class="headerlink" title="2.复制创建好的SSH keys到GitHub上"></a>2.复制创建好的SSH keys到GitHub上</h3><p>这时候，==SSH keys==就创建完了，然后我们需要前往文件夹复制/Users/xxx/.ssh/id_rsa.pub地址下文件==id_rsa.pub==里面的==key==了，</p><p><code>打开id_rsa.pub,复制&quot;xxx@xx.com&quot;之前的部分。</code></p><p>复制完，这时候，来到Github，在你的个人账户中，<br>按照顺序依次点击<br>“Settings –&gt; SSH and GPG keys –&gt; SSH keys –&gt; New SSH Key”,<br>Title可以写自己喜欢的标记，<br>在Key下面粘贴之前复制的内容,然后点击Add SSH Key，<br>这就就添加成功了。<br><img src="https://img-blog.csdnimg.cn/6d44bb4b703040cda898ecc0427d8512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-最后测试是否添加成功SSH-keys"><a href="#3-最后测试是否添加成功SSH-keys" class="headerlink" title="3.最后测试是否添加成功SSH keys"></a>3.最后测试是否添加成功SSH keys</h3><p>我们再次测试下公钥有没有添加成功：<br>在终端中，输入代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a1f4c19940b4d20b37c35908fa8b752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上，如果显示 ==You’ve successfully authenticated== 这就表明公钥添加成功了。</p><h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1><p><img src="https://img-blog.csdnimg.cn/2d626140025744e4849ec1a16271572c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：封面背景在文章最后面。&lt;/p&gt;
&lt;h2 id=&quot;一、首先测试下是否有原先有添加过公钥&quot;&gt;&lt;a href=&quot;#一、首先测试下是否有原先有添加过公钥&quot; class=&quot;headerlink&quot; title=&quot;一、首先测试下是否有原先有添加过公钥&quot;&gt;&lt;/a&gt;一、首先测试下是否有原先有添加过公钥&lt;/h2&gt;&lt;p&gt;我们用下面的代码在终端去测试下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -T git@github.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/5071fdab2b8b40b59d2da538dcefca61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;如上，如果显示，==Permission denied(publickey)==  这就表示缺少公钥。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="github" scheme="http://quanluo.github.io/tags/github/"/>
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="sshkeys" scheme="http://quanluo.github.io/tags/sshkeys/"/>
    
  </entry>
  
  <entry>
    <title>mac下启动jupyter notebook</title>
    <link href="http://quanluo.github.io/2021/03/03/mac%E4%B8%8B%E5%90%AF%E5%8A%A8jupyter-notebook/"/>
    <id>http://quanluo.github.io/2021/03/03/mac%E4%B8%8B%E5%90%AF%E5%8A%A8jupyter-notebook/</id>
    <published>2021-03-03T03:12:08.000Z</published>
    <updated>2021-09-07T05:50:28.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210303110634532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h3 id="首先打开终端"><a href="#首先打开终端" class="headerlink" title="首先打开终端"></a>首先打开终端</h3><p><img src="https://img-blog.csdnimg.cn/20210303110209276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t%60_70" alt="在这里插入图片描述"></p><h3 id="然后输入start-jupyter-notebook命令"><a href="#然后输入start-jupyter-notebook命令" class="headerlink" title="然后输入start jupyter notebook命令"></a>然后输入start jupyter notebook命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -m IPython notebook</span><br><span class="line"></span><br><span class="line"><span class="comment">### 如果是python3的环境就用下面的命令</span></span><br><span class="line">python3 -m IPython notebook</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210303110501413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="最后浏览器就会自动打开-jupyter-notebook"><a href="#最后浏览器就会自动打开-jupyter-notebook" class="headerlink" title="最后浏览器就会自动打开 jupyter notebook"></a>最后浏览器就会自动打开 jupyter notebook</h3><p><img src="https://img-blog.csdnimg.cn/20210303110634532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210303110634532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://quanluo.github.io/tags/Python/"/>
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="jupyter notebook" scheme="http://quanluo.github.io/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法</title>
    <link href="http://quanluo.github.io/2021/02/17/mysql%E5%9C%A8mac%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%B2%A1%E6%9C%89%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%99%BB%E9%99%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://quanluo.github.io/2021/02/17/mysql%E5%9C%A8mac%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%B2%A1%E6%9C%89%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%99%BB%E9%99%86%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E8%B7%AF%E5%BE%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-02-17T07:02:43.000Z</published>
    <updated>2021-02-17T07:04:17.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法"><a href="#mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法" class="headerlink" title="mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法"></a>mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法</h4><p><img src="https://img-blog.csdnimg.cn/20210217145307423.png" alt="在这里插入图片描述"></p><h4 id="解决办法如下："><a href="#解决办法如下：" class="headerlink" title="解决办法如下："></a>解决办法如下：</h4><a id="more"></a><h3 id="一、打开终端，为Path路径附加MySQL的bin目录"><a href="#一、打开终端，为Path路径附加MySQL的bin目录" class="headerlink" title="一、打开终端，为Path路径附加MySQL的bin目录"></a>一、打开终端，为Path路径附加MySQL的bin目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="string">"$PATH"</span>:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210217145412233.png" alt="在这里插入图片描述"></p><h3 id="二、然后就可以通过以下命令登陆MySQL"><a href="#二、然后就可以通过以下命令登陆MySQL" class="headerlink" title="二、然后就可以通过以下命令登陆MySQL"></a>二、然后就可以通过以下命令登陆MySQL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021021714564471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法&quot;&gt;&lt;a href=&quot;#mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法&quot; class=&quot;headerlink&quot; title=&quot;mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法&quot;&gt;&lt;/a&gt;mysql在mac终端下没有路径不能直接登陆数据库如何添加路径解决办法&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210217145307423.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决办法如下：&quot;&gt;&lt;a href=&quot;#解决办法如下：&quot; class=&quot;headerlink&quot; title=&quot;解决办法如下：&quot;&gt;&lt;/a&gt;解决办法如下：&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="mysql" scheme="http://quanluo.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Python 一键创建依赖包和一键安装依赖包</title>
    <link href="http://quanluo.github.io/2021/01/24/Python-%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%8C%85%E5%92%8C%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85/"/>
    <id>http://quanluo.github.io/2021/01/24/Python-%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%8C%85%E5%92%8C%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85/</id>
    <published>2021-01-23T16:28:28.000Z</published>
    <updated>2021-01-23T16:30:52.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-pip创建依赖包"><a href="#使用-pip创建依赖包" class="headerlink" title="使用 pip创建依赖包"></a>使用 pip创建依赖包</h3><p><code>requirements.txt</code> 用来记录项目所有的依赖包和版本号，只需要一个简单的 pip 命令就能完成。<br>记住在你代码文件夹下创建你这些代码所需要的依赖包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><a id="more"></a><p>会生成的一个<code>requirements.txt</code> 文件内容会像这个样子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alabaster==<span class="number">0.7</span><span class="number">.12</span></span><br><span class="line">anaconda-client==<span class="number">1.7</span><span class="number">.2</span></span><br><span class="line">anaconda-navigator==<span class="number">1.9</span><span class="number">.12</span></span><br><span class="line">anaconda-project==<span class="number">0.8</span><span class="number">.3</span></span><br><span class="line">applaunchservices==<span class="number">0.2</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="然后就可以用来一键安装依赖包了，也只需要一个简单的pip命令就能完成"><a href="#然后就可以用来一键安装依赖包了，也只需要一个简单的pip命令就能完成" class="headerlink" title="然后就可以用来一键安装依赖包了，也只需要一个简单的pip命令就能完成"></a>然后就可以用来一键安装依赖包了，也只需要一个简单的pip命令就能完成</h3><p>记住在你需要依赖的代码文件夹下安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>这种一次性安装 requirements.txt 里面所有的依赖包，真的是非常方便。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用-pip创建依赖包&quot;&gt;&lt;a href=&quot;#使用-pip创建依赖包&quot; class=&quot;headerlink&quot; title=&quot;使用 pip创建依赖包&quot;&gt;&lt;/a&gt;使用 pip创建依赖包&lt;/h3&gt;&lt;p&gt;&lt;code&gt;requirements.txt&lt;/code&gt; 用来记录项目所有的依赖包和版本号，只需要一个简单的 pip 命令就能完成。&lt;br&gt;记住在你代码文件夹下创建你这些代码所需要的依赖包&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip freeze &amp;gt; requirements.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://quanluo.github.io/tags/Python/"/>
    
      <category term="依赖包" scheme="http://quanluo.github.io/tags/%E4%BE%9D%E8%B5%96%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Mac版 WPS尾部空格没有下划线解决</title>
    <link href="http://quanluo.github.io/2020/12/13/Mac%E7%89%88-WPS%E5%B0%BE%E9%83%A8%E7%A9%BA%E6%A0%BC%E6%B2%A1%E6%9C%89%E4%B8%8B%E5%88%92%E7%BA%BF%E8%A7%A3%E5%86%B3/"/>
    <id>http://quanluo.github.io/2020/12/13/Mac%E7%89%88-WPS%E5%B0%BE%E9%83%A8%E7%A9%BA%E6%A0%BC%E6%B2%A1%E6%9C%89%E4%B8%8B%E5%88%92%E7%BA%BF%E8%A7%A3%E5%86%B3/</id>
    <published>2020-12-13T02:56:21.000Z</published>
    <updated>2020-12-13T02:58:17.367Z</updated>
    
    <content type="html"><![CDATA[<p>文件-选项-常规与保存-兼容选项-为尾部空格添加下划线选中即可<br>具体图文步骤如下：</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201213105209815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201213105251227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201213105315937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="文件-选项-常规与保存-兼容选项-为尾部空格添加下划线选中即可"><a href="#文件-选项-常规与保存-兼容选项-为尾部空格添加下划线选中即可" class="headerlink" title="文件-选项-常规与保存-兼容选项-为尾部空格添加下划线选中即可"></a>文件-选项-常规与保存-兼容选项-为尾部空格添加下划线选中即可</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件-选项-常规与保存-兼容选项-为尾部空格添加下划线选中即可&lt;br&gt;具体图文步骤如下：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
      <category term="wps" scheme="http://quanluo.github.io/tags/wps/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac打开应用提示已损坏的办法</title>
    <link href="http://quanluo.github.io/2020/12/01/%E8%A7%A3%E5%86%B3Mac%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%8F%90%E7%A4%BA%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84%E5%8A%9E%E6%B3%95/"/>
    <id>http://quanluo.github.io/2020/12/01/%E8%A7%A3%E5%86%B3Mac%E6%89%93%E5%BC%80%E5%BA%94%E7%94%A8%E6%8F%90%E7%A4%BA%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84%E5%8A%9E%E6%B3%95/</id>
    <published>2020-12-01T02:23:18.000Z</published>
    <updated>2020-12-01T02:25:06.267Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多升级了最新Mac系统的用户在打开一些应用的时候都会出现“应用XX已损坏”的系统提示，安装这些应用的时候总是提示“已损坏，移至废纸篓”这类信息，根本无法打开应用，那么Mac打开应用提示已损坏怎么办？Mac安装软件时提示已损坏怎么办？一起来了解一下！<br><img src="https://img-blog.csdnimg.cn/20201201101149217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h3 id="更新10-15以及新系统应用提示损坏打不开的方法："><a href="#更新10-15以及新系统应用提示损坏打不开的方法：" class="headerlink" title="更新10.15以及新系统应用提示损坏打不开的方法："></a><code>更新10.15以及新系统应用提示损坏打不开的方法：</code></h3><blockquote><p>打开终端(屏幕下方“小火箭”——“其他”——打开“终端”)，在终端中粘贴下面命令：</p></blockquote><p>　　<code>sudo xattr -r -d com.apple.quarantine</code> ,然后输入个空格，再将应用程序目录中的软件拖拽到命令后面，按回车后输入密码执行，比如需要打开sketch应用的命令是：</p><p>　　</p><p><code>sudo xattr -r -d com.apple.quarantine  /Applications/sketch.app/</code></p><p>　　打开应用提示已损坏是因为新系统的原因。新的系统为了加强安全机制，默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。那么怎么解决呢？</p><h4 id="1、首先，打开终端，在系统的Dock栏找到并启动控制台（Launchpad），终端默认在“其他”这个文件夹中。"><a href="#1、首先，打开终端，在系统的Dock栏找到并启动控制台（Launchpad），终端默认在“其他”这个文件夹中。" class="headerlink" title="1、首先，打开终端，在系统的Dock栏找到并启动控制台（Launchpad），终端默认在“其他”这个文件夹中。"></a>1、首先，打开终端，在系统的Dock栏找到并启动控制台（Launchpad），终端默认在“其他”这个文件夹中。</h4><p><img src="https://img-blog.csdnimg.cn/20201201101639801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2、然后，输入代码：sudo-spctl-–master-disable（master前面为两个短横线）注意红框处是空格。"><a href="#2、然后，输入代码：sudo-spctl-–master-disable（master前面为两个短横线）注意红框处是空格。" class="headerlink" title="2、然后，输入代码：sudo spctl –master-disable（master前面为两个短横线）注意红框处是空格。"></a>2、然后，输入代码：sudo spctl –master-disable（master前面为两个短横线）注意红框处是空格。</h4><p><img src="https://img-blog.csdnimg.cn/20201201101657845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按回车输入自己电脑的密码，然后回车（这里输入的密码不会显示出来，实际你已经输入了），输完按下回车即可。<br><img src="https://img-blog.csdnimg.cn/20201201101723489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3、打开系统偏好设置-»-安全性与隐私，若显示任何来源，大功告成。"><a href="#3、打开系统偏好设置-»-安全性与隐私，若显示任何来源，大功告成。" class="headerlink" title="3、打开系统偏好设置 » 安全性与隐私，若显示任何来源，大功告成。"></a>3、打开系统偏好设置 » 安全性与隐私，若显示任何来源，大功告成。</h4><p><img src="https://img-blog.csdnimg.cn/20201201101744658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4、如果还有类似出现下图打不开“xxxx”应用的情况，还可以看下面的处理方法"><a href="#4、如果还有类似出现下图打不开“xxxx”应用的情况，还可以看下面的处理方法" class="headerlink" title="4、如果还有类似出现下图打不开“xxxx”应用的情况，还可以看下面的处理方法"></a>4、如果还有类似出现下图打不开“xxxx”应用的情况，还可以看下面的处理方法</h4><p><img src="https://img-blog.csdnimg.cn/20201201101801390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　在<code>“系统偏好设置—安全性与隐私—通用—允许从以下位置下载的应用”</code>选择“仍要打开”，让系统同意应用运行即可（如下图所示）<br>　<img src="https://img-blog.csdnimg.cn/20201201101824833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>本篇文章转载于：<br>Mac打开应用提示已损坏怎么办 Mac安装软件时提示已损坏怎么办(<a href="http://www.pc6.com/edu/168719.html" target="_blank" rel="noopener">http://www.pc6.com/edu/168719.html</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多升级了最新Mac系统的用户在打开一些应用的时候都会出现“应用XX已损坏”的系统提示，安装这些应用的时候总是提示“已损坏，移至废纸篓”这类信息，根本无法打开应用，那么Mac打开应用提示已损坏怎么办？Mac安装软件时提示已损坏怎么办？一起来了解一下！&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201101149217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>将十进制转换成短浮点数格式（IEEE745）并用十六进制表示（组成原理）</title>
    <link href="http://quanluo.github.io/2020/11/30/%E5%B0%86%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%BC%E5%BC%8F%EF%BC%88IEEE745%EF%BC%89%E5%B9%B6%E7%94%A8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%88%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <id>http://quanluo.github.io/2020/11/30/%E5%B0%86%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9F%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%BC%E5%BC%8F%EF%BC%88IEEE745%EF%BC%89%E5%B9%B6%E7%94%A8%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%88%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%89/</id>
    <published>2020-11-30T02:56:06.000Z</published>
    <updated>2020-11-30T03:00:34.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201130105022993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="IEEE-745-标准中有三种形式的浮点数，具体如下表："><a href="#IEEE-745-标准中有三种形式的浮点数，具体如下表：" class="headerlink" title="IEEE 745 标准中有三种形式的浮点数，具体如下表："></a>IEEE 745 标准中有三种形式的浮点数，具体如下表：</h3><a id="more"></a><p>类型  | 数符 |阶码 | 尾数数值 | 总位数 | 偏置值 |偏置值 |<br>|——– | ——— | —– | —- | —- | —- | —|<br> | | | | | |十六进制 | 十进制<br> | 短浮点数|1 |8 |23 |32 |7FH | 127<br> |长浮点数 |1 |11 |52 |64 |3FFH | 1023<br> |临时浮点数 |1 |15 |64 |80 |3FFFH | 16383</p><h3 id="列题-：将（100-25）十进制转换成短浮点数格式。"><a href="#列题-：将（100-25）十进制转换成短浮点数格式。" class="headerlink" title="列题 ：将（100.25）十进制转换成短浮点数格式。"></a>列题 ：将（100.25）十进制转换成短浮点数格式。</h3><ol><li><p>把十进制转换成二进制。<br> (100.25)十进制 = （1100100.01）二进制</p></li><li><p>规格化二进制<br> 1100100.01 = 1.10010001✖️2^6</p></li><li><p>计算出阶码的移码（偏置值 + 阶码真值） ==阶码真值就是上面2^k 中的k==<br> 127 + 6 = 1111111 + 110 = 10000101</p></li><li><p>以短浮点数格式存储该数<br>因为，<br>符号为 = 0      ==（正数为0，负数为1）==<br>阶码（E） = 10000101<br>尾数 = 1001 0001 0000 0000 0000 000   （==规格化二进制后小数点后面的数然后用零补齐23位数位==）<br>所以，短浮点数代码为：<br>0，1000 0101，1001 0001 0000 0000 0000 000</p><p>表示为十六进制的代码：</p><h3 id="42C88000H"><a href="#42C88000H" class="headerlink" title="42C88000H"></a>42C88000H</h3></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130105022993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;IEEE-745-标准中有三种形式的浮点数，具体如下表：&quot;&gt;&lt;a href=&quot;#IEEE-745-标准中有三种形式的浮点数，具体如下表：&quot; class=&quot;headerlink&quot; title=&quot;IEEE 745 标准中有三种形式的浮点数，具体如下表：&quot;&gt;&lt;/a&gt;IEEE 745 标准中有三种形式的浮点数，具体如下表：&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="组成原理" scheme="http://quanluo.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="IEEE745" scheme="http://quanluo.github.io/tags/IEEE745/"/>
    
  </entry>
  
  <entry>
    <title>完美解决Mac软件意外退出的方法（软件签名）</title>
    <link href="http://quanluo.github.io/2020/11/23/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3Mac%E8%BD%AF%E4%BB%B6%E6%84%8F%E5%A4%96%E9%80%80%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%AD%BE%E5%90%8D%EF%BC%89/"/>
    <id>http://quanluo.github.io/2020/11/23/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3Mac%E8%BD%AF%E4%BB%B6%E6%84%8F%E5%A4%96%E9%80%80%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%AD%BE%E5%90%8D%EF%BC%89/</id>
    <published>2020-11-23T10:28:53.000Z</published>
    <updated>2020-11-23T10:30:27.036Z</updated>
    
    <content type="html"><![CDATA[<h5 id="因为Apple苹果公司删除了TNT的证书，所以在2019年7月12日后软件都不能运行了，临时的解决办法，就是自己签名，具体往下看。"><a href="#因为Apple苹果公司删除了TNT的证书，所以在2019年7月12日后软件都不能运行了，临时的解决办法，就是自己签名，具体往下看。" class="headerlink" title="因为Apple苹果公司删除了TNT的证书，所以在2019年7月12日后软件都不能运行了，临时的解决办法，就是自己签名，具体往下看。"></a>因为Apple苹果公司删除了TNT的证书，所以在2019年7月12日后软件都不能运行了，临时的解决办法，就是自己签名，具体往下看。</h5><p>比如安装美版的LOL，安装完后，LOL图标会是一个白色的未签名图标，因此，我们需要对lol进行手动签名。</p><p>签名：<br>打开终端工具输入并执行如下命令：<br><code>sudo codesign --force --deep --sign - /Applications/name.app</code><br>注意后面的文件路径，你可以打开访达找到应用程序，找到要签名的软件，直接拖入 终端 界面，即可自动生成路径。</p><h3 id="命令输完回车后，输入你电脑设置的密码就可以了。"><a href="#命令输完回车后，输入你电脑设置的密码就可以了。" class="headerlink" title="命令输完回车后，输入你电脑设置的密码就可以了。"></a>命令输完回车后，输入你电脑设置的密码就可以了。</h3><p><img src="https://img-blog.csdnimg.cn/20201123182537185.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;因为Apple苹果公司删除了TNT的证书，所以在2019年7月12日后软件都不能运行了，临时的解决办法，就是自己签名，具体往下看。&quot;&gt;&lt;a href=&quot;#因为Apple苹果公司删除了TNT的证书，所以在2019年7月12日后软件都不能运行了，临时的解决办法，就是自
      
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>解决Mac电脑连接校园网不弹出登陆窗口问题汇总</title>
    <link href="http://quanluo.github.io/2020/11/13/%E8%A7%A3%E5%86%B3Mac%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%8D%E5%BC%B9%E5%87%BA%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://quanluo.github.io/2020/11/13/%E8%A7%A3%E5%86%B3Mac%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%8D%E5%BC%B9%E5%87%BA%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2020-11-13T02:42:21.000Z</published>
    <updated>2020-11-13T03:01:44.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。"><a href="#1-查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。" class="headerlink" title="1.查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。"></a>1.查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。</h2><p><img src="https://img-blog.csdnimg.cn/20201113102257832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2-有使用梯子的同学，记得把梯子暂时先关闭一下，然后在连接校园网Wi-Fi。"><a href="#2-有使用梯子的同学，记得把梯子暂时先关闭一下，然后在连接校园网Wi-Fi。" class="headerlink" title="2.有使用梯子的同学，记得把梯子暂时先关闭一下，然后在连接校园网Wi-Fi。"></a>2.有使用梯子的同学，记得把梯子暂时先关闭一下，然后在连接校园网Wi-Fi。</h2><h2 id="3-你有登录页面的网址吗？没有的话，让同学复制给你，直接在Safari中访问该网址试试。"><a href="#3-你有登录页面的网址吗？没有的话，让同学复制给你，直接在Safari中访问该网址试试。" class="headerlink" title="3.你有登录页面的网址吗？没有的话，让同学复制给你，直接在Safari中访问该网址试试。"></a>3.你有登录页面的网址吗？没有的话，让同学复制给你，直接在Safari中访问该网址试试。</h2><h2 id="4-如果，你苹果手机是可以弹出来并且正确显示的话，那么请在你的safari的开发—-用户代理—-选择iphone。其实就是让你的mac的safari浏览器来模拟苹果手机浏览器。"><a href="#4-如果，你苹果手机是可以弹出来并且正确显示的话，那么请在你的safari的开发—-用户代理—-选择iphone。其实就是让你的mac的safari浏览器来模拟苹果手机浏览器。" class="headerlink" title="4.如果，你苹果手机是可以弹出来并且正确显示的话，那么请在你的safari的开发—-用户代理—-选择iphone。其实就是让你的mac的safari浏览器来模拟苹果手机浏览器。"></a>4.如果，你苹果手机是可以弹出来并且正确显示的话，那么请在你的safari的开发—-用户代理—-选择iphone。其实就是让你的mac的safari浏览器来模拟苹果手机浏览器。</h2><p><img src="https://img-blog.csdnimg.cn/20201113103349657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>以上就是我汇总的解决Mac电脑连接校园网不弹出登陆窗口问题的办法了，希望对使用mac电脑的同学有帮助.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。&quot;&gt;&lt;a href=&quot;#1-查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。&quot; class=&quot;headerlink&quot; title=&quot;1.查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。&quot;&gt;&lt;/a&gt;1.查看你的DNS有没有改过，把自己改过的DNS全部删除，变更为默认的就好。&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201113102257832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM0NzU1MA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://quanluo.github.io/tags/mac/"/>
    
  </entry>
  
</feed>
